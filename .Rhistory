brk
side_minus[c((brk + 1):nrow(side_minus), setdiff(1:nrow(side_minus), (brk + 1):nrow(side_minus))), ]
c((brk + 1):nrow(side_minus), setdiff(1:nrow(side_minus), (brk + 1):nrow(side_minus)))
side_minus[c((brk + 1):nrow(side_minus), setdiff(c(1:nrow(side_minus)), (brk + 1):nrow(side_minus))), ]
c((brk + 1):nrow(side_minus), setdiff(c(1:nrow(side_minus)), (brk + 1):nrow(side_minus)))
side_minus
(brk + 1)
nrow(side_minus)
nrow(side_minus) == brk
nrow(side_minus) != brk
map_continents <- function(continent_centres, radius, xlim = c(-180, 180), ylim = c(-90, 90), resolution = 1000, sea_colour = "blue", land_colour = "green", ...) {#
# Add grid overlay option:#
# Draw continent links to help visualise separation(s)/collision(s):#
	# Make empty plot:#
	plot(x = c(1, 1), xlim = xlim, ylim = c(-90, 90), type = "n", xlab = "Longitude", ylab = "Latitude")#
	# Fill with blue background (sea):#
	polygon(x = c(-180, 180, 180, -180), y = c(90, 90, -90, -90), border = NA, col = sea_colour)#
#
	# Create empty list to store continent polygons:#
	continent_polygons <- as.list(c(1:nrow(continent_centres)))#
	# For each continent:#
	for(i in 1:nrow(continent_centres)) {#
		# Isolate continent centre:#
		centre <- continent_centres[i, ]#
		# Create empty matrix to store points that will describe the edge of the continent:#
		edge_points <- matrix(nrow = 0, ncol = 2)#
		# For as many points as are dictated by resolution get the jth point describing the edge of the continent:#
		for(j in 1:resolution) edge_points <- rbind(edge_points, unlist(EndPoint(centre[1], centre[2], (360 / resolution) * j, radius)[c("longitude", "latitude")]))#
		# Store full continent in list:#
		continent_polygons[[i]] <- edge_points#
	}#
#
	# Get distances from North pole to each continents centre:#
	North_pole_distances <- One2ManyGreatCircleDistance(0, 90, continent_centres[, 1], continent_centres[, 2])#
	# Get distances from South pole to each continents centre:#
	South_pole_distances <- One2ManyGreatCircleDistance(0, -90, continent_centres[, 1], continent_centres[, 2])#
#
	# Get number(s) of continent(s) that sit over the North pole:#
	continents_at_North_pole <- which((as.numeric(apply(matrix(North_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(North_pole_distances < radius)) == 2)#
	# Get number(s) of continent(s) that sit over the South pole:#
	continents_at_South_pole <- which((as.numeric(apply(matrix(South_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(South_pole_distances < radius)) == 2)#
	# Create a long-lat matrix of points exactly East from current centres and on date line:#
	Wall_centres <- cbind(rep(180, nrow(continent_centres)), continent_centres[, 2])#
	# Create vector to store distances between each of these points and the associated continental centres:#
	Wall_distances <- vector(mode="numeric")#
	# Calculate each of those distances:#
	for(i in 1:nrow(continent_centres)) Wall_distances[i] <- GreatCircleDistanceFromLongLat(Wall_centres[i, 1], Wall_centres[i, 2], continent_centres[i, 1], continent_centres[i, 2])#
#
	# Get just those continents that do straddle the date line:#
	continents_across_date_line <- which((as.numeric(apply(matrix(Wall_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(Wall_distances < radius)) == 2)#
	# Remove continents that only cross the date line because they also overlap the pole:#
	continents_across_date_line <- setdiff(continents_across_date_line, c(continents_at_North_pole, continents_at_South_pole))#
	# If there are continent(s) at the North pole:#
	if(length(continents_at_North_pole) > 0) {#
		# For each continent at the North pole:#
		for(i in continents_at_North_pole) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2]), c(-180, 90), c(180, 90), c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the South pole:#
	if(length(continents_at_South_pole) > 0) {#
#
		# For each continent at the South pole:#
		for(i in continents_at_South_pole) {#
#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2]), c(180, -90), c(-180, -90), c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the North pole:#
	if(length(continents_across_date_line) > 0) {#
		# For each continent that crosses the date line:#
		for(i in continents_across_date_line) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Case if one break falls exactly at the end:#
			if(length(breaks) == 1) breaks <- c(breaks, resolution)#
#
			# Create first half (side one) of continent:#
			side_one <- continent_polygons[[i]][(breaks[1] + 1):(breaks[2]), ]#
			# Create second half (side one) of continent:#
			side_two <- continent_polygons[[i]][c(setdiff(c(1:1000), c(1:breaks[1], (breaks[1] + 1):(breaks[2]))), 1:breaks[1]), ]#
			# Need to assign halves to positive or negative (longitudes) to add extra points:#
			if((side_two[, 2] / abs(side_two[, 2]))[1] == -1) {#
				# Side two is negative:#
				side_minus <- side_two#
				# Side one is negative:#
				side_plus <- side_one#
			# Case if signs are the opposite:#
			} else {#
				# Side one is negative:#
				side_minus <- side_one#
				# Side two is positive:#
				side_plus <- side_two#
#
			}#
			brk <- which.min(side_minus[, 1])#
			if(nrow(side_minus) != brk) side_minus <- side_minus[c((brk + 1):nrow(side_minus), setdiff(c(1:nrow(side_minus)), (brk + 1):nrow(side_minus))), ]#
			brk <- which.max(side_plus[, 1])#
			if(nrow(side_plus) != brk) side_plus <- side_plus[c((brk + 1):nrow(side_plus), setdiff(1:nrow(side_plus), (brk + 1):nrow(side_plus))), ]#
			side_plus <- rbind(side_plus, matrix(c(180, side_plus[nrow(side_plus), 2], 180, side_plus[1, 2]), ncol = 2, byrow = TRUE))#
#
			side_minus <- rbind(side_minus, matrix(c(-180, side_minus[nrow(side_minus), 2], -180, side_minus[1, 2]), ncol = 2, byrow = TRUE))#
# FIND OUT WHICH ENDS WITH MIN ADN WHICH WITH MAX#
			# Make extra polygon points to delineate date-line edge of polygon for side one:#
#side_plus_extra <- matrix(c(180, min(side_plus[, 2]), 180, max(side_plus[, 2])), ncol = 2, byrow = TRUE)#
			# Make extra polygon points to delineate date-line edge of polygon for side two:#
#side_minus_extra <- matrix(c(-180, min(side_minus[, 2]), -180, max(side_minus[, 2])), ncol = 2, byrow = TRUE)#
# SOMETHING WRONG IN HERE!#
			# Add extra points to side one:#
#side_plus <- rbind(side_plus[1:which.max(side_plus[, 2]), ], side_plus_extra, side_plus[setdiff(1:nrow(side_plus), 1:which.max(side_plus[, 2])), ])#
			# Add extra points to side two:#
#side_minus <- rbind(side_minus[1:which.max(side_minus[, 2]), ], side_minus_extra, side_minus[setdiff(1:nrow(side_minus), 1:which.max(side_minus[, 2])), ])#
			# Add two sides as separate polygons to the end of the list:#
			continent_polygons <- c(continent_polygons, list(side_plus), list(side_minus))#
		}#
		# Remove old polygon from the list:#
		continent_polygons <- continent_polygons[-continents_across_date_line]#
	}#
	# Plot continental polygons:#
	#for(i in 1:length(continent_polygons)) polygon(x = continent_polygons[[i]][, 1], y = continent_polygons[[i]][, 2], border = NA, col = land_colour)#
#
	# Plot only side-split continents:#
	for(i in 1:length(continent_polygons)) if(nrow(continent_polygons[[i]]) < resolution) polygon(x = continent_polygons[[i]][, 1], y = continent_polygons[[i]][, 2], border = NA, col = land_colour)#
}#
#
for(i in 1:1000) {#
	continent_centres <- StartingPoints(7, 2000)#
#
	map_continents(continent_centres, radius)#
	Sys.sleep(2)#
}
# Create empty list to store continent polygons:#
	continent_polygons <- as.list(c(1:nrow(continent_centres)))#
	# For each continent:#
	for(i in 1:nrow(continent_centres)) {#
		# Isolate continent centre:#
		centre <- continent_centres[i, ]#
		# Create empty matrix to store points that will describe the edge of the continent:#
		edge_points <- matrix(nrow = 0, ncol = 2)#
		# For as many points as are dictated by resolution get the jth point describing the edge of the continent:#
		for(j in 1:resolution) edge_points <- rbind(edge_points, unlist(EndPoint(centre[1], centre[2], (360 / resolution) * j, radius)[c("longitude", "latitude")]))#
		# Store full continent in list:#
		continent_polygons[[i]] <- edge_points#
	}#
#
	# Get distances from North pole to each continents centre:#
	North_pole_distances <- One2ManyGreatCircleDistance(0, 90, continent_centres[, 1], continent_centres[, 2])#
	# Get distances from South pole to each continents centre:#
	South_pole_distances <- One2ManyGreatCircleDistance(0, -90, continent_centres[, 1], continent_centres[, 2])#
#
	# Get number(s) of continent(s) that sit over the North pole:#
	continents_at_North_pole <- which((as.numeric(apply(matrix(North_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(North_pole_distances < radius)) == 2)#
	# Get number(s) of continent(s) that sit over the South pole:#
	continents_at_South_pole <- which((as.numeric(apply(matrix(South_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(South_pole_distances < radius)) == 2)#
	# Create a long-lat matrix of points exactly East from current centres and on date line:#
	Wall_centres <- cbind(rep(180, nrow(continent_centres)), continent_centres[, 2])#
	# Create vector to store distances between each of these points and the associated continental centres:#
	Wall_distances <- vector(mode="numeric")#
	# Calculate each of those distances:#
	for(i in 1:nrow(continent_centres)) Wall_distances[i] <- GreatCircleDistanceFromLongLat(Wall_centres[i, 1], Wall_centres[i, 2], continent_centres[i, 1], continent_centres[i, 2])#
#
	# Get just those continents that do straddle the date line:#
	continents_across_date_line <- which((as.numeric(apply(matrix(Wall_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(Wall_distances < radius)) == 2)#
	# Remove continents that only cross the date line because they also overlap the pole:#
	continents_across_date_line <- setdiff(continents_across_date_line, c(continents_at_North_pole, continents_at_South_pole))#
	# If there are continent(s) at the North pole:#
	if(length(continents_at_North_pole) > 0) {#
		# For each continent at the North pole:#
		for(i in continents_at_North_pole) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2]), c(-180, 90), c(180, 90), c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the South pole:#
	if(length(continents_at_South_pole) > 0) {#
#
		# For each continent at the South pole:#
		for(i in continents_at_South_pole) {#
#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2]), c(180, -90), c(-180, -90), c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the North pole:#
	if(length(continents_across_date_line) > 0) {#
		# For each continent that crosses the date line:#
		for(i in continents_across_date_line) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Case if one break falls exactly at the end:#
			if(length(breaks) == 1) breaks <- c(breaks, resolution)#
#
			# Create first half (side one) of continent:#
			side_one <- continent_polygons[[i]][(breaks[1] + 1):(breaks[2]), ]#
			# Create second half (side one) of continent:#
			side_two <- continent_polygons[[i]][c(setdiff(c(1:1000), c(1:breaks[1], (breaks[1] + 1):(breaks[2]))), 1:breaks[1]), ]#
			# Need to assign halves to positive or negative (longitudes) to add extra points:#
			if((side_two[, 2] / abs(side_two[, 2]))[1] == -1) {#
				# Side two is negative:#
				side_minus <- side_two#
				# Side one is negative:#
				side_plus <- side_one#
			# Case if signs are the opposite:#
			} else {#
				# Side one is negative:#
				side_minus <- side_one#
				# Side two is positive:#
				side_plus <- side_two#
#
			}#
			brk <- which.min(side_minus[, 1])#
			if(nrow(side_minus) != brk) side_minus <- side_minus[c((brk + 1):nrow(side_minus), setdiff(c(1:nrow(side_minus)), (brk + 1):nrow(side_minus))), ]#
			brk <- which.max(side_plus[, 1])#
			if(nrow(side_plus) != brk) side_plus <- side_plus[c((brk + 1):nrow(side_plus), setdiff(1:nrow(side_plus), (brk + 1):nrow(side_plus))), ]#
			side_plus <- rbind(side_plus, matrix(c(180, side_plus[nrow(side_plus), 2], 180, side_plus[1, 2]), ncol = 2, byrow = TRUE))#
#
			side_minus <- rbind(side_minus, matrix(c(-180, side_minus[nrow(side_minus), 2], -180, side_minus[1, 2]), ncol = 2, byrow = TRUE))#
# FIND OUT WHICH ENDS WITH MIN ADN WHICH WITH MAX#
			# Make extra polygon points to delineate date-line edge of polygon for side one:#
#side_plus_extra <- matrix(c(180, min(side_plus[, 2]), 180, max(side_plus[, 2])), ncol = 2, byrow = TRUE)#
			# Make extra polygon points to delineate date-line edge of polygon for side two:#
#side_minus_extra <- matrix(c(-180, min(side_minus[, 2]), -180, max(side_minus[, 2])), ncol = 2, byrow = TRUE)#
# SOMETHING WRONG IN HERE!#
			# Add extra points to side one:#
#side_plus <- rbind(side_plus[1:which.max(side_plus[, 2]), ], side_plus_extra, side_plus[setdiff(1:nrow(side_plus), 1:which.max(side_plus[, 2])), ])#
			# Add extra points to side two:#
#side_minus <- rbind(side_minus[1:which.max(side_minus[, 2]), ], side_minus_extra, side_minus[setdiff(1:nrow(side_minus), 1:which.max(side_minus[, 2])), ])#
			# Add two sides as separate polygons to the end of the list:#
			continent_polygons <- c(continent_polygons, list(side_plus), list(side_minus))#
		}#
		# Remove old polygon from the list:#
		continent_polygons <- continent_polygons[-continents_across_date_line]#
	}
continent_polygons
# Create empty list to store continent polygons:#
	continent_polygons <- as.list(c(1:nrow(continent_centres)))#
	# For each continent:#
	for(i in 1:nrow(continent_centres)) {#
		# Isolate continent centre:#
		centre <- continent_centres[i, ]#
		# Create empty matrix to store points that will describe the edge of the continent:#
		edge_points <- matrix(nrow = 0, ncol = 2)#
		# For as many points as are dictated by resolution get the jth point describing the edge of the continent:#
		for(j in 1:resolution) edge_points <- rbind(edge_points, unlist(EndPoint(centre[1], centre[2], (360 / resolution) * j, radius)[c("longitude", "latitude")]))#
		# Store full continent in list:#
		continent_polygons[[i]] <- edge_points#
	}#
#
	# Get distances from North pole to each continents centre:#
	North_pole_distances <- One2ManyGreatCircleDistance(0, 90, continent_centres[, 1], continent_centres[, 2])#
	# Get distances from South pole to each continents centre:#
	South_pole_distances <- One2ManyGreatCircleDistance(0, -90, continent_centres[, 1], continent_centres[, 2])#
#
	# Get number(s) of continent(s) that sit over the North pole:#
	continents_at_North_pole <- which((as.numeric(apply(matrix(North_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(North_pole_distances < radius)) == 2)#
	# Get number(s) of continent(s) that sit over the South pole:#
	continents_at_South_pole <- which((as.numeric(apply(matrix(South_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(South_pole_distances < radius)) == 2)#
	# Create a long-lat matrix of points exactly East from current centres and on date line:#
	Wall_centres <- cbind(rep(180, nrow(continent_centres)), continent_centres[, 2])#
	# Create vector to store distances between each of these points and the associated continental centres:#
	Wall_distances <- vector(mode="numeric")#
	# Calculate each of those distances:#
	for(i in 1:nrow(continent_centres)) Wall_distances[i] <- GreatCircleDistanceFromLongLat(Wall_centres[i, 1], Wall_centres[i, 2], continent_centres[i, 1], continent_centres[i, 2])#
#
	# Get just those continents that do straddle the date line:#
	continents_across_date_line <- which((as.numeric(apply(matrix(Wall_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(Wall_distances < radius)) == 2)#
	# Remove continents that only cross the date line because they also overlap the pole:#
	continents_across_date_line <- setdiff(continents_across_date_line, c(continents_at_North_pole, continents_at_South_pole))#
	# If there are continent(s) at the North pole:#
	if(length(continents_at_North_pole) > 0) {#
		# For each continent at the North pole:#
		for(i in continents_at_North_pole) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2]), c(-180, 90), c(180, 90), c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the South pole:#
	if(length(continents_at_South_pole) > 0) {#
#
		# For each continent at the South pole:#
		for(i in continents_at_South_pole) {#
#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2]), c(180, -90), c(-180, -90), c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}
# For each continent that crosses the date line:#
		for(i in continents_across_date_line) {
}
i
# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Case if one break falls exactly at the end:#
			if(length(breaks) == 1) breaks <- c(breaks, resolution)#
#
			# Create first half (side one) of continent:#
			side_one <- continent_polygons[[i]][(breaks[1] + 1):(breaks[2]), ]#
			# Create second half (side one) of continent:#
			side_two <- continent_polygons[[i]][c(setdiff(c(1:1000), c(1:breaks[1], (breaks[1] + 1):(breaks[2]))), 1:breaks[1]), ]
side_one
side_two
(side_two[, 2] / abs(side_two[, 2]))[1]
side_two
(side_two[, 1] / abs(side_two[, 1]))[1]
map_continents <- function(continent_centres, radius, xlim = c(-180, 180), ylim = c(-90, 90), resolution = 1000, sea_colour = "blue", land_colour = "green", ...) {#
# Add grid overlay option:#
# Draw continent links to help visualise separation(s)/collision(s):#
	# Make empty plot:#
	plot(x = c(1, 1), xlim = xlim, ylim = c(-90, 90), type = "n", xlab = "Longitude", ylab = "Latitude")#
	# Fill with blue background (sea):#
	polygon(x = c(-180, 180, 180, -180), y = c(90, 90, -90, -90), border = NA, col = sea_colour)#
#
	# Create empty list to store continent polygons:#
	continent_polygons <- as.list(c(1:nrow(continent_centres)))#
	# For each continent:#
	for(i in 1:nrow(continent_centres)) {#
		# Isolate continent centre:#
		centre <- continent_centres[i, ]#
		# Create empty matrix to store points that will describe the edge of the continent:#
		edge_points <- matrix(nrow = 0, ncol = 2)#
		# For as many points as are dictated by resolution get the jth point describing the edge of the continent:#
		for(j in 1:resolution) edge_points <- rbind(edge_points, unlist(EndPoint(centre[1], centre[2], (360 / resolution) * j, radius)[c("longitude", "latitude")]))#
		# Store full continent in list:#
		continent_polygons[[i]] <- edge_points#
	}#
#
	# Get distances from North pole to each continents centre:#
	North_pole_distances <- One2ManyGreatCircleDistance(0, 90, continent_centres[, 1], continent_centres[, 2])#
	# Get distances from South pole to each continents centre:#
	South_pole_distances <- One2ManyGreatCircleDistance(0, -90, continent_centres[, 1], continent_centres[, 2])#
#
	# Get number(s) of continent(s) that sit over the North pole:#
	continents_at_North_pole <- which((as.numeric(apply(matrix(North_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(North_pole_distances < radius)) == 2)#
	# Get number(s) of continent(s) that sit over the South pole:#
	continents_at_South_pole <- which((as.numeric(apply(matrix(South_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(South_pole_distances < radius)) == 2)#
	# Create a long-lat matrix of points exactly East from current centres and on date line:#
	Wall_centres <- cbind(rep(180, nrow(continent_centres)), continent_centres[, 2])#
	# Create vector to store distances between each of these points and the associated continental centres:#
	Wall_distances <- vector(mode="numeric")#
	# Calculate each of those distances:#
	for(i in 1:nrow(continent_centres)) Wall_distances[i] <- GreatCircleDistanceFromLongLat(Wall_centres[i, 1], Wall_centres[i, 2], continent_centres[i, 1], continent_centres[i, 2])#
#
	# Get just those continents that do straddle the date line:#
	continents_across_date_line <- which((as.numeric(apply(matrix(Wall_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(Wall_distances < radius)) == 2)#
	# Remove continents that only cross the date line because they also overlap the pole:#
	continents_across_date_line <- setdiff(continents_across_date_line, c(continents_at_North_pole, continents_at_South_pole))#
	# If there are continent(s) at the North pole:#
	if(length(continents_at_North_pole) > 0) {#
		# For each continent at the North pole:#
		for(i in continents_at_North_pole) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2]), c(-180, 90), c(180, 90), c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the South pole:#
	if(length(continents_at_South_pole) > 0) {#
#
		# For each continent at the South pole:#
		for(i in continents_at_South_pole) {#
#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2]), c(180, -90), c(-180, -90), c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the North pole:#
	if(length(continents_across_date_line) > 0) {#
		# For each continent that crosses the date line:#
		for(i in continents_across_date_line) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Case if one break falls exactly at the end:#
			if(length(breaks) == 1) breaks <- c(breaks, resolution)#
#
			# Create first half (side one) of continent:#
			side_one <- continent_polygons[[i]][(breaks[1] + 1):(breaks[2]), ]#
			# Create second half (side one) of continent:#
			side_two <- continent_polygons[[i]][c(setdiff(c(1:1000), c(1:breaks[1], (breaks[1] + 1):(breaks[2]))), 1:breaks[1]), ]#
			# Need to assign halves to positive or negative (longitudes) to add extra points:#
			if((side_two[, 1] / abs(side_two[, 1]))[1] == -1) {#
				# Side two is negative:#
				side_minus <- side_two#
				# Side one is negative:#
				side_plus <- side_one#
			# Case if signs are the opposite:#
			} else {#
				# Side one is negative:#
				side_minus <- side_one#
				# Side two is positive:#
				side_plus <- side_two#
#
			}#
			brk <- which.min(side_minus[, 1])#
			if(nrow(side_minus) != brk) side_minus <- side_minus[c((brk + 1):nrow(side_minus), setdiff(c(1:nrow(side_minus)), (brk + 1):nrow(side_minus))), ]#
			brk <- which.max(side_plus[, 1])#
			if(nrow(side_plus) != brk) side_plus <- side_plus[c((brk + 1):nrow(side_plus), setdiff(1:nrow(side_plus), (brk + 1):nrow(side_plus))), ]#
			side_plus <- rbind(side_plus, matrix(c(180, side_plus[nrow(side_plus), 2], 180, side_plus[1, 2]), ncol = 2, byrow = TRUE))#
#
			side_minus <- rbind(side_minus, matrix(c(-180, side_minus[nrow(side_minus), 2], -180, side_minus[1, 2]), ncol = 2, byrow = TRUE))#
# FIND OUT WHICH ENDS WITH MIN ADN WHICH WITH MAX#
			# Make extra polygon points to delineate date-line edge of polygon for side one:#
#side_plus_extra <- matrix(c(180, min(side_plus[, 2]), 180, max(side_plus[, 2])), ncol = 2, byrow = TRUE)#
			# Make extra polygon points to delineate date-line edge of polygon for side two:#
#side_minus_extra <- matrix(c(-180, min(side_minus[, 2]), -180, max(side_minus[, 2])), ncol = 2, byrow = TRUE)#
# SOMETHING WRONG IN HERE!#
			# Add extra points to side one:#
#side_plus <- rbind(side_plus[1:which.max(side_plus[, 2]), ], side_plus_extra, side_plus[setdiff(1:nrow(side_plus), 1:which.max(side_plus[, 2])), ])#
			# Add extra points to side two:#
#side_minus <- rbind(side_minus[1:which.max(side_minus[, 2]), ], side_minus_extra, side_minus[setdiff(1:nrow(side_minus), 1:which.max(side_minus[, 2])), ])#
			# Add two sides as separate polygons to the end of the list:#
			continent_polygons <- c(continent_polygons, list(side_plus), list(side_minus))#
		}#
		# Remove old polygon from the list:#
		continent_polygons <- continent_polygons[-continents_across_date_line]#
	}#
	# Plot continental polygons:#
	#for(i in 1:length(continent_polygons)) polygon(x = continent_polygons[[i]][, 1], y = continent_polygons[[i]][, 2], border = NA, col = land_colour)#
#
	# Plot only side-split continents:#
	for(i in 1:length(continent_polygons)) if(nrow(continent_polygons[[i]]) < resolution) polygon(x = continent_polygons[[i]][, 1], y = continent_polygons[[i]][, 2], border = NA, col = land_colour)#
}#
#
for(i in 1:1000) {#
	continent_centres <- StartingPoints(7, 2000)#
#
	map_continents(continent_centres, radius)#
	Sys.sleep(2)#
}
continent_centres
continent_centres[1,] <- c(177, 85)
# Create empty list to store continent polygons:#
	continent_polygons <- as.list(c(1:nrow(continent_centres)))#
	# For each continent:#
	for(i in 1:nrow(continent_centres)) {#
		# Isolate continent centre:#
		centre <- continent_centres[i, ]#
		# Create empty matrix to store points that will describe the edge of the continent:#
		edge_points <- matrix(nrow = 0, ncol = 2)#
		# For as many points as are dictated by resolution get the jth point describing the edge of the continent:#
		for(j in 1:resolution) edge_points <- rbind(edge_points, unlist(EndPoint(centre[1], centre[2], (360 / resolution) * j, radius)[c("longitude", "latitude")]))#
		# Store full continent in list:#
		continent_polygons[[i]] <- edge_points#
	}#
#
	# Get distances from North pole to each continents centre:#
	North_pole_distances <- One2ManyGreatCircleDistance(0, 90, continent_centres[, 1], continent_centres[, 2])#
	# Get distances from South pole to each continents centre:#
	South_pole_distances <- One2ManyGreatCircleDistance(0, -90, continent_centres[, 1], continent_centres[, 2])#
#
	# Get number(s) of continent(s) that sit over the North pole:#
	continents_at_North_pole <- which((as.numeric(apply(matrix(North_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(North_pole_distances < radius)) == 2)#
	# Get number(s) of continent(s) that sit over the South pole:#
	continents_at_South_pole <- which((as.numeric(apply(matrix(South_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(South_pole_distances < radius)) == 2)#
	# Create a long-lat matrix of points exactly East from current centres and on date line:#
	Wall_centres <- cbind(rep(180, nrow(continent_centres)), continent_centres[, 2])#
	# Create vector to store distances between each of these points and the associated continental centres:#
	Wall_distances <- vector(mode="numeric")#
	# Calculate each of those distances:#
	for(i in 1:nrow(continent_centres)) Wall_distances[i] <- GreatCircleDistanceFromLongLat(Wall_centres[i, 1], Wall_centres[i, 2], continent_centres[i, 1], continent_centres[i, 2])#
#
	# Get just those continents that do straddle the date line:#
	continents_across_date_line <- which((as.numeric(apply(matrix(Wall_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(Wall_distances < radius)) == 2)#
	# Remove continents that only cross the date line because they also overlap the pole:#
	continents_across_date_line <- setdiff(continents_across_date_line, c(continents_at_North_pole, continents_at_South_pole))#
	# If there are continent(s) at the North pole:#
	if(length(continents_at_North_pole) > 0) {#
		# For each continent at the North pole:#
		for(i in continents_at_North_pole) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2]), c(-180, 90), c(180, 90), c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the South pole:#
	if(length(continents_at_South_pole) > 0) {#
#
		# For each continent at the South pole:#
		for(i in continents_at_South_pole) {#
#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2]), c(180, -90), c(-180, -90), c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}
continents_across_date_line
continent_centres[1,] <- c(177, 83)
# Create empty list to store continent polygons:#
	continent_polygons <- as.list(c(1:nrow(continent_centres)))#
	# For each continent:#
	for(i in 1:nrow(continent_centres)) {#
		# Isolate continent centre:#
		centre <- continent_centres[i, ]#
		# Create empty matrix to store points that will describe the edge of the continent:#
		edge_points <- matrix(nrow = 0, ncol = 2)#
		# For as many points as are dictated by resolution get the jth point describing the edge of the continent:#
		for(j in 1:resolution) edge_points <- rbind(edge_points, unlist(EndPoint(centre[1], centre[2], (360 / resolution) * j, radius)[c("longitude", "latitude")]))#
		# Store full continent in list:#
		continent_polygons[[i]] <- edge_points#
	}#
#
	# Get distances from North pole to each continents centre:#
	North_pole_distances <- One2ManyGreatCircleDistance(0, 90, continent_centres[, 1], continent_centres[, 2])#
	# Get distances from South pole to each continents centre:#
	South_pole_distances <- One2ManyGreatCircleDistance(0, -90, continent_centres[, 1], continent_centres[, 2])#
#
	# Get number(s) of continent(s) that sit over the North pole:#
	continents_at_North_pole <- which((as.numeric(apply(matrix(North_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(North_pole_distances < radius)) == 2)#
	# Get number(s) of continent(s) that sit over the South pole:#
	continents_at_South_pole <- which((as.numeric(apply(matrix(South_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(South_pole_distances < radius)) == 2)#
	# Create a long-lat matrix of points exactly East from current centres and on date line:#
	Wall_centres <- cbind(rep(180, nrow(continent_centres)), continent_centres[, 2])#
	# Create vector to store distances between each of these points and the associated continental centres:#
	Wall_distances <- vector(mode="numeric")#
	# Calculate each of those distances:#
	for(i in 1:nrow(continent_centres)) Wall_distances[i] <- GreatCircleDistanceFromLongLat(Wall_centres[i, 1], Wall_centres[i, 2], continent_centres[i, 1], continent_centres[i, 2])#
#
	# Get just those continents that do straddle the date line:#
	continents_across_date_line <- which((as.numeric(apply(matrix(Wall_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(Wall_distances < radius)) == 2)#
	# Remove continents that only cross the date line because they also overlap the pole:#
	continents_across_date_line <- setdiff(continents_across_date_line, c(continents_at_North_pole, continents_at_South_pole))#
	# If there are continent(s) at the North pole:#
	if(length(continents_at_North_pole) > 0) {#
		# For each continent at the North pole:#
		for(i in continents_at_North_pole) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2]), c(-180, 90), c(180, 90), c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the South pole:#
	if(length(continents_at_South_pole) > 0) {#
#
		# For each continent at the South pole:#
		for(i in continents_at_South_pole) {#
#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2]), c(180, -90), c(-180, -90), c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}
continents_across_date_line
continent_centres[1,] <- c(177, 80)
# Create empty list to store continent polygons:#
	continent_polygons <- as.list(c(1:nrow(continent_centres)))#
	# For each continent:#
	for(i in 1:nrow(continent_centres)) {#
		# Isolate continent centre:#
		centre <- continent_centres[i, ]#
		# Create empty matrix to store points that will describe the edge of the continent:#
		edge_points <- matrix(nrow = 0, ncol = 2)#
		# For as many points as are dictated by resolution get the jth point describing the edge of the continent:#
		for(j in 1:resolution) edge_points <- rbind(edge_points, unlist(EndPoint(centre[1], centre[2], (360 / resolution) * j, radius)[c("longitude", "latitude")]))#
		# Store full continent in list:#
		continent_polygons[[i]] <- edge_points#
	}#
#
	# Get distances from North pole to each continents centre:#
	North_pole_distances <- One2ManyGreatCircleDistance(0, 90, continent_centres[, 1], continent_centres[, 2])#
	# Get distances from South pole to each continents centre:#
	South_pole_distances <- One2ManyGreatCircleDistance(0, -90, continent_centres[, 1], continent_centres[, 2])#
#
	# Get number(s) of continent(s) that sit over the North pole:#
	continents_at_North_pole <- which((as.numeric(apply(matrix(North_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(North_pole_distances < radius)) == 2)#
	# Get number(s) of continent(s) that sit over the South pole:#
	continents_at_South_pole <- which((as.numeric(apply(matrix(South_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(South_pole_distances < radius)) == 2)#
	# Create a long-lat matrix of points exactly East from current centres and on date line:#
	Wall_centres <- cbind(rep(180, nrow(continent_centres)), continent_centres[, 2])#
	# Create vector to store distances between each of these points and the associated continental centres:#
	Wall_distances <- vector(mode="numeric")#
	# Calculate each of those distances:#
	for(i in 1:nrow(continent_centres)) Wall_distances[i] <- GreatCircleDistanceFromLongLat(Wall_centres[i, 1], Wall_centres[i, 2], continent_centres[i, 1], continent_centres[i, 2])#
#
	# Get just those continents that do straddle the date line:#
	continents_across_date_line <- which((as.numeric(apply(matrix(Wall_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(Wall_distances < radius)) == 2)#
	# Remove continents that only cross the date line because they also overlap the pole:#
	continents_across_date_line <- setdiff(continents_across_date_line, c(continents_at_North_pole, continents_at_South_pole))#
	# If there are continent(s) at the North pole:#
	if(length(continents_at_North_pole) > 0) {#
		# For each continent at the North pole:#
		for(i in continents_at_North_pole) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2]), c(-180, 90), c(180, 90), c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the South pole:#
	if(length(continents_at_South_pole) > 0) {#
#
		# For each continent at the South pole:#
		for(i in continents_at_South_pole) {#
#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2]), c(180, -90), c(-180, -90), c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}
continents_across_date_line
continent_centres[1,] <- c(177, 75)
# Create empty list to store continent polygons:#
	continent_polygons <- as.list(c(1:nrow(continent_centres)))#
	# For each continent:#
	for(i in 1:nrow(continent_centres)) {#
		# Isolate continent centre:#
		centre <- continent_centres[i, ]#
		# Create empty matrix to store points that will describe the edge of the continent:#
		edge_points <- matrix(nrow = 0, ncol = 2)#
		# For as many points as are dictated by resolution get the jth point describing the edge of the continent:#
		for(j in 1:resolution) edge_points <- rbind(edge_points, unlist(EndPoint(centre[1], centre[2], (360 / resolution) * j, radius)[c("longitude", "latitude")]))#
		# Store full continent in list:#
		continent_polygons[[i]] <- edge_points#
	}#
#
	# Get distances from North pole to each continents centre:#
	North_pole_distances <- One2ManyGreatCircleDistance(0, 90, continent_centres[, 1], continent_centres[, 2])#
	# Get distances from South pole to each continents centre:#
	South_pole_distances <- One2ManyGreatCircleDistance(0, -90, continent_centres[, 1], continent_centres[, 2])#
#
	# Get number(s) of continent(s) that sit over the North pole:#
	continents_at_North_pole <- which((as.numeric(apply(matrix(North_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(North_pole_distances < radius)) == 2)#
	# Get number(s) of continent(s) that sit over the South pole:#
	continents_at_South_pole <- which((as.numeric(apply(matrix(South_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(South_pole_distances < radius)) == 2)#
	# Create a long-lat matrix of points exactly East from current centres and on date line:#
	Wall_centres <- cbind(rep(180, nrow(continent_centres)), continent_centres[, 2])#
	# Create vector to store distances between each of these points and the associated continental centres:#
	Wall_distances <- vector(mode="numeric")#
	# Calculate each of those distances:#
	for(i in 1:nrow(continent_centres)) Wall_distances[i] <- GreatCircleDistanceFromLongLat(Wall_centres[i, 1], Wall_centres[i, 2], continent_centres[i, 1], continent_centres[i, 2])#
#
	# Get just those continents that do straddle the date line:#
	continents_across_date_line <- which((as.numeric(apply(matrix(Wall_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(Wall_distances < radius)) == 2)#
	# Remove continents that only cross the date line because they also overlap the pole:#
	continents_across_date_line <- setdiff(continents_across_date_line, c(continents_at_North_pole, continents_at_South_pole))#
	# If there are continent(s) at the North pole:#
	if(length(continents_at_North_pole) > 0) {#
		# For each continent at the North pole:#
		for(i in continents_at_North_pole) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2]), c(-180, 90), c(180, 90), c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the South pole:#
	if(length(continents_at_South_pole) > 0) {#
#
		# For each continent at the South pole:#
		for(i in continents_at_South_pole) {#
#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2]), c(180, -90), c(-180, -90), c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}
continents_across_date_line
continent_centres
continent_centres[1,] <- c(177, 70)
# Create empty list to store continent polygons:#
	continent_polygons <- as.list(c(1:nrow(continent_centres)))#
	# For each continent:#
	for(i in 1:nrow(continent_centres)) {#
		# Isolate continent centre:#
		centre <- continent_centres[i, ]#
		# Create empty matrix to store points that will describe the edge of the continent:#
		edge_points <- matrix(nrow = 0, ncol = 2)#
		# For as many points as are dictated by resolution get the jth point describing the edge of the continent:#
		for(j in 1:resolution) edge_points <- rbind(edge_points, unlist(EndPoint(centre[1], centre[2], (360 / resolution) * j, radius)[c("longitude", "latitude")]))#
		# Store full continent in list:#
		continent_polygons[[i]] <- edge_points#
	}#
#
	# Get distances from North pole to each continents centre:#
	North_pole_distances <- One2ManyGreatCircleDistance(0, 90, continent_centres[, 1], continent_centres[, 2])#
	# Get distances from South pole to each continents centre:#
	South_pole_distances <- One2ManyGreatCircleDistance(0, -90, continent_centres[, 1], continent_centres[, 2])#
#
	# Get number(s) of continent(s) that sit over the North pole:#
	continents_at_North_pole <- which((as.numeric(apply(matrix(North_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(North_pole_distances < radius)) == 2)#
	# Get number(s) of continent(s) that sit over the South pole:#
	continents_at_South_pole <- which((as.numeric(apply(matrix(South_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(South_pole_distances < radius)) == 2)#
	# Create a long-lat matrix of points exactly East from current centres and on date line:#
	Wall_centres <- cbind(rep(180, nrow(continent_centres)), continent_centres[, 2])#
	# Create vector to store distances between each of these points and the associated continental centres:#
	Wall_distances <- vector(mode="numeric")#
	# Calculate each of those distances:#
	for(i in 1:nrow(continent_centres)) Wall_distances[i] <- GreatCircleDistanceFromLongLat(Wall_centres[i, 1], Wall_centres[i, 2], continent_centres[i, 1], continent_centres[i, 2])#
#
	# Get just those continents that do straddle the date line:#
	continents_across_date_line <- which((as.numeric(apply(matrix(Wall_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(Wall_distances < radius)) == 2)#
	# Remove continents that only cross the date line because they also overlap the pole:#
	continents_across_date_line <- setdiff(continents_across_date_line, c(continents_at_North_pole, continents_at_South_pole))#
	# If there are continent(s) at the North pole:#
	if(length(continents_at_North_pole) > 0) {#
		# For each continent at the North pole:#
		for(i in continents_at_North_pole) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2]), c(-180, 90), c(180, 90), c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the South pole:#
	if(length(continents_at_South_pole) > 0) {#
#
		# For each continent at the South pole:#
		for(i in continents_at_South_pole) {#
#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2]), c(180, -90), c(-180, -90), c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}
continents_across_date_line
# For each continent that crosses the date line:#
		for(i in continents_across_date_line) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Case if one break falls exactly at the end:#
			if(length(breaks) == 1) breaks <- c(breaks, resolution)#
#
			# Create first half (side one) of continent:#
			side_one <- continent_polygons[[i]][(breaks[1] + 1):(breaks[2]), ]#
			# Create second half (side one) of continent:#
			side_two <- continent_polygons[[i]][c(setdiff(c(1:1000), c(1:breaks[1], (breaks[1] + 1):(breaks[2]))), 1:breaks[1]), ]#
			# Need to assign halves to positive or negative (longitudes) to add extra points:#
			if((side_two[, 1] / abs(side_two[, 1]))[1] == -1) {#
				# Side two is negative:#
				side_minus <- side_two#
				# Side one is negative:#
				side_plus <- side_one#
			# Case if signs are the opposite:#
			} else {#
				# Side one is negative:#
				side_minus <- side_one#
				# Side two is positive:#
				side_plus <- side_two#
#
			}#
			brk <- which.min(side_minus[, 1])#
			if(nrow(side_minus) != brk) side_minus <- side_minus[c((brk + 1):nrow(side_minus), setdiff(c(1:nrow(side_minus)), (brk + 1):nrow(side_minus))), ]#
			brk <- which.max(side_plus[, 1])#
			if(nrow(side_plus) != brk) side_plus <- side_plus[c((brk + 1):nrow(side_plus), setdiff(1:nrow(side_plus), (brk + 1):nrow(side_plus))), ]#
			side_plus <- rbind(side_plus, matrix(c(180, side_plus[nrow(side_plus), 2], 180, side_plus[1, 2]), ncol = 2, byrow = TRUE))#
#
			side_minus <- rbind(side_minus, matrix(c(-180, side_minus[nrow(side_minus), 2], -180, side_minus[1, 2]), ncol = 2, byrow = TRUE))#
# FIND OUT WHICH ENDS WITH MIN ADN WHICH WITH MAX#
			# Make extra polygon points to delineate date-line edge of polygon for side one:#
#side_plus_extra <- matrix(c(180, min(side_plus[, 2]), 180, max(side_plus[, 2])), ncol = 2, byrow = TRUE)#
			# Make extra polygon points to delineate date-line edge of polygon for side two:#
#side_minus_extra <- matrix(c(-180, min(side_minus[, 2]), -180, max(side_minus[, 2])), ncol = 2, byrow = TRUE)#
# SOMETHING WRONG IN HERE!#
			# Add extra points to side one:#
#side_plus <- rbind(side_plus[1:which.max(side_plus[, 2]), ], side_plus_extra, side_plus[setdiff(1:nrow(side_plus), 1:which.max(side_plus[, 2])), ])#
			# Add extra points to side two:#
#side_minus <- rbind(side_minus[1:which.max(side_minus[, 2]), ], side_minus_extra, side_minus[setdiff(1:nrow(side_minus), 1:which.max(side_minus[, 2])), ])#
			# Add two sides as separate polygons to the end of the list:#
			continent_polygons <- c(continent_polygons, list(side_plus), list(side_minus))#
		}#
		# Remove old polygon from the list:#
		continent_polygons <- continent_polygons[-continents_across_date_line]#
	}
# Create empty list to store continent polygons:#
	continent_polygons <- as.list(c(1:nrow(continent_centres)))#
	# For each continent:#
	for(i in 1:nrow(continent_centres)) {#
		# Isolate continent centre:#
		centre <- continent_centres[i, ]#
		# Create empty matrix to store points that will describe the edge of the continent:#
		edge_points <- matrix(nrow = 0, ncol = 2)#
		# For as many points as are dictated by resolution get the jth point describing the edge of the continent:#
		for(j in 1:resolution) edge_points <- rbind(edge_points, unlist(EndPoint(centre[1], centre[2], (360 / resolution) * j, radius)[c("longitude", "latitude")]))#
		# Store full continent in list:#
		continent_polygons[[i]] <- edge_points#
	}#
#
	# Get distances from North pole to each continents centre:#
	North_pole_distances <- One2ManyGreatCircleDistance(0, 90, continent_centres[, 1], continent_centres[, 2])#
	# Get distances from South pole to each continents centre:#
	South_pole_distances <- One2ManyGreatCircleDistance(0, -90, continent_centres[, 1], continent_centres[, 2])#
#
	# Get number(s) of continent(s) that sit over the North pole:#
	continents_at_North_pole <- which((as.numeric(apply(matrix(North_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(North_pole_distances < radius)) == 2)#
	# Get number(s) of continent(s) that sit over the South pole:#
	continents_at_South_pole <- which((as.numeric(apply(matrix(South_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(South_pole_distances < radius)) == 2)#
	# Create a long-lat matrix of points exactly East from current centres and on date line:#
	Wall_centres <- cbind(rep(180, nrow(continent_centres)), continent_centres[, 2])#
	# Create vector to store distances between each of these points and the associated continental centres:#
	Wall_distances <- vector(mode="numeric")#
	# Calculate each of those distances:#
	for(i in 1:nrow(continent_centres)) Wall_distances[i] <- GreatCircleDistanceFromLongLat(Wall_centres[i, 1], Wall_centres[i, 2], continent_centres[i, 1], continent_centres[i, 2])#
#
	# Get just those continents that do straddle the date line:#
	continents_across_date_line <- which((as.numeric(apply(matrix(Wall_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(Wall_distances < radius)) == 2)#
	# Remove continents that only cross the date line because they also overlap the pole:#
	continents_across_date_line <- setdiff(continents_across_date_line, c(continents_at_North_pole, continents_at_South_pole))#
	# If there are continent(s) at the North pole:#
	if(length(continents_at_North_pole) > 0) {#
		# For each continent at the North pole:#
		for(i in continents_at_North_pole) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2]), c(-180, 90), c(180, 90), c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the South pole:#
	if(length(continents_at_South_pole) > 0) {#
#
		# For each continent at the South pole:#
		for(i in continents_at_South_pole) {#
#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2]), c(180, -90), c(-180, -90), c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the North pole:#
	if(length(continents_across_date_line) > 0) {#
		# For each continent that crosses the date line:#
		for(i in continents_across_date_line) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Case if one break falls exactly at the end:#
			if(length(breaks) == 1) breaks <- c(breaks, resolution)#
#
			# Create first half (side one) of continent:#
			side_one <- continent_polygons[[i]][(breaks[1] + 1):(breaks[2]), ]#
			# Create second half (side one) of continent:#
			side_two <- continent_polygons[[i]][c(setdiff(c(1:1000), c(1:breaks[1], (breaks[1] + 1):(breaks[2]))), 1:breaks[1]), ]#
			# Need to assign halves to positive or negative (longitudes) to add extra points:#
			if((side_two[, 1] / abs(side_two[, 1]))[1] == -1) {#
				# Side two is negative:#
				side_minus <- side_two#
				# Side one is negative:#
				side_plus <- side_one#
			# Case if signs are the opposite:#
			} else {#
				# Side one is negative:#
				side_minus <- side_one#
				# Side two is positive:#
				side_plus <- side_two#
#
			}#
			brk <- which.min(side_minus[, 1])#
			if(nrow(side_minus) != brk) side_minus <- side_minus[c((brk + 1):nrow(side_minus), setdiff(c(1:nrow(side_minus)), (brk + 1):nrow(side_minus))), ]#
			brk <- which.max(side_plus[, 1])#
			if(nrow(side_plus) != brk) side_plus <- side_plus[c((brk + 1):nrow(side_plus), setdiff(1:nrow(side_plus), (brk + 1):nrow(side_plus))), ]#
			side_plus <- rbind(side_plus, matrix(c(180, side_plus[nrow(side_plus), 2], 180, side_plus[1, 2]), ncol = 2, byrow = TRUE))#
#
			side_minus <- rbind(side_minus, matrix(c(-180, side_minus[nrow(side_minus), 2], -180, side_minus[1, 2]), ncol = 2, byrow = TRUE))#
# FIND OUT WHICH ENDS WITH MIN ADN WHICH WITH MAX#
			# Make extra polygon points to delineate date-line edge of polygon for side one:#
#side_plus_extra <- matrix(c(180, min(side_plus[, 2]), 180, max(side_plus[, 2])), ncol = 2, byrow = TRUE)#
			# Make extra polygon points to delineate date-line edge of polygon for side two:#
#side_minus_extra <- matrix(c(-180, min(side_minus[, 2]), -180, max(side_minus[, 2])), ncol = 2, byrow = TRUE)#
# SOMETHING WRONG IN HERE!#
			# Add extra points to side one:#
#side_plus <- rbind(side_plus[1:which.max(side_plus[, 2]), ], side_plus_extra, side_plus[setdiff(1:nrow(side_plus), 1:which.max(side_plus[, 2])), ])#
			# Add extra points to side two:#
#side_minus <- rbind(side_minus[1:which.max(side_minus[, 2]), ], side_minus_extra, side_minus[setdiff(1:nrow(side_minus), 1:which.max(side_minus[, 2])), ])#
			# Add two sides as separate polygons to the end of the list:#
			continent_polygons <- c(continent_polygons, list(side_plus), list(side_minus))#
		}#
		# Remove old polygon from the list:#
		continent_polygons <- continent_polygons[-continents_across_date_line]#
	}
continent_polygons
sort(side_minus)
# Create empty list to store continent polygons:#
	continent_polygons <- as.list(c(1:nrow(continent_centres)))#
	# For each continent:#
	for(i in 1:nrow(continent_centres)) {#
		# Isolate continent centre:#
		centre <- continent_centres[i, ]#
		# Create empty matrix to store points that will describe the edge of the continent:#
		edge_points <- matrix(nrow = 0, ncol = 2)#
		# For as many points as are dictated by resolution get the jth point describing the edge of the continent:#
		for(j in 1:resolution) edge_points <- rbind(edge_points, unlist(EndPoint(centre[1], centre[2], (360 / resolution) * j, radius)[c("longitude", "latitude")]))#
		# Store full continent in list:#
		continent_polygons[[i]] <- edge_points#
	}#
#
	# Get distances from North pole to each continents centre:#
	North_pole_distances <- One2ManyGreatCircleDistance(0, 90, continent_centres[, 1], continent_centres[, 2])#
	# Get distances from South pole to each continents centre:#
	South_pole_distances <- One2ManyGreatCircleDistance(0, -90, continent_centres[, 1], continent_centres[, 2])#
#
	# Get number(s) of continent(s) that sit over the North pole:#
	continents_at_North_pole <- which((as.numeric(apply(matrix(North_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(North_pole_distances < radius)) == 2)#
	# Get number(s) of continent(s) that sit over the South pole:#
	continents_at_South_pole <- which((as.numeric(apply(matrix(South_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(South_pole_distances < radius)) == 2)#
	# Create a long-lat matrix of points exactly East from current centres and on date line:#
	Wall_centres <- cbind(rep(180, nrow(continent_centres)), continent_centres[, 2])#
	# Create vector to store distances between each of these points and the associated continental centres:#
	Wall_distances <- vector(mode="numeric")#
	# Calculate each of those distances:#
	for(i in 1:nrow(continent_centres)) Wall_distances[i] <- GreatCircleDistanceFromLongLat(Wall_centres[i, 1], Wall_centres[i, 2], continent_centres[i, 1], continent_centres[i, 2])#
#
	# Get just those continents that do straddle the date line:#
	continents_across_date_line <- which((as.numeric(apply(matrix(Wall_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(Wall_distances < radius)) == 2)#
	# Remove continents that only cross the date line because they also overlap the pole:#
	continents_across_date_line <- setdiff(continents_across_date_line, c(continents_at_North_pole, continents_at_South_pole))#
	# If there are continent(s) at the North pole:#
	if(length(continents_at_North_pole) > 0) {#
		# For each continent at the North pole:#
		for(i in continents_at_North_pole) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2]), c(-180, 90), c(180, 90), c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the South pole:#
	if(length(continents_at_South_pole) > 0) {#
#
		# For each continent at the South pole:#
		for(i in continents_at_South_pole) {#
#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2]), c(180, -90), c(-180, -90), c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}
# For each continent that crosses the date line:#
		for(i in continents_across_date_line) {
}
continents_across_date_line
# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Case if one break falls exactly at the end:#
			if(length(breaks) == 1) breaks <- c(breaks, resolution)#
#
			# Create first half (side one) of continent:#
			side_one <- continent_polygons[[i]][(breaks[1] + 1):(breaks[2]), ]#
			# Create second half (side one) of continent:#
			side_two <- continent_polygons[[i]][c(setdiff(c(1:1000), c(1:breaks[1], (breaks[1] + 1):(breaks[2]))), 1:breaks[1]), ]#
			# Need to assign halves to positive or negative (longitudes) to add extra points:#
			if((side_two[, 1] / abs(side_two[, 1]))[1] == -1) {#
				# Side two is negative:#
				side_minus <- side_two#
				# Side one is negative:#
				side_plus <- side_one#
			# Case if signs are the opposite:#
			} else {#
				# Side one is negative:#
				side_minus <- side_one#
				# Side two is positive:#
				side_plus <- side_two#
#
			}#
			brk <- which.min(side_minus[, 1])#
			if(nrow(side_minus) != brk) side_minus <- side_minus[c((brk + 1):nrow(side_minus), setdiff(c(1:nrow(side_minus)), (brk + 1):nrow(side_minus))), ]#
			brk <- which.max(side_plus[, 1])#
			if(nrow(side_plus) != brk) side_plus <- side_plus[c((brk + 1):nrow(side_plus), setdiff(1:nrow(side_plus), (brk + 1):nrow(side_plus))), ]
side_minus
side_minus[, 1]
sort(side_minus[, 1])
sort(side_minus[, 1])[1:2]
match(sort(side_minus[, 1])[1:2], side_minus[, 1])
side_minus[match(sort(side_minus[, 1])[1:2], side_minus[, 1]), ]
side_minus[match(sort(side_minus[, 1])[1:2], side_minus[, 1]), 1]
side_minus[match(sort(side_minus[, 1])[1:2], side_minus[, 1]), ]
side_minus[match(sort(side_minus[, 1])[1:2], side_minus[, 1])[1], ]
side_minus[match(sort(side_minus[, 1])[1:2], side_minus[, 1])[1], 2]
side_minus[match(sort(side_minus[, 1])[1:2], side_minus[, 1]), ]
side_plus[match(sort(side_minus[, 1])[1:2], side_minus[, 1]), ]
?sort
side_plus[match(sort(side_plus[, 1], decreasing = TRUE)[1:2], side_plus[, 1]), ]
side_plus
side_plus[, 2]
diff(side_plus[, 2])
plot(diff(side_plus[, 2]))
which.max(diff(side_plus[, 2]))
which.max(abs(diff(side_plus[, 2])))
side_plus
# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Case if one break falls exactly at the end:#
			if(length(breaks) == 1) breaks <- c(breaks, resolution)#
#
			# Create first half (side one) of continent:#
			side_one <- continent_polygons[[i]][(breaks[1] + 1):(breaks[2]), ]#
			# Create second half (side one) of continent:#
			side_two <- continent_polygons[[i]][c(setdiff(c(1:1000), c(1:breaks[1], (breaks[1] + 1):(breaks[2]))), 1:breaks[1]), ]#
			# Need to assign halves to positive or negative (longitudes) to add extra points:#
			if((side_two[, 1] / abs(side_two[, 1]))[1] == -1) {#
				# Side two is negative:#
				side_minus <- side_two#
				# Side one is negative:#
				side_plus <- side_one#
			# Case if signs are the opposite:#
			} else {#
				# Side one is negative:#
				side_minus <- side_one#
				# Side two is positive:#
				side_plus <- side_two#
#
			}
brk <- which.max(abs(diff(side_plus[, 2])))#
			if(nrow(side_plus) != brk) side_plus <- side_plus[c((brk + 1):nrow(side_plus), setdiff(1:nrow(side_plus), (brk + 1):nrow(side_plus))), ]
side_plus
brk <- which.max(abs(diff(side_plus[, 2])))
brk
# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Case if one break falls exactly at the end:#
			if(length(breaks) == 1) breaks <- c(breaks, resolution)#
#
			# Create first half (side one) of continent:#
			side_one <- continent_polygons[[i]][(breaks[1] + 1):(breaks[2]), ]#
			# Create second half (side one) of continent:#
			side_two <- continent_polygons[[i]][c(setdiff(c(1:1000), c(1:breaks[1], (breaks[1] + 1):(breaks[2]))), 1:breaks[1]), ]#
			# Need to assign halves to positive or negative (longitudes) to add extra points:#
			if((side_two[, 1] / abs(side_two[, 1]))[1] == -1) {#
				# Side two is negative:#
				side_minus <- side_two#
				# Side one is negative:#
				side_plus <- side_one#
			# Case if signs are the opposite:#
			} else {#
				# Side one is negative:#
				side_minus <- side_one#
				# Side two is positive:#
				side_plus <- side_two#
#
			}
side_plus
brk <- which.max(abs(diff(side_plus[, 2])))
c((brk + 1):nrow(side_plus), setdiff(1:nrow(side_plus), (brk + 1):nrow(side_plus)))
map_continents <- function(continent_centres, radius, xlim = c(-180, 180), ylim = c(-90, 90), resolution = 1000, sea_colour = "blue", land_colour = "green", ...) {#
# Add grid overlay option:#
# Draw continent links to help visualise separation(s)/collision(s):#
	# Make empty plot:#
	plot(x = c(1, 1), xlim = xlim, ylim = c(-90, 90), type = "n", xlab = "Longitude", ylab = "Latitude")#
	# Fill with blue background (sea):#
	polygon(x = c(-180, 180, 180, -180), y = c(90, 90, -90, -90), border = NA, col = sea_colour)#
#
	# Create empty list to store continent polygons:#
	continent_polygons <- as.list(c(1:nrow(continent_centres)))#
	# For each continent:#
	for(i in 1:nrow(continent_centres)) {#
		# Isolate continent centre:#
		centre <- continent_centres[i, ]#
		# Create empty matrix to store points that will describe the edge of the continent:#
		edge_points <- matrix(nrow = 0, ncol = 2)#
		# For as many points as are dictated by resolution get the jth point describing the edge of the continent:#
		for(j in 1:resolution) edge_points <- rbind(edge_points, unlist(EndPoint(centre[1], centre[2], (360 / resolution) * j, radius)[c("longitude", "latitude")]))#
		# Store full continent in list:#
		continent_polygons[[i]] <- edge_points#
	}#
#
	# Get distances from North pole to each continents centre:#
	North_pole_distances <- One2ManyGreatCircleDistance(0, 90, continent_centres[, 1], continent_centres[, 2])#
	# Get distances from South pole to each continents centre:#
	South_pole_distances <- One2ManyGreatCircleDistance(0, -90, continent_centres[, 1], continent_centres[, 2])#
#
	# Get number(s) of continent(s) that sit over the North pole:#
	continents_at_North_pole <- which((as.numeric(apply(matrix(North_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(North_pole_distances < radius)) == 2)#
	# Get number(s) of continent(s) that sit over the South pole:#
	continents_at_South_pole <- which((as.numeric(apply(matrix(South_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(South_pole_distances < radius)) == 2)#
	# Create a long-lat matrix of points exactly East from current centres and on date line:#
	Wall_centres <- cbind(rep(180, nrow(continent_centres)), continent_centres[, 2])#
	# Create vector to store distances between each of these points and the associated continental centres:#
	Wall_distances <- vector(mode="numeric")#
	# Calculate each of those distances:#
	for(i in 1:nrow(continent_centres)) Wall_distances[i] <- GreatCircleDistanceFromLongLat(Wall_centres[i, 1], Wall_centres[i, 2], continent_centres[i, 1], continent_centres[i, 2])#
#
	# Get just those continents that do straddle the date line:#
	continents_across_date_line <- which((as.numeric(apply(matrix(Wall_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(Wall_distances < radius)) == 2)#
	# Remove continents that only cross the date line because they also overlap the pole:#
	continents_across_date_line <- setdiff(continents_across_date_line, c(continents_at_North_pole, continents_at_South_pole))#
	# If there are continent(s) at the North pole:#
	if(length(continents_at_North_pole) > 0) {#
		# For each continent at the North pole:#
		for(i in continents_at_North_pole) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2]), c(-180, 90), c(180, 90), c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the South pole:#
	if(length(continents_at_South_pole) > 0) {#
#
		# For each continent at the South pole:#
		for(i in continents_at_South_pole) {#
#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2]), c(180, -90), c(-180, -90), c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the North pole:#
	if(length(continents_across_date_line) > 0) {#
		# For each continent that crosses the date line:#
		for(i in continents_across_date_line) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Case if one break falls exactly at the end:#
			if(length(breaks) == 1) breaks <- c(breaks, resolution)#
#
			# Create first half (side one) of continent:#
			side_one <- continent_polygons[[i]][(breaks[1] + 1):(breaks[2]), ]#
			# Create second half (side one) of continent:#
			side_two <- continent_polygons[[i]][c(setdiff(c(1:1000), c(1:breaks[1], (breaks[1] + 1):(breaks[2]))), 1:breaks[1]), ]#
			# Need to assign halves to positive or negative (longitudes) to add extra points:#
			if((side_two[, 1] / abs(side_two[, 1]))[1] == -1) {#
				# Side two is negative:#
				side_minus <- side_two#
				# Side one is negative:#
				side_plus <- side_one#
			# Case if signs are the opposite:#
			} else {#
				# Side one is negative:#
				side_minus <- side_one#
				# Side two is positive:#
				side_plus <- side_two#
#
			}#
#brk <- which.min(side_minus[, 1])#
#if(nrow(side_minus) != brk) side_minus <- side_minus[c((brk + 1):nrow(side_minus), setdiff(c(1:nrow(side_minus)), (brk + 1):nrow(side_minus))), ]#
#brk <- which.max(abs(diff(side_plus[, 2])))#
#side_plus <- side_plus[c((brk + 1):nrow(side_plus), setdiff(1:nrow(side_plus), (brk + 1):nrow(side_plus))), ]#
#side_plus <- rbind(side_plus, matrix(c(180, side_minus[match(sort(side_minus[, 1])[1:2], side_minus[, 1])[1], 2], 180, side_minus[match(sort(side_minus[, 1])[1:2], side_minus[, 1])[2], 2]), ncol = 2, byrow = TRUE))#
#
#side_minus <- rbind(side_minus, matrix(c(-180, side_minus[nrow(side_minus), 2], -180, side_minus[1, 2]), ncol = 2, byrow = TRUE))#
# FIND OUT WHICH ENDS WITH MIN ADN WHICH WITH MAX#
			# Make extra polygon points to delineate date-line edge of polygon for side one:#
#side_plus_extra <- matrix(c(180, min(side_plus[, 2]), 180, max(side_plus[, 2])), ncol = 2, byrow = TRUE)#
			# Make extra polygon points to delineate date-line edge of polygon for side two:#
#side_minus_extra <- matrix(c(-180, min(side_minus[, 2]), -180, max(side_minus[, 2])), ncol = 2, byrow = TRUE)#
# SOMETHING WRONG IN HERE!#
			# Add extra points to side one:#
#side_plus <- rbind(side_plus[1:which.max(side_plus[, 2]), ], side_plus_extra, side_plus[setdiff(1:nrow(side_plus), 1:which.max(side_plus[, 2])), ])#
			# Add extra points to side two:#
#side_minus <- rbind(side_minus[1:which.max(side_minus[, 2]), ], side_minus_extra, side_minus[setdiff(1:nrow(side_minus), 1:which.max(side_minus[, 2])), ])#
			# Add two sides as separate polygons to the end of the list:#
			continent_polygons <- c(continent_polygons, list(side_plus), list(side_minus))#
		}#
		# Remove old polygon from the list:#
		continent_polygons <- continent_polygons[-continents_across_date_line]#
	}#
	# Plot continental polygons:#
	#for(i in 1:length(continent_polygons)) polygon(x = continent_polygons[[i]][, 1], y = continent_polygons[[i]][, 2], border = NA, col = land_colour)#
#
	# Plot only side-split continents:#
	for(i in 1:length(continent_polygons)) if(nrow(continent_polygons[[i]]) < resolution) polygon(x = continent_polygons[[i]][, 1], y = continent_polygons[[i]][, 2], border = NA, col = land_colour)#
}#
#
for(i in 1:1000) {#
	continent_centres <- StartingPoints(7, 2000)#
#
	map_continents(continent_centres, radius)#
	Sys.sleep(2)#
}
map_continents <- function(continent_centres, radius, xlim = c(-180, 180), ylim = c(-90, 90), resolution = 1000, sea_colour = "blue", land_colour = "green", ...) {#
# Add grid overlay option:#
# Draw continent links to help visualise separation(s)/collision(s):#
	# Make empty plot:#
	plot(x = c(1, 1), xlim = xlim, ylim = c(-90, 90), type = "n", xlab = "Longitude", ylab = "Latitude")#
	# Fill with blue background (sea):#
	polygon(x = c(-180, 180, 180, -180), y = c(90, 90, -90, -90), border = NA, col = sea_colour)#
#
	# Create empty list to store continent polygons:#
	continent_polygons <- as.list(c(1:nrow(continent_centres)))#
	# For each continent:#
	for(i in 1:nrow(continent_centres)) {#
		# Isolate continent centre:#
		centre <- continent_centres[i, ]#
		# Create empty matrix to store points that will describe the edge of the continent:#
		edge_points <- matrix(nrow = 0, ncol = 2)#
		# For as many points as are dictated by resolution get the jth point describing the edge of the continent:#
		for(j in 1:resolution) edge_points <- rbind(edge_points, unlist(EndPoint(centre[1], centre[2], (360 / resolution) * j, radius)[c("longitude", "latitude")]))#
		# Store full continent in list:#
		continent_polygons[[i]] <- edge_points#
	}#
#
	# Get distances from North pole to each continents centre:#
	North_pole_distances <- One2ManyGreatCircleDistance(0, 90, continent_centres[, 1], continent_centres[, 2])#
	# Get distances from South pole to each continents centre:#
	South_pole_distances <- One2ManyGreatCircleDistance(0, -90, continent_centres[, 1], continent_centres[, 2])#
#
	# Get number(s) of continent(s) that sit over the North pole:#
	continents_at_North_pole <- which((as.numeric(apply(matrix(North_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(North_pole_distances < radius)) == 2)#
	# Get number(s) of continent(s) that sit over the South pole:#
	continents_at_South_pole <- which((as.numeric(apply(matrix(South_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(South_pole_distances < radius)) == 2)#
	# Create a long-lat matrix of points exactly East from current centres and on date line:#
	Wall_centres <- cbind(rep(180, nrow(continent_centres)), continent_centres[, 2])#
	# Create vector to store distances between each of these points and the associated continental centres:#
	Wall_distances <- vector(mode="numeric")#
	# Calculate each of those distances:#
	for(i in 1:nrow(continent_centres)) Wall_distances[i] <- GreatCircleDistanceFromLongLat(Wall_centres[i, 1], Wall_centres[i, 2], continent_centres[i, 1], continent_centres[i, 2])#
#
	# Get just those continents that do straddle the date line:#
	continents_across_date_line <- which((as.numeric(apply(matrix(Wall_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(Wall_distances < radius)) == 2)#
	# Remove continents that only cross the date line because they also overlap the pole:#
	continents_across_date_line <- setdiff(continents_across_date_line, c(continents_at_North_pole, continents_at_South_pole))#
	# If there are continent(s) at the North pole:#
	if(length(continents_at_North_pole) > 0) {#
		# For each continent at the North pole:#
		for(i in continents_at_North_pole) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2]), c(-180, 90), c(180, 90), c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the South pole:#
	if(length(continents_at_South_pole) > 0) {#
#
		# For each continent at the South pole:#
		for(i in continents_at_South_pole) {#
#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2]), c(180, -90), c(-180, -90), c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the North pole:#
	if(length(continents_across_date_line) > 0) {#
		# For each continent that crosses the date line:#
		for(i in continents_across_date_line) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Case if one break falls exactly at the end:#
			if(length(breaks) == 1) breaks <- c(breaks, resolution)#
#
			# Create first half (side one) of continent:#
			side_one <- continent_polygons[[i]][(breaks[1] + 1):(breaks[2]), ]#
			# Create second half (side one) of continent:#
			side_two <- continent_polygons[[i]][c(setdiff(c(1:1000), c(1:breaks[1], (breaks[1] + 1):(breaks[2]))), 1:breaks[1]), ]#
			# Need to assign halves to positive or negative (longitudes) to add extra points:#
			if((side_two[, 1] / abs(side_two[, 1]))[1] == -1) {#
				# Side two is negative:#
				side_minus <- side_two#
				# Side one is negative:#
				side_plus <- side_one#
			# Case if signs are the opposite:#
			} else {#
				# Side one is negative:#
				side_minus <- side_one#
				# Side two is positive:#
				side_plus <- side_two#
#
			}#
#brk <- which.min(side_minus[, 1])#
#if(nrow(side_minus) != brk) side_minus <- side_minus[c((brk + 1):nrow(side_minus), setdiff(c(1:nrow(side_minus)), (brk + 1):nrow(side_minus))), ]#
#brk <- which.max(abs(diff(side_plus[, 2])))#
#side_plus <- side_plus[c((brk + 1):nrow(side_plus), setdiff(1:nrow(side_plus), (brk + 1):nrow(side_plus))), ]#
#side_plus <- rbind(side_plus, matrix(c(180, side_minus[match(sort(side_minus[, 1])[1:2], side_minus[, 1])[1], 2], 180, side_minus[match(sort(side_minus[, 1])[1:2], side_minus[, 1])[2], 2]), ncol = 2, byrow = TRUE))#
#
#side_minus <- rbind(side_minus, matrix(c(-180, side_minus[nrow(side_minus), 2], -180, side_minus[1, 2]), ncol = 2, byrow = TRUE))#
# FIND OUT WHICH ENDS WITH MIN ADN WHICH WITH MAX#
			# Make extra polygon points to delineate date-line edge of polygon for side one:#
#side_plus_extra <- matrix(c(180, min(side_plus[, 2]), 180, max(side_plus[, 2])), ncol = 2, byrow = TRUE)#
			# Make extra polygon points to delineate date-line edge of polygon for side two:#
#side_minus_extra <- matrix(c(-180, min(side_minus[, 2]), -180, max(side_minus[, 2])), ncol = 2, byrow = TRUE)#
# SOMETHING WRONG IN HERE!#
			# Add extra points to side one:#
#side_plus <- rbind(side_plus[1:which.max(side_plus[, 2]), ], side_plus_extra, side_plus[setdiff(1:nrow(side_plus), 1:which.max(side_plus[, 2])), ])#
			# Add extra points to side two:#
#side_minus <- rbind(side_minus[1:which.max(side_minus[, 2]), ], side_minus_extra, side_minus[setdiff(1:nrow(side_minus), 1:which.max(side_minus[, 2])), ])#
			# Add two sides as separate polygons to the end of the list:#
			continent_polygons <- c(continent_polygons, list(side_plus), list(side_minus))#
		}#
		# Remove old polygon from the list:#
		continent_polygons <- continent_polygons[-continents_across_date_line]#
	}#
	# Plot continental polygons:#
	#for(i in 1:length(continent_polygons)) polygon(x = continent_polygons[[i]][, 1], y = continent_polygons[[i]][, 2], border = NA, col = land_colour)#
#
	# Plot only side-split continents:#
	for(i in 1:length(continent_polygons)) if(nrow(continent_polygons[[i]]) >= resolution) polygon(x = continent_polygons[[i]][, 1], y = continent_polygons[[i]][, 2], border = NA, col = land_colour)#
}#
#
for(i in 1:1000) {#
	continent_centres <- StartingPoints(7, 2000)#
#
	map_continents(continent_centres, radius)#
	Sys.sleep(2)#
}
getwd()
pdf("test_plot.pdf")#
#
for(i in 1:1000) {#
	continent_centres <- StartingPoints(7, 2000)#
#
	map_continents(continent_centres, radius)#
#Sys.sleep(2)#
}#
#
dev.off()
map_continents <- function(continent_centres, radius, xlim = c(-180, 180), ylim = c(-90, 90), resolution = 1000, sea_colour = "blue", land_colour = "green", ...) {#
# Add grid overlay option:#
# Draw continent links to help visualise separation(s)/collision(s):#
	# Make empty plot:#
	plot(x = c(1, 1), xlim = xlim, ylim = c(-90, 90), type = "n", xlab = "Longitude", ylab = "Latitude")#
	# Fill with blue background (sea):#
	polygon(x = c(-180, 180, 180, -180), y = c(90, 90, -90, -90), border = NA, col = sea_colour)#
#
	# Create empty list to store continent polygons:#
	continent_polygons <- as.list(c(1:nrow(continent_centres)))#
	# For each continent:#
	for(i in 1:nrow(continent_centres)) {#
		# Isolate continent centre:#
		centre <- continent_centres[i, ]#
		# Create empty matrix to store points that will describe the edge of the continent:#
		edge_points <- matrix(nrow = 0, ncol = 2)#
		# For as many points as are dictated by resolution get the jth point describing the edge of the continent:#
		for(j in 1:resolution) edge_points <- rbind(edge_points, unlist(EndPoint(centre[1], centre[2], (360 / resolution) * j, radius)[c("longitude", "latitude")]))#
		# Store full continent in list:#
		continent_polygons[[i]] <- edge_points#
	}#
#
	# Get distances from North pole to each continents centre:#
	North_pole_distances <- One2ManyGreatCircleDistance(0, 90, continent_centres[, 1], continent_centres[, 2])#
	# Get distances from South pole to each continents centre:#
	South_pole_distances <- One2ManyGreatCircleDistance(0, -90, continent_centres[, 1], continent_centres[, 2])#
#
	# Get number(s) of continent(s) that sit over the North pole:#
	continents_at_North_pole <- which((as.numeric(apply(matrix(North_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(North_pole_distances < radius)) == 2)#
	# Get number(s) of continent(s) that sit over the South pole:#
	continents_at_South_pole <- which((as.numeric(apply(matrix(South_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(South_pole_distances < radius)) == 2)#
	# Create a long-lat matrix of points exactly East from current centres and on date line:#
	Wall_centres <- cbind(rep(180, nrow(continent_centres)), continent_centres[, 2])#
	# Create vector to store distances between each of these points and the associated continental centres:#
	Wall_distances <- vector(mode="numeric")#
	# Calculate each of those distances:#
	for(i in 1:nrow(continent_centres)) Wall_distances[i] <- GreatCircleDistanceFromLongLat(Wall_centres[i, 1], Wall_centres[i, 2], continent_centres[i, 1], continent_centres[i, 2])#
#
	# Get just those continents that do straddle the date line:#
	continents_across_date_line <- which((as.numeric(apply(matrix(Wall_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(Wall_distances < radius)) == 2)#
	# Remove continents that only cross the date line because they also overlap the pole:#
	continents_across_date_line <- setdiff(continents_across_date_line, c(continents_at_North_pole, continents_at_South_pole))#
	# If there are continent(s) at the North pole:#
	if(length(continents_at_North_pole) > 0) {#
		# For each continent at the North pole:#
		for(i in continents_at_North_pole) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2]), c(-180, 90), c(180, 90), c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the South pole:#
	if(length(continents_at_South_pole) > 0) {#
#
		# For each continent at the South pole:#
		for(i in continents_at_South_pole) {#
#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2]), c(180, -90), c(-180, -90), c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the North pole:#
	if(length(continents_across_date_line) > 0) {#
		# For each continent that crosses the date line:#
		for(i in continents_across_date_line) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Case if one break falls exactly at the end:#
			if(length(breaks) == 1) breaks <- c(breaks, resolution)#
#
			# Create first half (side one) of continent:#
			side_one <- continent_polygons[[i]][(breaks[1] + 1):(breaks[2]), ]#
			# Create second half (side one) of continent:#
			side_two <- continent_polygons[[i]][c(setdiff(c(1:1000), c(1:breaks[1], (breaks[1] + 1):(breaks[2]))), 1:breaks[1]), ]#
			# Need to assign halves to positive or negative (longitudes) to add extra points:#
			if((side_two[, 1] / abs(side_two[, 1]))[1] == -1) {#
				# Side two is negative:#
				side_minus <- side_two#
				# Side one is negative:#
				side_plus <- side_one#
			# Case if signs are the opposite:#
			} else {#
				# Side one is negative:#
				side_minus <- side_one#
				# Side two is positive:#
				side_plus <- side_two#
#
			}#
#brk <- which.min(side_minus[, 1])#
#if(nrow(side_minus) != brk) side_minus <- side_minus[c((brk + 1):nrow(side_minus), setdiff(c(1:nrow(side_minus)), (brk + 1):nrow(side_minus))), ]#
#brk <- which.max(abs(diff(side_plus[, 2])))#
#side_plus <- side_plus[c((brk + 1):nrow(side_plus), setdiff(1:nrow(side_plus), (brk + 1):nrow(side_plus))), ]#
#side_plus <- rbind(side_plus, matrix(c(180, side_minus[match(sort(side_minus[, 1])[1:2], side_minus[, 1])[1], 2], 180, side_minus[match(sort(side_minus[, 1])[1:2], side_minus[, 1])[2], 2]), ncol = 2, byrow = TRUE))#
#
#side_minus <- rbind(side_minus, matrix(c(-180, side_minus[nrow(side_minus), 2], -180, side_minus[1, 2]), ncol = 2, byrow = TRUE))#
# FIND OUT WHICH ENDS WITH MIN ADN WHICH WITH MAX#
			# Make extra polygon points to delineate date-line edge of polygon for side one:#
#side_plus_extra <- matrix(c(180, min(side_plus[, 2]), 180, max(side_plus[, 2])), ncol = 2, byrow = TRUE)#
			# Make extra polygon points to delineate date-line edge of polygon for side two:#
#side_minus_extra <- matrix(c(-180, min(side_minus[, 2]), -180, max(side_minus[, 2])), ncol = 2, byrow = TRUE)#
# SOMETHING WRONG IN HERE!#
			# Add extra points to side one:#
#side_plus <- rbind(side_plus[1:which.max(side_plus[, 2]), ], side_plus_extra, side_plus[setdiff(1:nrow(side_plus), 1:which.max(side_plus[, 2])), ])#
			# Add extra points to side two:#
#side_minus <- rbind(side_minus[1:which.max(side_minus[, 2]), ], side_minus_extra, side_minus[setdiff(1:nrow(side_minus), 1:which.max(side_minus[, 2])), ])#
			# Add two sides as separate polygons to the end of the list:#
			continent_polygons <- c(continent_polygons, list(side_plus), list(side_minus))#
		}#
		# Remove old polygon from the list:#
		continent_polygons <- continent_polygons[-continents_across_date_line]#
	}#
	# Plot continental polygons:#
	#for(i in 1:length(continent_polygons)) polygon(x = continent_polygons[[i]][, 1], y = continent_polygons[[i]][, 2], border = NA, col = land_colour)#
#
	# Plot only side-split continents:#
	for(i in 1:length(continent_polygons)) if(nrow(continent_polygons[[i]]) > resolution) polygon(x = continent_polygons[[i]][, 1], y = continent_polygons[[i]][, 2], border = NA, col = land_colour)#
}#
#
pdf("test_plot.pdf")#
#
for(i in 1:100) {#
	continent_centres <- StartingPoints(7, 2000)#
#
	map_continents(continent_centres, radius)#
#Sys.sleep(2)#
}#
#
dev.off()
# Create empty list to store continent polygons:#
	continent_polygons <- as.list(c(1:nrow(continent_centres)))#
	# For each continent:#
	for(i in 1:nrow(continent_centres)) {#
		# Isolate continent centre:#
		centre <- continent_centres[i, ]#
		# Create empty matrix to store points that will describe the edge of the continent:#
		edge_points <- matrix(nrow = 0, ncol = 2)#
		# For as many points as are dictated by resolution get the jth point describing the edge of the continent:#
		for(j in 1:resolution) edge_points <- rbind(edge_points, unlist(EndPoint(centre[1], centre[2], (360 / resolution) * j, radius)[c("longitude", "latitude")]))#
		# Store full continent in list:#
		continent_polygons[[i]] <- edge_points#
	}#
#
	# Get distances from North pole to each continents centre:#
	North_pole_distances <- One2ManyGreatCircleDistance(0, 90, continent_centres[, 1], continent_centres[, 2])#
	# Get distances from South pole to each continents centre:#
	South_pole_distances <- One2ManyGreatCircleDistance(0, -90, continent_centres[, 1], continent_centres[, 2])#
#
	# Get number(s) of continent(s) that sit over the North pole:#
	continents_at_North_pole <- which((as.numeric(apply(matrix(North_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(North_pole_distances < radius)) == 2)#
	# Get number(s) of continent(s) that sit over the South pole:#
	continents_at_South_pole <- which((as.numeric(apply(matrix(South_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(South_pole_distances < radius)) == 2)#
	# Create a long-lat matrix of points exactly East from current centres and on date line:#
	Wall_centres <- cbind(rep(180, nrow(continent_centres)), continent_centres[, 2])#
	# Create vector to store distances between each of these points and the associated continental centres:#
	Wall_distances <- vector(mode="numeric")#
	# Calculate each of those distances:#
	for(i in 1:nrow(continent_centres)) Wall_distances[i] <- GreatCircleDistanceFromLongLat(Wall_centres[i, 1], Wall_centres[i, 2], continent_centres[i, 1], continent_centres[i, 2])#
#
	# Get just those continents that do straddle the date line:#
	continents_across_date_line <- which((as.numeric(apply(matrix(Wall_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(Wall_distances < radius)) == 2)#
	# Remove continents that only cross the date line because they also overlap the pole:#
	continents_across_date_line <- setdiff(continents_across_date_line, c(continents_at_North_pole, continents_at_South_pole))#
	# If there are continent(s) at the North pole:#
	if(length(continents_at_North_pole) > 0) {#
		# For each continent at the North pole:#
		for(i in continents_at_North_pole) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2]), c(-180, 90), c(180, 90), c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the South pole:#
	if(length(continents_at_South_pole) > 0) {#
#
		# For each continent at the South pole:#
		for(i in continents_at_South_pole) {#
#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2]), c(180, -90), c(-180, -90), c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}
continents_across_date_line
# Create empty list to store continent polygons:#
	continent_polygons <- as.list(c(1:nrow(continent_centres)))#
	# For each continent:#
	for(i in 1:nrow(continent_centres)) {#
		# Isolate continent centre:#
		centre <- continent_centres[i, ]#
		# Create empty matrix to store points that will describe the edge of the continent:#
		edge_points <- matrix(nrow = 0, ncol = 2)#
		# For as many points as are dictated by resolution get the jth point describing the edge of the continent:#
		for(j in 1:resolution) edge_points <- rbind(edge_points, unlist(EndPoint(centre[1], centre[2], (360 / resolution) * j, radius)[c("longitude", "latitude")]))#
		# Store full continent in list:#
		continent_polygons[[i]] <- edge_points#
	}#
#
	# Get distances from North pole to each continents centre:#
	North_pole_distances <- One2ManyGreatCircleDistance(0, 90, continent_centres[, 1], continent_centres[, 2])#
	# Get distances from South pole to each continents centre:#
	South_pole_distances <- One2ManyGreatCircleDistance(0, -90, continent_centres[, 1], continent_centres[, 2])#
#
	# Get number(s) of continent(s) that sit over the North pole:#
	continents_at_North_pole <- which((as.numeric(apply(matrix(North_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(North_pole_distances < radius)) == 2)#
	# Get number(s) of continent(s) that sit over the South pole:#
	continents_at_South_pole <- which((as.numeric(apply(matrix(South_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(South_pole_distances < radius)) == 2)#
	# Create a long-lat matrix of points exactly East from current centres and on date line:#
	Wall_centres <- cbind(rep(180, nrow(continent_centres)), continent_centres[, 2])#
	# Create vector to store distances between each of these points and the associated continental centres:#
	Wall_distances <- vector(mode="numeric")#
	# Calculate each of those distances:#
	for(i in 1:nrow(continent_centres)) Wall_distances[i] <- GreatCircleDistanceFromLongLat(Wall_centres[i, 1], Wall_centres[i, 2], continent_centres[i, 1], continent_centres[i, 2])#
#
	# Get just those continents that do straddle the date line:#
	continents_across_date_line <- which((as.numeric(apply(matrix(Wall_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(Wall_distances < radius)) == 2)#
	# Remove continents that only cross the date line because they also overlap the pole:#
	continents_across_date_line <- setdiff(continents_across_date_line, c(continents_at_North_pole, continents_at_South_pole))#
	# If there are continent(s) at the North pole:#
	if(length(continents_at_North_pole) > 0) {#
		# For each continent at the North pole:#
		for(i in continents_at_North_pole) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2]), c(-180, 90), c(180, 90), c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the South pole:#
	if(length(continents_at_South_pole) > 0) {#
#
		# For each continent at the South pole:#
		for(i in continents_at_South_pole) {#
#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2]), c(180, -90), c(-180, -90), c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}
continents_across_date_line
continent_centres
continent_centres[4, 1] <- 178
# Create empty list to store continent polygons:#
	continent_polygons <- as.list(c(1:nrow(continent_centres)))#
	# For each continent:#
	for(i in 1:nrow(continent_centres)) {#
		# Isolate continent centre:#
		centre <- continent_centres[i, ]#
		# Create empty matrix to store points that will describe the edge of the continent:#
		edge_points <- matrix(nrow = 0, ncol = 2)#
		# For as many points as are dictated by resolution get the jth point describing the edge of the continent:#
		for(j in 1:resolution) edge_points <- rbind(edge_points, unlist(EndPoint(centre[1], centre[2], (360 / resolution) * j, radius)[c("longitude", "latitude")]))#
		# Store full continent in list:#
		continent_polygons[[i]] <- edge_points#
	}#
#
	# Get distances from North pole to each continents centre:#
	North_pole_distances <- One2ManyGreatCircleDistance(0, 90, continent_centres[, 1], continent_centres[, 2])#
	# Get distances from South pole to each continents centre:#
	South_pole_distances <- One2ManyGreatCircleDistance(0, -90, continent_centres[, 1], continent_centres[, 2])#
#
	# Get number(s) of continent(s) that sit over the North pole:#
	continents_at_North_pole <- which((as.numeric(apply(matrix(North_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(North_pole_distances < radius)) == 2)#
	# Get number(s) of continent(s) that sit over the South pole:#
	continents_at_South_pole <- which((as.numeric(apply(matrix(South_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(South_pole_distances < radius)) == 2)#
	# Create a long-lat matrix of points exactly East from current centres and on date line:#
	Wall_centres <- cbind(rep(180, nrow(continent_centres)), continent_centres[, 2])#
	# Create vector to store distances between each of these points and the associated continental centres:#
	Wall_distances <- vector(mode="numeric")#
	# Calculate each of those distances:#
	for(i in 1:nrow(continent_centres)) Wall_distances[i] <- GreatCircleDistanceFromLongLat(Wall_centres[i, 1], Wall_centres[i, 2], continent_centres[i, 1], continent_centres[i, 2])#
#
	# Get just those continents that do straddle the date line:#
	continents_across_date_line <- which((as.numeric(apply(matrix(Wall_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(Wall_distances < radius)) == 2)#
	# Remove continents that only cross the date line because they also overlap the pole:#
	continents_across_date_line <- setdiff(continents_across_date_line, c(continents_at_North_pole, continents_at_South_pole))#
	# If there are continent(s) at the North pole:#
	if(length(continents_at_North_pole) > 0) {#
		# For each continent at the North pole:#
		for(i in continents_at_North_pole) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2]), c(-180, 90), c(180, 90), c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the South pole:#
	if(length(continents_at_South_pole) > 0) {#
#
		# For each continent at the South pole:#
		for(i in continents_at_South_pole) {#
#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2]), c(180, -90), c(-180, -90), c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}
continent_centres
continents_across_date_line
i<-4
continent_polygons[[i]]
c(continent_polygons[[i]][, 1], continent_polygons[[i]][, 1])
diff(c(continent_polygons[[i]][, 1], continent_polygons[[i]][, 1]))
abs(diff(c(continent_polygons[[i]][, 1], continent_polygons[[i]][, 1])))
abs(diff(c(continent_polygons[[i]][, 1], continent_polygons[[i]][, 1]))) > 180
which(abs(diff(c(continent_polygons[[i]][, 1], continent_polygons[[i]][, 1]))) > 180)
which(abs(diff(c(continent_polygons[[i]][, 1], continent_polygons[[i]][, 1]))) > 180)[1:2]
# Get breaks (where latitudinal "jump" occurs as crosses date line):#
			breaks <- which(abs(diff(c(continent_polygons[[i]][, 1], continent_polygons[[i]][, 1]))) > 180)[1:2]
breaks
continent_polygons[[i]]
(breaks[1] + 1):breaks[2]
continent_polygons[[i]][(breaks[1] + 1):breaks[2], ]
side_one <- continent_polygons[[i]][(breaks[1] + 1):breaks[2], ]
breaks[2]
breaks[2] + 1
min(c(breaks[2] + 1, resolution))
min(c(breaks[2] + 1, resolution)):resolution
breaks[1]
1:breaks[1]
c(min(c(breaks[2] + 1, resolution)):resolution, 1:breaks[1])
side_one <- continent_polygons[[i]][(breaks[1] + 1):breaks[2], ]#
			side_two <- continent_polygons[[i]][c(min(c(breaks[2] + 1, resolution)):resolution, 1:breaks[1]), ]
# Get breaks (where latitudinal "jump" occurs as crosses date line):#
			breaks <- which(abs(diff(c(continent_polygons[[i]][, 1], continent_polygons[[i]][, 1]))) > 180)[1:2]#
			side_one <- continent_polygons[[i]][(breaks[1] + 1):breaks[2], ]#
			side_two <- continent_polygons[[i]][c(min(c(breaks[2] + 1, resolution)):resolution, 1:breaks[1]), ]
side_one
side_one
side_one[1, 1]
side_one[1, 1] / abs(side_one[1, 1])
(side_one[1, 1] / abs(side_one[1, 1])) * 180
rep((side_one[1, 1] / abs(side_one[1, 1])) * 180, 2)
as.vector(rep((side_one[1, 1] / abs(side_one[1, 1])) * 180, 2))
side_one[1, 2]
side_one[nrow(side_one), 2]
c(side_one[nrow(side_one), 2], side_one[1, 2])
as.vector(c(side_one[nrow(side_one), 2], side_one[1, 2]))
c(as.vector(rep((side_one[1, 1] / abs(side_one[1, 1])) * 180, 2)), as.vector(c(side_one[nrow(side_one), 2], side_one[1, 2])))
matrix(c(as.vector(rep((side_one[1, 1] / abs(side_one[1, 1])) * 180, 2)), as.vector(c(side_one[nrow(side_one), 2], side_one[1, 2]))), ncol = 2)
map_continents <- function(continent_centres, radius, xlim = c(-180, 180), ylim = c(-90, 90), resolution = 1000, sea_colour = "blue", land_colour = "green", ...) {#
# Add grid overlay option:#
# Draw continent links to help visualise separation(s)/collision(s):#
	# Make empty plot:#
	plot(x = c(1, 1), xlim = xlim, ylim = c(-90, 90), type = "n", xlab = "Longitude", ylab = "Latitude")#
	# Fill with blue background (sea):#
	polygon(x = c(-180, 180, 180, -180), y = c(90, 90, -90, -90), border = NA, col = sea_colour)#
#
	# Create empty list to store continent polygons:#
	continent_polygons <- as.list(c(1:nrow(continent_centres)))#
	# For each continent:#
	for(i in 1:nrow(continent_centres)) {#
		# Isolate continent centre:#
		centre <- continent_centres[i, ]#
		# Create empty matrix to store points that will describe the edge of the continent:#
		edge_points <- matrix(nrow = 0, ncol = 2)#
		# For as many points as are dictated by resolution get the jth point describing the edge of the continent:#
		for(j in 1:resolution) edge_points <- rbind(edge_points, unlist(EndPoint(centre[1], centre[2], (360 / resolution) * j, radius)[c("longitude", "latitude")]))#
		# Store full continent in list:#
		continent_polygons[[i]] <- edge_points#
	}#
#
	# Get distances from North pole to each continents centre:#
	North_pole_distances <- One2ManyGreatCircleDistance(0, 90, continent_centres[, 1], continent_centres[, 2])#
	# Get distances from South pole to each continents centre:#
	South_pole_distances <- One2ManyGreatCircleDistance(0, -90, continent_centres[, 1], continent_centres[, 2])#
#
	# Get number(s) of continent(s) that sit over the North pole:#
	continents_at_North_pole <- which((as.numeric(apply(matrix(North_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(North_pole_distances < radius)) == 2)#
	# Get number(s) of continent(s) that sit over the South pole:#
	continents_at_South_pole <- which((as.numeric(apply(matrix(South_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(South_pole_distances < radius)) == 2)#
	# Create a long-lat matrix of points exactly East from current centres and on date line:#
	Wall_centres <- cbind(rep(180, nrow(continent_centres)), continent_centres[, 2])#
	# Create vector to store distances between each of these points and the associated continental centres:#
	Wall_distances <- vector(mode="numeric")#
	# Calculate each of those distances:#
	for(i in 1:nrow(continent_centres)) Wall_distances[i] <- GreatCircleDistanceFromLongLat(Wall_centres[i, 1], Wall_centres[i, 2], continent_centres[i, 1], continent_centres[i, 2])#
#
	# Get just those continents that do straddle the date line:#
	continents_across_date_line <- which((as.numeric(apply(matrix(Wall_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(Wall_distances < radius)) == 2)#
	# Remove continents that only cross the date line because they also overlap the pole:#
	continents_across_date_line <- setdiff(continents_across_date_line, c(continents_at_North_pole, continents_at_South_pole))#
	# If there are continent(s) at the North pole:#
	if(length(continents_at_North_pole) > 0) {#
		# For each continent at the North pole:#
		for(i in continents_at_North_pole) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2]), c(-180, 90), c(180, 90), c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the South pole:#
	if(length(continents_at_South_pole) > 0) {#
#
		# For each continent at the South pole:#
		for(i in continents_at_South_pole) {#
#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2]), c(180, -90), c(-180, -90), c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the North pole:#
	if(length(continents_across_date_line) > 0) {#
		# For each continent that crosses the date line:#
		for(i in continents_across_date_line) {#
			# Get breaks (where latitudinal "jump" occurs as crosses date line):#
			breaks <- which(abs(diff(c(continent_polygons[[i]][, 1], continent_polygons[[i]][, 1]))) > 180)[1:2]#
			side_one <- continent_polygons[[i]][(breaks[1] + 1):breaks[2], ]#
			side_two <- continent_polygons[[i]][c(min(c(breaks[2] + 1, resolution)):resolution, 1:breaks[1]), ]#
			side_one <- rbind(side_one, matrix(c(as.vector(rep((side_one[1, 1] / abs(side_one[1, 1])) * 180, 2)), as.vector(c(side_one[nrow(side_one), 2], side_one[1, 2]))), ncol = 2))#
			side_two <- rbind(side_two, matrix(c(as.vector(rep((side_two[1, 1] / abs(side_two[1, 1])) * 180, 2)), as.vector(c(side_two[nrow(side_two), 2], side_two[1, 2]))), ncol = 2))#
			# Add two sides as separate polygons to the end of the list:#
			continent_polygons <- c(continent_polygons, list(side_one), list(side_two))#
		}#
		# Remove old polygon from the list:#
		continent_polygons <- continent_polygons[-continents_across_date_line]#
	}#
	# Plot continental polygons:#
	#for(i in 1:length(continent_polygons)) polygon(x = continent_polygons[[i]][, 1], y = continent_polygons[[i]][, 2], border = NA, col = land_colour)#
#
	# Plot only side-split continents:#
	for(i in 1:length(continent_polygons)) if(nrow(continent_polygons[[i]]) < resolution) polygon(x = continent_polygons[[i]][, 1], y = continent_polygons[[i]][, 2], border = NA, col = land_colour)#
}#
#
pdf("test_plot.pdf")#
#
for(i in 1:100) {#
	continent_centres <- StartingPoints(7, 2000)#
#
	map_continents(continent_centres, radius)#
#Sys.sleep(2)#
}#
#
dev.off()
?pdf
map_continents <- function(continent_centres, radius, xlim = c(-180, 180), ylim = c(-90, 90), resolution = 1000, sea_colour = "blue", land_colour = "green", ...) {#
# Add grid overlay option:#
# Draw continent links to help visualise separation(s)/collision(s):#
	# Make empty plot:#
	plot(x = c(1, 1), xlim = xlim, ylim = c(-90, 90), type = "n", xlab = "Longitude", ylab = "Latitude")#
	# Fill with blue background (sea):#
	polygon(x = c(-180, 180, 180, -180), y = c(90, 90, -90, -90), border = NA, col = sea_colour)#
#
	# Create empty list to store continent polygons:#
	continent_polygons <- as.list(c(1:nrow(continent_centres)))#
	# For each continent:#
	for(i in 1:nrow(continent_centres)) {#
		# Isolate continent centre:#
		centre <- continent_centres[i, ]#
		# Create empty matrix to store points that will describe the edge of the continent:#
		edge_points <- matrix(nrow = 0, ncol = 2)#
		# For as many points as are dictated by resolution get the jth point describing the edge of the continent:#
		for(j in 1:resolution) edge_points <- rbind(edge_points, unlist(EndPoint(centre[1], centre[2], (360 / resolution) * j, radius)[c("longitude", "latitude")]))#
		# Store full continent in list:#
		continent_polygons[[i]] <- edge_points#
	}#
#
	# Get distances from North pole to each continents centre:#
	North_pole_distances <- One2ManyGreatCircleDistance(0, 90, continent_centres[, 1], continent_centres[, 2])#
	# Get distances from South pole to each continents centre:#
	South_pole_distances <- One2ManyGreatCircleDistance(0, -90, continent_centres[, 1], continent_centres[, 2])#
#
	# Get number(s) of continent(s) that sit over the North pole:#
	continents_at_North_pole <- which((as.numeric(apply(matrix(North_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(North_pole_distances < radius)) == 2)#
	# Get number(s) of continent(s) that sit over the South pole:#
	continents_at_South_pole <- which((as.numeric(apply(matrix(South_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(South_pole_distances < radius)) == 2)#
	# Create a long-lat matrix of points exactly East from current centres and on date line:#
	Wall_centres <- cbind(rep(180, nrow(continent_centres)), continent_centres[, 2])#
	# Create vector to store distances between each of these points and the associated continental centres:#
	Wall_distances <- vector(mode="numeric")#
	# Calculate each of those distances:#
	for(i in 1:nrow(continent_centres)) Wall_distances[i] <- GreatCircleDistanceFromLongLat(Wall_centres[i, 1], Wall_centres[i, 2], continent_centres[i, 1], continent_centres[i, 2])#
#
	# Get just those continents that do straddle the date line:#
	continents_across_date_line <- which((as.numeric(apply(matrix(Wall_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(Wall_distances < radius)) == 2)#
	# Remove continents that only cross the date line because they also overlap the pole:#
	continents_across_date_line <- setdiff(continents_across_date_line, c(continents_at_North_pole, continents_at_South_pole))#
	# If there are continent(s) at the North pole:#
	if(length(continents_at_North_pole) > 0) {#
		# For each continent at the North pole:#
		for(i in continents_at_North_pole) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2]), c(-180, 90), c(180, 90), c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the South pole:#
	if(length(continents_at_South_pole) > 0) {#
#
		# For each continent at the South pole:#
		for(i in continents_at_South_pole) {#
#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2]), c(180, -90), c(-180, -90), c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the North pole:#
	if(length(continents_across_date_line) > 0) {#
		# For each continent that crosses the date line:#
		for(i in continents_across_date_line) {#
			# Get breaks (where latitudinal "jump" occurs as crosses date line):#
			breaks <- which(abs(diff(c(continent_polygons[[i]][, 1], continent_polygons[[i]][, 1]))) > 180)[1:2]#
			side_one <- continent_polygons[[i]][(breaks[1] + 1):breaks[2], ]#
			side_two <- continent_polygons[[i]][c(min(c(breaks[2] + 1, resolution)):resolution, 1:breaks[1]), ]#
			side_one <- rbind(side_one, matrix(c(as.vector(rep((side_one[1, 1] / abs(side_one[1, 1])) * 180, 2)), as.vector(c(side_one[nrow(side_one), 2], side_one[1, 2]))), ncol = 2))#
			side_two <- rbind(side_two, matrix(c(as.vector(rep((side_two[1, 1] / abs(side_two[1, 1])) * 180, 2)), as.vector(c(side_two[nrow(side_two), 2], side_two[1, 2]))), ncol = 2))#
			# Add two sides as separate polygons to the end of the list:#
			continent_polygons <- c(continent_polygons, list(side_one), list(side_two))#
		}#
		# Remove old polygon from the list:#
		continent_polygons <- continent_polygons[-continents_across_date_line]#
	}#
	# Plot continental polygons:#
	for(i in 1:length(continent_polygons)) polygon(x = continent_polygons[[i]][, 1], y = continent_polygons[[i]][, 2], border = NA, col = land_colour)#
}#
#
pdf("test_plot.pdf", width = 18, height = 9)#
#
for(i in 1:100) {#
	continent_centres <- StartingPoints(7, 2000)#
#
	map_continents(continent_centres, radius)#
#Sys.sleep(2)#
}#
#
dev.off()
map_continents <- function(continent_centres, radius, xlim = c(-180, 180), ylim = c(-90, 90), resolution = 1000, sea_colour = "blue", land_colour = "green", ...) {#
# Add grid overlay option:#
# Draw continent links to help visualise separation(s)/collision(s):#
	# Make empty plot:#
	plot(x = c(1, 1), xlim = xlim, ylim = c(-90, 90), type = "n", xlab = "Longitude", ylab = "Latitude")#
	# Fill with blue background (sea):#
	polygon(x = c(-180, 180, 180, -180), y = c(90, 90, -90, -90), border = NA, col = sea_colour)#
#
	# Create empty list to store continent polygons:#
	continent_polygons <- as.list(c(1:nrow(continent_centres)))#
	# For each continent:#
	for(i in 1:nrow(continent_centres)) {#
		# Isolate continent centre:#
		centre <- continent_centres[i, ]#
		# Create empty matrix to store points that will describe the edge of the continent:#
		edge_points <- matrix(nrow = 0, ncol = 2)#
		# For as many points as are dictated by resolution get the jth point describing the edge of the continent:#
		for(j in 1:resolution) edge_points <- rbind(edge_points, unlist(EndPoint(centre[1], centre[2], (360 / resolution) * j, radius)[c("longitude", "latitude")]))#
		# Store full continent in list:#
		continent_polygons[[i]] <- edge_points#
	}#
#
	# Get distances from North pole to each continents centre:#
	North_pole_distances <- One2ManyGreatCircleDistance(0, 90, continent_centres[, 1], continent_centres[, 2])#
	# Get distances from South pole to each continents centre:#
	South_pole_distances <- One2ManyGreatCircleDistance(0, -90, continent_centres[, 1], continent_centres[, 2])#
#
	# Get number(s) of continent(s) that sit over the North pole:#
	continents_at_North_pole <- which((as.numeric(apply(matrix(North_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(North_pole_distances < radius)) == 2)#
	# Get number(s) of continent(s) that sit over the South pole:#
	continents_at_South_pole <- which((as.numeric(apply(matrix(South_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(South_pole_distances < radius)) == 2)#
	# Create a long-lat matrix of points exactly East from current centres and on date line:#
	Wall_centres <- cbind(rep(180, nrow(continent_centres)), continent_centres[, 2])#
	# Create vector to store distances between each of these points and the associated continental centres:#
	Wall_distances <- vector(mode="numeric")#
	# Calculate each of those distances:#
	for(i in 1:nrow(continent_centres)) Wall_distances[i] <- GreatCircleDistanceFromLongLat(Wall_centres[i, 1], Wall_centres[i, 2], continent_centres[i, 1], continent_centres[i, 2])#
#
	# Get just those continents that do straddle the date line:#
	continents_across_date_line <- which((as.numeric(apply(matrix(Wall_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(Wall_distances < radius)) == 2)#
	# Remove continents that only cross the date line because they also overlap the pole:#
	continents_across_date_line <- setdiff(continents_across_date_line, c(continents_at_North_pole, continents_at_South_pole))#
	# If there are continent(s) at the North pole:#
	if(length(continents_at_North_pole) > 0) {#
		# For each continent at the North pole:#
		for(i in continents_at_North_pole) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2]), c(-180, 90), c(180, 90), c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the South pole:#
	if(length(continents_at_South_pole) > 0) {#
#
		# For each continent at the South pole:#
		for(i in continents_at_South_pole) {#
#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2]), c(180, -90), c(-180, -90), c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the North pole:#
	if(length(continents_across_date_line) > 0) {#
		# For each continent that crosses the date line:#
		for(i in continents_across_date_line) {#
			# Get breaks (where latitudinal "jump" occurs as crosses date line):#
			breaks <- which(abs(diff(c(continent_polygons[[i]][, 1], continent_polygons[[i]][, 1]))) > 180)[1:2]#
			# Get first side (first "half" of the polygon):#
			side_one <- continent_polygons[[i]][(breaks[1] + 1):breaks[2], ]#
			# Get second side (second "half" of the polygon):#
			side_two <- continent_polygons[[i]][c(min(c(breaks[2] + 1, resolution)):resolution, 1:breaks[1]), ]#
			if(!is.matrix(side_one) || !is.matrix(side_two)) stop("Not a matrix anymore!")#
			# Add extra points to draw first polygon up to the date line:#
			side_one <- rbind(side_one, matrix(c(as.vector(rep((side_one[1, 1] / abs(side_one[1, 1])) * 180, 2)), as.vector(c(side_one[nrow(side_one), 2], side_one[1, 2]))), ncol = 2))#
			# Add extra points to draw second polygon up to the date line:#
			side_two <- rbind(side_two, matrix(c(as.vector(rep((side_two[1, 1] / abs(side_two[1, 1])) * 180, 2)), as.vector(c(side_two[nrow(side_two), 2], side_two[1, 2]))), ncol = 2))#
			if(!is.matrix(side_one) || !is.matrix(side_two)) stop("Not a matrix anymore (again)!")#
			# Add two sides as separate polygons to the end of the list:#
			continent_polygons <- c(continent_polygons, list(side_one), list(side_two))#
		}#
		# Remove old polygon(s) from the list:#
		continent_polygons <- continent_polygons[-continents_across_date_line]#
	}#
	# Plot continental polygons:#
	for(i in 1:length(continent_polygons)) polygon(x = continent_polygons[[i]][, 1], y = continent_polygons[[i]][, 2], border = NA, col = land_colour)#
}#
#
pdf("test_plot.pdf", width = 18, height = 9)#
#
for(i in 1:100) {#
	continent_centres <- StartingPoints(7, 2000)#
#
	map_continents(continent_centres, radius)#
#Sys.sleep(2)#
}#
#
dev.off()
map_continents <- function(continent_centres, radius, xlim = c(-180, 180), ylim = c(-90, 90), resolution = 1000, sea_colour = "blue", land_colour = "green", ...) {#
# Add grid overlay option:#
# Draw continent links to help visualise separation(s)/collision(s):#
	# Make empty plot:#
	plot(x = c(1, 1), xlim = xlim, ylim = c(-90, 90), type = "n", xlab = "Longitude", ylab = "Latitude")#
	# Fill with blue background (sea):#
	polygon(x = c(-180, 180, 180, -180), y = c(90, 90, -90, -90), border = NA, col = sea_colour)#
#
	# Create empty list to store continent polygons:#
	continent_polygons <- as.list(c(1:nrow(continent_centres)))#
	# For each continent:#
	for(i in 1:nrow(continent_centres)) {#
		# Isolate continent centre:#
		centre <- continent_centres[i, ]#
		# Create empty matrix to store points that will describe the edge of the continent:#
		edge_points <- matrix(nrow = 0, ncol = 2)#
		# For as many points as are dictated by resolution get the jth point describing the edge of the continent:#
		for(j in 1:resolution) edge_points <- rbind(edge_points, unlist(EndPoint(centre[1], centre[2], (360 / resolution) * j, radius)[c("longitude", "latitude")]))#
		# Store full continent in list:#
		continent_polygons[[i]] <- edge_points#
	}#
#
	# Get distances from North pole to each continents centre:#
	North_pole_distances <- One2ManyGreatCircleDistance(0, 90, continent_centres[, 1], continent_centres[, 2])#
	# Get distances from South pole to each continents centre:#
	South_pole_distances <- One2ManyGreatCircleDistance(0, -90, continent_centres[, 1], continent_centres[, 2])#
#
	# Get number(s) of continent(s) that sit over the North pole:#
	continents_at_North_pole <- which((as.numeric(apply(matrix(North_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(North_pole_distances < radius)) == 2)#
	# Get number(s) of continent(s) that sit over the South pole:#
	continents_at_South_pole <- which((as.numeric(apply(matrix(South_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(South_pole_distances < radius)) == 2)#
	# Create a long-lat matrix of points exactly East from current centres and on date line:#
	Wall_centres <- cbind(rep(180, nrow(continent_centres)), continent_centres[, 2])#
	# Create vector to store distances between each of these points and the associated continental centres:#
	Wall_distances <- vector(mode="numeric")#
	# Calculate each of those distances:#
	for(i in 1:nrow(continent_centres)) Wall_distances[i] <- GreatCircleDistanceFromLongLat(Wall_centres[i, 1], Wall_centres[i, 2], continent_centres[i, 1], continent_centres[i, 2])#
#
	# Get just those continents that do straddle the date line:#
	continents_across_date_line <- which((as.numeric(apply(matrix(Wall_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(Wall_distances < radius)) == 2)#
	# Remove continents that only cross the date line because they also overlap the pole:#
	continents_across_date_line <- setdiff(continents_across_date_line, c(continents_at_North_pole, continents_at_South_pole))#
	# If there are continent(s) at the North pole:#
	if(length(continents_at_North_pole) > 0) {#
		# For each continent at the North pole:#
		for(i in continents_at_North_pole) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2]), c(-180, 90), c(180, 90), c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the South pole:#
	if(length(continents_at_South_pole) > 0) {#
#
		# For each continent at the South pole:#
		for(i in continents_at_South_pole) {#
#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2]), c(180, -90), c(-180, -90), c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the North pole:#
	if(length(continents_across_date_line) > 0) {#
		# For each continent that crosses the date line:#
		for(i in continents_across_date_line) {#
			# Get breaks (where latitudinal "jump" occurs as crosses date line):#
			breaks <- which(abs(diff(c(continent_polygons[[i]][, 1], continent_polygons[[i]][, 1]))) > 180)[1:2]#
			# Get first side (first "half" of the polygon):#
			side_one <- continent_polygons[[i]][(breaks[1] + 1):breaks[2], ]#
			# Get second side (second "half" of the polygon):#
			side_two <- continent_polygons[[i]][c(min(c(breaks[2] + 1, resolution)):resolution, 1:breaks[1]), ]#
			# Add extra points to draw first polygon up to the date line:#
			side_one <- rbind(side_one, matrix(c(as.vector(rep((side_one[1, 1] / abs(side_one[1, 1])) * 180, 2)), as.vector(c(side_one[nrow(side_one), 2], side_one[1, 2]))), ncol = 2))#
			# Add extra points to draw second polygon up to the date line:#
			side_two <- rbind(side_two, matrix(c(as.vector(rep((side_two[1, 1] / abs(side_two[1, 1])) * 180, 2)), as.vector(c(side_two[nrow(side_two), 2], side_two[1, 2]))), ncol = 2))#
			# Add two sides as separate polygons to the end of the list:#
			continent_polygons <- c(continent_polygons, list(side_one), list(side_two))#
		}#
		# Remove old polygon(s) from the list:#
		continent_polygons <- continent_polygons[-continents_across_date_line]#
	}#
	# Plot continental polygons:#
	for(i in 1:length(continent_polygons)) polygon(x = continent_polygons[[i]][, 1], y = continent_polygons[[i]][, 2], border = NA, col = land_colour)#
	return(continent_polygons)#
}#
#
answers <- list()#
#
pdf("test_plot.pdf", width = 18, height = 9)#
#
for(i in 1:100) {#
	continent_centres <- StartingPoints(7, 2000)#
#
	out <- map_continents(continent_centres, radius)#
	answers <- c(answers, list(out))#
#Sys.sleep(2)#
}#
#
dev.off()
answers[[3]]
edge_points
edge_points[, 1]
diff(edge_points[, 1])
abs(diff(edge_points[, 1]))
abs(diff(edge_points[, 1])) > 180
any(abs(diff(edge_points[, 1])) > 180)
map_continents <- function(continent_centres, radius, xlim = c(-180, 180), ylim = c(-90, 90), resolution = 1000, sea_colour = "blue", land_colour = "green", ...) {#
# Add grid overlay option:#
# Draw continent links to help visualise separation(s)/collision(s):#
	# Make empty plot:#
	plot(x = c(1, 1), xlim = xlim, ylim = c(-90, 90), type = "n", xlab = "Longitude", ylab = "Latitude")#
	# Fill with blue background (sea):#
	polygon(x = c(-180, 180, 180, -180), y = c(90, 90, -90, -90), border = NA, col = sea_colour)#
#
	# Create empty list to store continent polygons:#
	continent_polygons <- as.list(c(1:nrow(continent_centres)))#
	continents_across_date_line <- vector(mode="numeric")#
	# For each continent:#
	for(i in 1:nrow(continent_centres)) {#
		# Isolate continent centre:#
		centre <- continent_centres[i, ]#
		# Create empty matrix to store points that will describe the edge of the continent:#
		edge_points <- matrix(nrow = 0, ncol = 2)#
		# For as many points as are dictated by resolution get the jth point describing the edge of the continent:#
		for(j in 1:resolution) edge_points <- rbind(edge_points, unlist(EndPoint(centre[1], centre[2], (360 / resolution) * j, radius)[c("longitude", "latitude")]))#
		# Store full continent in list:#
		continent_polygons[[i]] <- edge_points#
		if(any(abs(diff(edge_points[, 1])) > 180)) continents_across_date_line <- c(continents_across_date_line, i)#
	}#
#
	# Get distances from North pole to each continents centre:#
	North_pole_distances <- One2ManyGreatCircleDistance(0, 90, continent_centres[, 1], continent_centres[, 2])#
	# Get distances from South pole to each continents centre:#
	South_pole_distances <- One2ManyGreatCircleDistance(0, -90, continent_centres[, 1], continent_centres[, 2])#
#
	# Get number(s) of continent(s) that sit over the North pole:#
	continents_at_North_pole <- which((as.numeric(apply(matrix(North_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(North_pole_distances < radius)) == 2)#
	# Get number(s) of continent(s) that sit over the South pole:#
	continents_at_South_pole <- which((as.numeric(apply(matrix(South_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(South_pole_distances < radius)) == 2)#
	# Remove continents that only cross the date line because they also overlap the pole:#
	continents_across_date_line <- setdiff(continents_across_date_line, c(continents_at_North_pole, continents_at_South_pole))#
	# If there are continent(s) at the North pole:#
	if(length(continents_at_North_pole) > 0) {#
		# For each continent at the North pole:#
		for(i in continents_at_North_pole) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2]), c(-180, 90), c(180, 90), c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the South pole:#
	if(length(continents_at_South_pole) > 0) {#
#
		# For each continent at the South pole:#
		for(i in continents_at_South_pole) {#
#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2]), c(180, -90), c(-180, -90), c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the North pole:#
	if(length(continents_across_date_line) > 0) {#
		# For each continent that crosses the date line:#
		for(i in continents_across_date_line) {#
			# Get breaks (where latitudinal "jump" occurs as crosses date line):#
			breaks <- which(abs(diff(c(continent_polygons[[i]][, 1], continent_polygons[[i]][, 1]))) > 180)[1:2]#
			# Get first side (first "half" of the polygon):#
			side_one <- continent_polygons[[i]][(breaks[1] + 1):breaks[2], ]#
			# Get second side (second "half" of the polygon):#
			side_two <- continent_polygons[[i]][c(min(c(breaks[2] + 1, resolution)):resolution, 1:breaks[1]), ]#
			# Add extra points to draw first polygon up to the date line:#
			side_one <- rbind(side_one, matrix(c(as.vector(rep((side_one[1, 1] / abs(side_one[1, 1])) * 180, 2)), as.vector(c(side_one[nrow(side_one), 2], side_one[1, 2]))), ncol = 2))#
			# Add extra points to draw second polygon up to the date line:#
			side_two <- rbind(side_two, matrix(c(as.vector(rep((side_two[1, 1] / abs(side_two[1, 1])) * 180, 2)), as.vector(c(side_two[nrow(side_two), 2], side_two[1, 2]))), ncol = 2))#
			# Add two sides as separate polygons to the end of the list:#
			continent_polygons <- c(continent_polygons, list(side_one), list(side_two))#
		}#
		# Remove old polygon(s) from the list:#
		continent_polygons <- continent_polygons[-continents_across_date_line]#
	}#
	# Plot continental polygons:#
	for(i in 1:length(continent_polygons)) polygon(x = continent_polygons[[i]][, 1], y = continent_polygons[[i]][, 2], border = NA, col = land_colour)#
	return(continent_polygons)#
}#
#
answers <- list()#
#
pdf("test_plot.pdf", width = 18, height = 9)#
#
for(i in 1:100) {#
	continent_centres <- StartingPoints(7, 2000)#
#
	out <- map_continents(continent_centres, radius)#
	answers <- c(answers, list(out))#
#Sys.sleep(2)#
}#
#
dev.off()
map_continents <- function(continent_centres, radius, xlim = c(-180, 180), ylim = c(-90, 90), resolution = 1000, sea_colour = "blue", land_colour = "green", ...) {#
# Add grid overlay option:#
# Draw continent links to help visualise separation(s)/collision(s):#
	# Make empty plot:#
	plot(x = c(1, 1), xlim = xlim, ylim = c(-90, 90), type = "n", xlab = "Longitude", ylab = "Latitude", ...)#
	# Fill with blue background (sea):#
	polygon(x = c(-180, 180, 180, -180), y = c(90, 90, -90, -90), border = NA, col = sea_colour)#
#
	# Create empty list to store continent polygons:#
	continent_polygons <- as.list(c(1:nrow(continent_centres)))#
	# Create empty vector to store continents that cross the date line:#
	continents_across_date_line <- vector(mode="numeric")#
	# For each continent:#
	for(i in 1:nrow(continent_centres)) {#
		# Isolate continent centre:#
		centre <- continent_centres[i, ]#
		# Create empty matrix to store points that will describe the edge of the continent:#
		edge_points <- matrix(nrow = 0, ncol = 2)#
		# For as many points as are dictated by resolution get the jth point describing the edge of the continent:#
		for(j in 1:resolution) edge_points <- rbind(edge_points, unlist(EndPoint(centre[1], centre[2], (360 / resolution) * j, radius)[c("longitude", "latitude")]))#
		# Store full continent in list:#
		continent_polygons[[i]] <- edge_points#
		# Check to see if continent crosses date line and if so store the continent number:#
		if(any(abs(diff(edge_points[, 1])) > 180)) continents_across_date_line <- c(continents_across_date_line, i)#
	}#
#
	# Get distances from North pole to each continents centre:#
	North_pole_distances <- One2ManyGreatCircleDistance(0, 90, continent_centres[, 1], continent_centres[, 2])#
	# Get distances from South pole to each continents centre:#
	South_pole_distances <- One2ManyGreatCircleDistance(0, -90, continent_centres[, 1], continent_centres[, 2])#
#
	# Get number(s) of continent(s) that sit over the North pole:#
	continents_at_North_pole <- which((as.numeric(apply(matrix(North_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(North_pole_distances < radius)) == 2)#
	# Get number(s) of continent(s) that sit over the South pole:#
	continents_at_South_pole <- which((as.numeric(apply(matrix(South_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(South_pole_distances < radius)) == 2)#
	# Remove continents that only cross the date line because they also overlap the pole:#
	continents_across_date_line <- setdiff(continents_across_date_line, c(continents_at_North_pole, continents_at_South_pole))#
	# If there are continent(s) at the North pole:#
	if(length(continents_at_North_pole) > 0) {#
		# For each continent at the North pole:#
		for(i in continents_at_North_pole) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2]), c(-180, 90), c(180, 90), c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the South pole:#
	if(length(continents_at_South_pole) > 0) {#
#
		# For each continent at the South pole:#
		for(i in continents_at_South_pole) {#
#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2]), c(180, -90), c(-180, -90), c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the North pole:#
	if(length(continents_across_date_line) > 0) {#
		# For each continent that crosses the date line:#
		for(i in continents_across_date_line) {#
			# Get breaks (where latitudinal "jump" occurs as crosses date line):#
			breaks <- which(abs(diff(c(continent_polygons[[i]][, 1], continent_polygons[[i]][, 1]))) > 180)[1:2]#
			# Get first side (first "half" of the polygon):#
			side_one <- continent_polygons[[i]][(breaks[1] + 1):breaks[2], ]#
			# Get second side (second "half" of the polygon):#
			side_two <- continent_polygons[[i]][c(min(c(breaks[2] + 1, resolution)):resolution, 1:breaks[1]), ]#
			# Add extra points to draw first polygon up to the date line:#
			side_one <- rbind(side_one, matrix(c(as.vector(rep((side_one[1, 1] / abs(side_one[1, 1])) * 180, 2)), as.vector(c(side_one[nrow(side_one), 2], side_one[1, 2]))), ncol = 2))#
			# Add extra points to draw second polygon up to the date line:#
			side_two <- rbind(side_two, matrix(c(as.vector(rep((side_two[1, 1] / abs(side_two[1, 1])) * 180, 2)), as.vector(c(side_two[nrow(side_two), 2], side_two[1, 2]))), ncol = 2))#
			# Add two sides as separate polygons to the end of the list:#
			continent_polygons <- c(continent_polygons, list(side_one), list(side_two))#
		}#
		# Remove old polygon(s) from the list:#
		continent_polygons <- continent_polygons[-continents_across_date_line]#
	}#
	# Plot continental polygons:#
	for(i in 1:length(continent_polygons)) polygon(x = continent_polygons[[i]][, 1], y = continent_polygons[[i]][, 2], border = NA, col = land_colour)#
}
map_continents(continent_centres, radius)
?map
getwd()
document()
check()
library(strap)
geoscalePhylo
?plot
check()
install()
library(dispeRse)
library(animation)
saveGIF({#
brownian.motion(pch = 21, cex = 5, col = "red", bg = "yellow")#
}, movie.name = "brownian_motion.gif", interval = 0.1, nmax = 30, ani.width = 600,#
ani.height = 600)
DispersalSimulator(N_steps = 200, organism_multiplier = 1)
out <- DispersalSimulator(N_steps = 200, organism_multiplier = 1)
names(out)
out$continent_positions
out$continent_positions[, , 1]
out$continent_positions[i, , 1]
i<-1
out$continent_positions[i, , 1]
out$continent_positions[, i, 1]
out$continent_positions[, i, 2]
cbind(out$continent_positions[, i, 1], out$continent_positions[, i, 2])
out <- DispersalSimulator(N_steps = 200, organism_multiplier = 1, radius = 2000)#
#
saveGIF({#
#
	for(i in 1:200) MapContinents(cbind(out$continent_positions[, i, 1], out$continent_positions[, i, 2]), radius = 2000)#
#
}, movie.name = "test.gif", interval = 0.1, nmax = 200, ani.width = 600, ani.height = 600)
?ani.options
names(out)
out$organism_longitudes
out$organism_longitudes[, i]
out$organism_longitudes
out$organism_longitudes[, i]
cbind(out$organism_longitudes[, i], out$organism_latitudes[, i])
out <- DispersalSimulator(N_steps = 200, organism_multiplier = 1, radius = 2000)#
#
saveGIF({#
#
	for(i in 1:201) {#
		MapContinents(cbind(out$continent_positions[, i, 1], out$continent_positions[, i, 2]), radius = 2000)#
#
		points(x = out$organism_longitudes[, i], y = out$organism_latitudes[, i], pch=19, col="red")#
#
	}#
#
}, movie.name = "test.gif", interval = 0.1, nmax = 200, ani.width = 600, ani.height = 600)
saveGIF({#
#
	for(i in 1:201) {#
		MapContinents(cbind(out$continent_positions[, i, 1], out$continent_positions[, i, 2]), radius = 2000)#
#
		points(x = out$organism_longitudes[, i], y = out$organism_latitudes[, i], pch=19, col="red")#
#
	}#
#
}, movie.name = "test.gif", interval = 0.1, nmax = 201, ani.width = 600, ani.height = 600)
saveGIF({#
#
	for(i in 1:201) {#
		MapContinents(cbind(out$continent_positions[, i, 1], out$continent_positions[, i, 2]), radius = 2000)#
#
		points(x = out$organism_longitudes[, i], y = out$organism_latitudes[, i], pch=19, col="red")#
#
	}#
#
}, movie.name = "test.gif", interval = 0.1, nmax = 201, ani.width = 600, ani.height = 600)
DispersalSimulatorout <- DispersalSimulator(N_steps = 200, organism_multiplier = 1, radius = 2000, continent_speed_mean = 50, sontinent_speed_sd = 20, organism_step_sd = 1000, start_configuration = "supercontinent")
out <- DispersalSimulator(N_steps = 200, organism_multiplier = 1, radius = 2000, continent_speed_mean = 50, continent_speed_sd = 20, organism_step_sd = 1000, start_configuration = "supercontinent")#
#
saveGIF({#
#
	for(i in 1:201) {#
		MapContinents(cbind(out$continent_positions[, i, 1], out$continent_positions[, i, 2]), radius = 2000)#
#
		points(x = out$organism_longitudes[, i], y = out$organism_latitudes[, i], pch=19, col="red")#
#
	}#
#
}, movie.name = "test.gif", interval = 0.1, nmax = 201, ani.width = 600, ani.height = 600)
out <- DispersalSimulator(N_steps = 200, organism_multiplier = 1, radius = 2000, continent_speed_mean = 50, continent_speed_sd = 20, organism_step_sd = 1000, start_configuration = "supercontinent")#
#
saveGIF({#
#
	for(i in 1:201) {#
		MapContinents(cbind(out$continent_positions[, i, 1], out$continent_positions[, i, 2]), radius = 2000)#
#
		points(x = out$organism_longitudes[, i], y = out$organism_latitudes[, i], pch=19, col="red")#
#
	}#
#
}, movie.name = "test.gif", interval = 0.1, nmax = 201, ani.width = 600, ani.height = 600)
out <- DispersalSimulator(N_steps = 200, organism_multiplier = 1, radius = 2000, continent_speed_mean = 50, continent_speed_sd = 20, organism_step_sd = 1000, start_configuration = "supercontinent")#
#
saveGIF({#
#
	for(i in 1:201) {#
		MapContinents(cbind(out$continent_positions[, i, 1], out$continent_positions[, i, 2]), radius = 2000)#
#
		points(x = out$organism_longitudes[, i], y = out$organism_latitudes[, i], pch=19, col="red")#
#
	}#
#
}, movie.name = "test.gif", interval = 0.1, nmax = 201, ani.width = 600, ani.height = 600)
out <- DispersalSimulator(N_steps = 200, organism_multiplier = 1, radius = 2000, continent_speed_mean = 50, continent_speed_sd = 20, organism_step_sd = 1000, start_configuration = "supercontinent")#
#
saveGIF({#
#
	for(i in 1:201) {#
		MapContinents(cbind(out$continent_positions[, i, 1], out$continent_positions[, i, 2]), radius = 2000)#
#
		points(x = out$organism_longitudes[, i], y = out$organism_latitudes[, i], pch=19, col="red")#
#
	}#
#
}, movie.name = "test.gif", interval = 0.1, nmax = 201, ani.width = 600, ani.height = 600)
out <- DispersalSimulator(N_steps = 200, organism_multiplier = 1, radius = 2000, continent_speed_mean = 50, continent_speed_sd = 20, organism_step_sd = 1000, start_configuration = "supercontinent", stickiness = 0)
out <- DispersalSimulator(N_steps = 200, organism_multiplier = 1, radius = 2000, continent_speed_mean = 50, continent_speed_sd = 20, organism_step_sd = 1000, start_configuration = "supercontinent", stickiness = 0)
out <- DispersalSimulator(N_steps = 200, organism_multiplier = 1, radius = 2000, continent_speed_mean = 50, continent_speed_sd = 20, organism_step_sd = 1000, start_configuration = "supercontinent", stickiness = 0.1)
out <- DispersalSimulator(N_steps = 200, organism_multiplier = 1, radius = 2000, continent_speed_mean = 50, continent_speed_sd = 20, organism_step_sd = 1000, start_configuration = "supercontinent", stickiness = 0.5)
saveGIF({#
#
	for(i in 1:201) {#
		MapContinents(cbind(out$continent_positions[, i, 1], out$continent_positions[, i, 2]), radius = 2000)#
#
		points(x = out$organism_longitudes[, i], y = out$organism_latitudes[, i], pch=19, col="red")#
#
	}#
#
}, movie.name = "test.gif", interval = 0.1, nmax = 201, ani.width = 600, ani.height = 600)
MapContinents(cbind(out$continent_positions[, 19, 1], out$continent_positions[, 19, 2]), radius = 2000)
dev.off()
dev.off()
dev.off()
MapContinents(cbind(out$continent_positions[, 19, 1], out$continent_positions[, 19, 2]), radius = 2000)
#' Maps continents on Mercator projection#
#'#
#' Given a set of continent centres and their radius plots them on a Mercator projection#
#'#
#' @param continent_centres A two-column matrix of decimalised longitudes (first column) and latitudes (second column).#
#' @param radius A single radius value for each continent in kilometres.#
#' @param xlim A single radius value for each continent in kilometres.#
#' @param ylim A single radius value for each continent in kilometres.#
#' @param resolution The number of points to use to plot each continent.#
#' @param sea_colour The colour value to use to plot the sea.#
#' @param land_colour The colour value used to plot the land.#
#' @param ... Other arguments to be passed to \link{plot}.#
#' @return A Mercator projection plot of each continent.#
#' @details Nothing yet.#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#' @export#
#' @examples#
#' MapContinents(continent_centres = matrix(c(-0, 0), ncol=2), radius = 2000)#
#
MapContinents <- function(continent_centres, radius, xlim = c(-180, 180), ylim = c(-90, 90), resolution = 1000, sea_colour = "blue", land_colour = "green", ...) {#
# Add grid overlay option:#
# Add option to draw continent links to help visualise separation(s)/collision(s)#
# Add ability to use other projection options than Mercator#
# Ensure resolution has a minimum value of say, 100.#
# Top-level conditionals to check values make sense, e.g., long-lat within limits.#
# Allow borders of continents to be plotted?#
# Remove borders of plot/axes? Or allow option to.#
	# Make empty plot:#
	plot(x = c(1, 1), xlim = xlim, ylim = c(-90, 90), type = "n", xlab = "Longitude", ylab = "Latitude", axes = F, ...)#
	# Fill with blue background (sea):#
	polygon(x = c(-180, 180, 180, -180), y = c(90, 90, -90, -90), border = NA, col = sea_colour)#
#
	# Create empty list to store continent polygons:#
	continent_polygons <- as.list(c(1:nrow(continent_centres)))#
	# Create empty vector to store continents that cross the date line:#
	continents_across_date_line <- vector(mode="numeric")#
	# For each continent:#
	for(i in 1:nrow(continent_centres)) {#
		# Isolate continent centre:#
		centre <- continent_centres[i, ]#
		# Create empty matrix to store points that will describe the edge of the continent:#
		edge_points <- matrix(nrow = 0, ncol = 2)#
		# For as many points as are dictated by resolution get the jth point describing the edge of the continent:#
		for(j in 1:resolution) edge_points <- rbind(edge_points, unlist(EndPoint(centre[1], centre[2], (360 / resolution) * j, radius)[c("longitude", "latitude")]))#
		# Store full continent in list:#
		continent_polygons[[i]] <- edge_points#
		# Check to see if continent crosses date line and if so store the continent number:#
		if(any(abs(diff(edge_points[, 1])) > 180)) continents_across_date_line <- c(continents_across_date_line, i)#
	}#
#
	# Get distances from North pole to each continents centre:#
	North_pole_distances <- One2ManyGreatCircleDistance(0, 90, continent_centres[, 1], continent_centres[, 2])#
	# Get distances from South pole to each continents centre:#
	South_pole_distances <- One2ManyGreatCircleDistance(0, -90, continent_centres[, 1], continent_centres[, 2])#
#
	# Get number(s) of continent(s) that sit over the North pole:#
	continents_at_North_pole <- which((as.numeric(apply(matrix(North_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(North_pole_distances < radius)) == 2)#
	# Get number(s) of continent(s) that sit over the South pole:#
	continents_at_South_pole <- which((as.numeric(apply(matrix(South_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(South_pole_distances < radius)) == 2)#
	# Remove continents that only cross the date line because they also overlap the pole:#
	continents_across_date_line <- setdiff(continents_across_date_line, c(continents_at_North_pole, continents_at_South_pole))#
	# If there are continent(s) at the North pole:#
	if(length(continents_at_North_pole) > 0) {#
		# For each continent at the North pole:#
		for(i in continents_at_North_pole) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2]), c(-180, 90), c(180, 90), c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the South pole:#
	if(length(continents_at_South_pole) > 0) {#
#
		# For each continent at the South pole:#
		for(i in continents_at_South_pole) {#
#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2]), c(180, -90), c(-180, -90), c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the North pole:#
	if(length(continents_across_date_line) > 0) {#
		# For each continent that crosses the date line:#
		for(i in continents_across_date_line) {#
			# Get breaks (where latitudinal "jump" occurs as crosses date line):#
			breaks <- which(abs(diff(c(continent_polygons[[i]][, 1], continent_polygons[[i]][, 1]))) > 180)[1:2]#
			# Get first side (first "half" of the polygon):#
			side_one <- continent_polygons[[i]][(breaks[1] + 1):breaks[2], ]#
			# Get second side (second "half" of the polygon):#
			side_two <- continent_polygons[[i]][c(min(c(breaks[2] + 1, resolution)):resolution, 1:breaks[1]), ]#
			# Add extra points to draw first polygon up to the date line:#
			side_one <- rbind(side_one, matrix(c(as.vector(rep((side_one[1, 1] / abs(side_one[1, 1])) * 180, 2)), as.vector(c(side_one[nrow(side_one), 2], side_one[1, 2]))), ncol = 2))#
			# Add extra points to draw second polygon up to the date line:#
			side_two <- rbind(side_two, matrix(c(as.vector(rep((side_two[1, 1] / abs(side_two[1, 1])) * 180, 2)), as.vector(c(side_two[nrow(side_two), 2], side_two[1, 2]))), ncol = 2))#
			# Add two sides as separate polygons to the end of the list:#
			continent_polygons <- c(continent_polygons, list(side_one), list(side_two))#
		}#
		# Remove old polygon(s) from the list:#
		continent_polygons <- continent_polygons[-continents_across_date_line]#
	}#
	# Plot continental polygons:#
	for(i in 1:length(continent_polygons)) polygon(x = continent_polygons[[i]][, 1], y = continent_polygons[[i]][, 2], border = NA, col = land_colour)#
}
MapContinents(cbind(out$continent_positions[, 19, 1], out$continent_positions[, 19, 2]), radius = 2000)
?plot
radius
continent_centres <- cbind(out$continent_positions[, 19, 1], out$continent_positions[, 19, 2])
# Create empty list to store continent polygons:#
	continent_polygons <- as.list(c(1:nrow(continent_centres)))#
	# Create empty vector to store continents that cross the date line:#
	continents_across_date_line <- vector(mode="numeric")#
	# For each continent:#
	for(i in 1:nrow(continent_centres)) {#
		# Isolate continent centre:#
		centre <- continent_centres[i, ]#
		# Create empty matrix to store points that will describe the edge of the continent:#
		edge_points <- matrix(nrow = 0, ncol = 2)#
		# For as many points as are dictated by resolution get the jth point describing the edge of the continent:#
		for(j in 1:resolution) edge_points <- rbind(edge_points, unlist(EndPoint(centre[1], centre[2], (360 / resolution) * j, radius)[c("longitude", "latitude")]))#
		# Store full continent in list:#
		continent_polygons[[i]] <- edge_points#
		# Check to see if continent crosses date line and if so store the continent number:#
		if(any(abs(diff(edge_points[, 1])) > 180)) continents_across_date_line <- c(continents_across_date_line, i)#
	}#
#
	# Get distances from North pole to each continents centre:#
	North_pole_distances <- One2ManyGreatCircleDistance(0, 90, continent_centres[, 1], continent_centres[, 2])#
	# Get distances from South pole to each continents centre:#
	South_pole_distances <- One2ManyGreatCircleDistance(0, -90, continent_centres[, 1], continent_centres[, 2])#
#
	# Get number(s) of continent(s) that sit over the North pole:#
	continents_at_North_pole <- which((as.numeric(apply(matrix(North_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(North_pole_distances < radius)) == 2)#
	# Get number(s) of continent(s) that sit over the South pole:#
	continents_at_South_pole <- which((as.numeric(apply(matrix(South_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(South_pole_distances < radius)) == 2)#
	# Remove continents that only cross the date line because they also overlap the pole:#
	continents_across_date_line <- setdiff(continents_across_date_line, c(continents_at_North_pole, continents_at_South_pole))#
	# If there are continent(s) at the North pole:#
	if(length(continents_at_North_pole) > 0) {#
		# For each continent at the North pole:#
		for(i in continents_at_North_pole) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2]), c(-180, 90), c(180, 90), c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the South pole:#
	if(length(continents_at_South_pole) > 0) {#
#
		# For each continent at the South pole:#
		for(i in continents_at_South_pole) {#
#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2]), c(180, -90), c(-180, -90), c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}
continents_across_date_line
# For each continent that crosses the date line:#
		for(i in continents_across_date_line) {
}
# Get breaks (where latitudinal "jump" occurs as crosses date line):#
			breaks <- which(abs(diff(c(continent_polygons[[i]][, 1], continent_polygons[[i]][, 1]))) > 180)[1:2]#
			# Get first side (first "half" of the polygon):#
			side_one <- continent_polygons[[i]][(breaks[1] + 1):breaks[2], ]#
			# Get second side (second "half" of the polygon):#
			side_two <- continent_polygons[[i]][c(min(c(breaks[2] + 1, resolution)):resolution, 1:breaks[1]), ]#
			# Add extra points to draw first polygon up to the date line:#
			side_one <- rbind(side_one, matrix(c(as.vector(rep((side_one[1, 1] / abs(side_one[1, 1])) * 180, 2)), as.vector(c(side_one[nrow(side_one), 2], side_one[1, 2]))), ncol = 2))#
			# Add extra points to draw second polygon up to the date line:#
			side_two <- rbind(side_two, matrix(c(as.vector(rep((side_two[1, 1] / abs(side_two[1, 1])) * 180, 2)), as.vector(c(side_two[nrow(side_two), 2], side_two[1, 2]))), ncol = 2))
side_one
side_two
# Get breaks (where latitudinal "jump" occurs as crosses date line):#
			breaks <- which(abs(diff(c(continent_polygons[[i]][, 1], continent_polygons[[i]][, 1]))) > 180)[1:2]#
			# Get first side (first "half" of the polygon):#
			side_one <- continent_polygons[[i]][(breaks[1] + 1):breaks[2], ]#
			# Get second side (second "half" of the polygon):#
			side_two <- continent_polygons[[i]][c(min(c(breaks[2] + 1, resolution)):resolution, 1:breaks[1]), ]
side_one
side_two
continent_polygons[[i]]
# Get breaks (where latitudinal "jump" occurs as crosses date line):#
			breaks <- which(abs(diff(c(continent_polygons[[i]][, 1], continent_polygons[[i]][, 1]))) > 180)[1:2]
breaks
continent_polygons[[i]][(breaks[1] + 1):breaks[2], ]
min(c(breaks[2] + 1, resolution)):resolution
1:breaks[1])
1:breaks[1]
breaks
continent_polygons[[i]]
continent_polygons[[i]][,1]
# Get breaks (where latitudinal "jump" occurs as crosses date line):#
			breaks <- which(abs(diff(c(continent_polygons[[i]][, 1], continent_polygons[[i]][, 1]))) > 180)[1:2]
(breaks[1] + 1):breaks[2]
1:breaks[1]
continent_polygons[[i]][(breaks[1] + 1):breaks[2], 1]
breaks
continent_polygons[[i]][,1]
breaks[2] + 1
breaks[2] + 1 %% resolution
(breaks[2] + 1) %% resolution
c(min(c(breaks[2] + 1, resolution)):resolution, 1:breaks[1])
side_one
side_two
breaks[2] + 1
(breaks[2] + 1) %% resolution
breaks
side_one
breaks
1:breaks[1]
c(min(c(breaks[2] + 1, resolution)):resolution, 1:breaks[1])
min(c(breaks[2] + 1, resolution)):resolution
breaks
1:breaks[1]
c(min(c(breaks[2] + 1, resolution)):resolution
breaks[2] + 1
(breaks[2] + 1):resolution
breaks[2] <- 999
(breaks[2] + 1):resolution
#' Maps continents on Mercator projection#
#'#
#' Given a set of continent centres and their radius plots them on a Mercator projection#
#'#
#' @param continent_centres A two-column matrix of decimalised longitudes (first column) and latitudes (second column).#
#' @param radius A single radius value for each continent in kilometres.#
#' @param xlim A single radius value for each continent in kilometres.#
#' @param ylim A single radius value for each continent in kilometres.#
#' @param resolution The number of points to use to plot each continent.#
#' @param sea_colour The colour value to use to plot the sea.#
#' @param land_colour The colour value used to plot the land.#
#' @param ... Other arguments to be passed to \link{plot}.#
#' @return A Mercator projection plot of each continent.#
#' @details Nothing yet.#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#' @export#
#' @examples#
#' MapContinents(continent_centres = matrix(c(-0, 0), ncol=2), radius = 2000)#
#
MapContinents <- function(continent_centres, radius, xlim = c(-180, 180), ylim = c(-90, 90), resolution = 1000, sea_colour = "blue", land_colour = "green", ...) {#
# Add grid overlay option:#
# Add option to draw continent links to help visualise separation(s)/collision(s)#
# Add ability to use other projection options than Mercator#
# Ensure resolution has a minimum value of say, 100.#
# Top-level conditionals to check values make sense, e.g., long-lat within limits.#
# Allow borders of continents to be plotted?#
# Remove borders of plot/axes? Or allow option to.#
	# Make empty plot:#
	plot(x = c(1, 1), xlim = xlim, ylim = c(-90, 90), type = "n", xlab = "Longitude", ylab = "Latitude", ...)#
	# Fill with blue background (sea):#
	polygon(x = c(-180, 180, 180, -180), y = c(90, 90, -90, -90), border = NA, col = sea_colour)#
#
	# Create empty list to store continent polygons:#
	continent_polygons <- as.list(c(1:nrow(continent_centres)))#
	# Create empty vector to store continents that cross the date line:#
	continents_across_date_line <- vector(mode="numeric")#
	# For each continent:#
	for(i in 1:nrow(continent_centres)) {#
		# Isolate continent centre:#
		centre <- continent_centres[i, ]#
		# Create empty matrix to store points that will describe the edge of the continent:#
		edge_points <- matrix(nrow = 0, ncol = 2)#
		# For as many points as are dictated by resolution get the jth point describing the edge of the continent:#
		for(j in 1:resolution) edge_points <- rbind(edge_points, unlist(EndPoint(centre[1], centre[2], (360 / resolution) * j, radius)[c("longitude", "latitude")]))#
		# Store full continent in list:#
		continent_polygons[[i]] <- edge_points#
		# Check to see if continent crosses date line and if so store the continent number:#
		if(any(abs(diff(edge_points[, 1])) > 180)) continents_across_date_line <- c(continents_across_date_line, i)#
	}#
#
	# Get distances from North pole to each continents centre:#
	North_pole_distances <- One2ManyGreatCircleDistance(0, 90, continent_centres[, 1], continent_centres[, 2])#
	# Get distances from South pole to each continents centre:#
	South_pole_distances <- One2ManyGreatCircleDistance(0, -90, continent_centres[, 1], continent_centres[, 2])#
#
	# Get number(s) of continent(s) that sit over the North pole:#
	continents_at_North_pole <- which((as.numeric(apply(matrix(North_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(North_pole_distances < radius)) == 2)#
	# Get number(s) of continent(s) that sit over the South pole:#
	continents_at_South_pole <- which((as.numeric(apply(matrix(South_pole_distances, nrow = 1), 2, all.equal, current = radius) != TRUE) + as.numeric(South_pole_distances < radius)) == 2)#
	# Remove continents that only cross the date line because they also overlap the pole:#
	continents_across_date_line <- setdiff(continents_across_date_line, c(continents_at_North_pole, continents_at_South_pole))#
	# If there are continent(s) at the North pole:#
	if(length(continents_at_North_pole) > 0) {#
		# For each continent at the North pole:#
		for(i in continents_at_North_pole) {#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2]), c(-180, 90), c(180, 90), c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) at the South pole:#
	if(length(continents_at_South_pole) > 0) {#
#
		# For each continent at the South pole:#
		for(i in continents_at_South_pole) {#
#
			# Get signs (positive/negative) of longitudes (i.e., corresponding to East/West) of points in polygon:#
			longitude_signs <- continent_polygons[[i]][, 1] / abs(continent_polygons[[i]][, 1])#
			# Get breaks (where switch from positive to negative occurs):#
			breaks <- which(abs(diff(longitude_signs)) > 0)#
			# Reorder points using first break:#
			continent_polygons[[i]] <- continent_polygons[[i]][c((breaks[1] + 1):resolution, 1:breaks[1]), ]#
			# Build mini-matrix of additonal points (to take continent to date line and corners):#
			extra_points <- matrix(c(c(180, continent_polygons[[i]][which.max(continent_polygons[[i]][, 1]), 2]), c(180, -90), c(-180, -90), c(-180, continent_polygons[[i]][which.min(continent_polygons[[i]][, 1]), 2])), ncol = 2, byrow = TRUE)#
			# Add extra points in right part of continent to plot:#
			continent_polygons[[i]] <- rbind(continent_polygons[[i]][1:which.max(continent_polygons[[i]][, 1]), ], extra_points, continent_polygons[[i]][setdiff(1:resolution, 1:which.max(continent_polygons[[i]][, 1])), ])#
		}#
	}#
	# If there are continent(s) that cross the date line:#
	if(length(continents_across_date_line) > 0) {#
		# For each continent that crosses the date line:#
		for(i in continents_across_date_line) {#
			# Get breaks (where latitudinal "jump" occurs as crosses date line):#
			breaks <- which(abs(diff(c(continent_polygons[[i]][, 1], continent_polygons[[i]][, 1]))) > 180)[1:2]#
			# Get first side (first "half" of the polygon):#
			side_one <- continent_polygons[[i]][(breaks[1] + 1):breaks[2], ]#
			# Get second side (second "half" of the polygon):#
			if(breaks[2] != resolution) side_two <- continent_polygons[[i]][c((breaks[2] + 1):resolution, 1:breaks[1]), ]#
			# Get second side (second "half" of the polygon):#
			if(breaks[2] == resolution) side_two <- continent_polygons[[i]][c(1:breaks[1]), ]#
			# Add extra points to draw first polygon up to the date line:#
			side_one <- rbind(side_one, matrix(c(as.vector(rep((side_one[1, 1] / abs(side_one[1, 1])) * 180, 2)), as.vector(c(side_one[nrow(side_one), 2], side_one[1, 2]))), ncol = 2))#
			# Add extra points to draw second polygon up to the date line:#
			side_two <- rbind(side_two, matrix(c(as.vector(rep((side_two[1, 1] / abs(side_two[1, 1])) * 180, 2)), as.vector(c(side_two[nrow(side_two), 2], side_two[1, 2]))), ncol = 2))#
			# Add two sides as separate polygons to the end of the list:#
			continent_polygons <- c(continent_polygons, list(side_one), list(side_two))#
		}#
		# Remove old polygon(s) from the list:#
		continent_polygons <- continent_polygons[-continents_across_date_line]#
	}#
	# Plot continental polygons:#
	for(i in 1:length(continent_polygons)) polygon(x = continent_polygons[[i]][, 1], y = continent_polygons[[i]][, 2], border = NA, col = land_colour)#
}
saveGIF({#
#
	for(i in 1:201) {#
		MapContinents(cbind(out$continent_positions[, i, 1], out$continent_positions[, i, 2]), radius = 2000)#
#
		points(x = out$organism_longitudes[, i], y = out$organism_latitudes[, i], pch=19, col="red")#
#
	}#
#
}, movie.name = "test.gif", interval = 0.1, nmax = 201, ani.width = 600, ani.height = 600)
out <- DispersalSimulator(N_steps = 200, organism_multiplier = 1, radius = 2000, continent_speed_mean = 50, continent_speed_sd = 20, organism_step_sd = 1000, start_configuration = "supercontinent", stickiness = 0.5)#
#
saveGIF({#
#
	for(i in 1:201) {#
		MapContinents(cbind(out$continent_positions[, i, 1], out$continent_positions[, i, 2]), radius = 2000)#
#
		points(x = out$organism_longitudes[, i], y = out$organism_latitudes[, i], pch=19, col="red")#
#
	}#
#
}, movie.name = "test.gif", interval = 0.1, nmax = 201, ani.width = 600, ani.height = 600)
out <- DispersalSimulator(N_steps = 200, organism_multiplier = 1, radius = 2000, continent_speed_mean = 50, continent_speed_sd = 20, organism_step_sd = 1000, start_configuration = "supercontinent", stickiness = 0.5)
