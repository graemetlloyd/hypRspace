tan(0)
tan(180)
tan(270)
tan(360)
tan(1234801)
tan(-1234801)
s - side_length
side_length
s <- (3 * side_length) / 2
tan((s - side_length) / 2)
?geosphere
areaPolygon
areaPolygon-method
?geosphere
showMethods("areaPolygon")
library(geosphere)
min_separation
min_separation * 2
GetThetaFromGreatCircleDistance(min_separation * 2)
GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(min_separation * 2))
x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))
x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
				(y / 2)  / (z / 2)
asin((y / 2) / (z / 2))
asin((y / 2) / (z / 2)) * (pi / 180)
asin((y / 2) / (z / 2)) / (pi / 180)
asin((y / 2) / (z / 2)) / (pi / 180) * 2
x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2
spherical_angle
first_circle_long
first_circle_lat
GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat)
GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat) + spherical_angle
(GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat) + spherical_angle)
(GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat) + spherical_angle) %% 360
x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2#
#
				new_bearing <- (GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat) + spherical_angle) %% 360
EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)
GetGreatCircleDistanceFromLongLat(second_circle_long, second_circle_lat, EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)$long, EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)$lat)
min_separation
x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2#
#
				new_bearing <- (GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat) - spherical_angle) %% 360#
				GetGreatCircleDistanceFromLongLat(second_circle_long, second_circle_lat, EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)$long, EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)$lat)
min_separation
x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2#
#
				new_bearing <- (GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat) - spherical_angle) %% 360#
				GetGreatCircleDistanceFromLongLat(first_circle_long, first_circle_lat, EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)$long, EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)$lat)
x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2#
#
				new_bearing <- (GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat) + spherical_angle) %% 360#
				GetGreatCircleDistanceFromLongLat(first_circle_long, first_circle_lat, EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)$long, EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)$lat)
GetGreatCircleDistanceFromLongLat(second_circle_long, second_circle_lat, first_circle_long, first_circle_lat)
spherical_angle
min_separation
x <- min_separation * 2
x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
				x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2
spherical_angle
x <- min_separation *  2#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2
spherical_angle
x <- min_separation * 4#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2
spherical_angle
2 * pi * EarthRad
0.5 * pi * EarthRad
x <- 0.5 * pi * EarthRad
y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2
spherical_angle
x <- 0.0000000001#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2
spherical_angle
# Get the spherical angle for an equilateral triangle where its sides (as great circle distances) are known:#
	GetSphericalAngleForEquilateralTriangleFromGreatCircleSideLength <- function(side_length, EarthRad = 6367.4447) {#
# Check this works for triangles larger than equivalent of 90-degrees of latitude on each side!#
		# Get y (which will be double the opposite for the triangle we are trying to solve):#
		y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(side_length))#
		# Get z which will be double the hypotenuse for the triangle we are trying to solve):#
		z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(side_length * 2))#
		# Solve the traingle for theta (the spherical angle) and convert to degrees:#
		spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2#
		# Return the spherical angle:#
		return(spherical_angle)#
	}
GetSphericalAngleForEquilateralTriangleFromGreatCircleSideLength(min_separation)
spherical_angle
spherical_angle <- GetSphericalAngleForEquilateralTriangleFromGreatCircleSideLength(min_separation)
spherical_angle
new_bearing <- (GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat) - spherical_angle) %% 360
new_bearing
GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat)
spherical_angle <- GetSphericalAngleForEquilateralTriangleFromGreatCircleSideLength(min_separation)#
				new_bearing_1 <- (GetBearing(first_circle_long, first_circle_lat, second_circle_long, second_circle_lat) - spherical_angle) %% 360#
				new_bearing_2 <- (GetBearing(first_circle_long, first_circle_lat, second_circle_long, second_circle_lat) + spherical_angle) %% 360#
				new_continent_1 <- EndPoint(first_circle_long, first_circle_lat, new_bearing_1, min_separation)#
				new_continent_2 <- EndPoint(first_circle_long, first_circle_lat, new_bearing_2, min_separation)#
				GetGreatCircleDistanceFromLongLat(second_circle_long, second_circle_lat, first_circle_long, first_circle_lat)#
#
				GetGreatCircleDistanceFromLongLat(second_circle_long, second_circle_lat, new_continent_1$long, new_continent_1$lat)#
				GetGreatCircleDistanceFromLongLat(second_circle_long, second_circle_lat, new_continent_2$long, new_continent_2$lat)
sample(c(1, 2), 1)
new_continent_1
unlist(new_continent_1)
rbind(unlist(new_continent_1), unlist(new_continent_2))
rbind(unlist(new_continent_1), unlist(new_continent_2))[, 1:2]
rbind(unlist(new_continent_1), unlist(new_continent_2))[, c("long", "lat")]
rbind(unlist(new_continent_1), unlist(new_continent_2))[, c("long", "lat")][sample(c(1, 2), 1), ]
# Get spherical angle of equilateral (spherical) triangle with sides equal to minimum separation:#
				spherical_angle <- GetSphericalAngleForEquilateralTriangleFromGreatCircleSideLength(min_separation)#
#
				# Get first of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_1 <- (GetBearing(first_circle_long, first_circle_lat, second_circle_long, second_circle_lat) - spherical_angle) %% 360#
				# Get second of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_2 <- (GetBearing(first_circle_long, first_circle_lat, second_circle_long, second_circle_lat) + spherical_angle) %% 360#
				# Get lat-long coordinates of first possible site of third continent:#
				new_continent_1 <- EndPoint(first_circle_long, first_circle_lat, new_bearing_1, min_separation)#
				# Get lat-long coordinates of second possible site of third continent:#
				new_continent_2 <- EndPoint(first_circle_long, first_circle_lat, new_bearing_2, min_separation)#
				# Randomly pick site for third continent:#
				third_circle <- rbind(unlist(new_continent_1), unlist(new_continent_2))[, c("long", "lat")][sample(c(1, 2), 1), ]
third_circle
third_circle$long
third_circle["long"]
c(1, first_circle_long, first_circle_lat)
matrix(c(1, first_circle_long, first_circle_lat), ncol=3)
matrix(c(1, first_circle_long, first_circle_lat), ncol=3, dimnames=list(c(), c("Circle", "Longitude", "Latitude")))
circles
# Create matrix to store circles:#
		circles <- matrix(c(1, first_circle_long, first_circle_lat), ncol=3, dimnames=list(c(), c("Circle", "Longitude", "Latitude")))
c(2, second_circle$long, second_circle$lat)
rbind(circles, c(2, second_circle$long, second_circle$lat))
# Add second continent to circles matrix:#
			circles <- rbind(circles, c(2, second_circle$long, second_circle$lat))
c(3, third_circle["long"], third_circle["lat"])
rbind(circles, c(3, third_circle["long"], third_circle["lat"]))
N_continents
N_continents <- 7
N_continents > nrow(circles)
library(devtools)
setwd("~/Documents/Publications/in prep/dispeRse")
check()
install()
build()
library(dispeRse)
library(maps)#
#
EarthRad <- 6367.4447#
#
niter <- 100#
#
n_aminals <- 100#
#
stepsize_sd <- 100#
#
continent_centre <- c(0, 0)#
#
continent_radius <- 2000#
#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
end_distances <- start_distances <- vector(mode="numeric")#
#
#response <- "bounce"#
response <- "redraw"#
#response <- "stop"#
#
for(i in 1:n_aminals) {#
#
	bearing <- runif(1, 0, 360)#
#
	distance <- runif(1, 0, continent_radius)#
	start_positions <- rbind(start_positions, unlist(EndPoint(continent_centre[1], continent_centre[1], bearing, distance)[c("long", "lat")]))#
	# Record distance from centre of continent:#
	start_distances[i] <- distance#
}#
#
map(xlim=c(-radius / ((2 * pi * EarthRad) / 360), radius / ((2 * pi * EarthRad) / 360)), ylim=c(-radius / ((2 * pi * EarthRad) / 360), radius / ((2 * pi * EarthRad) / 360)))#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="red", cex=0.5)#
#
# For each time step:#
for(i in 1:niter) {#
	# For each organism:#
	for(j in 1:n_aminals) {#
		# Draw a random bearing for the next move:#
		bearing <- runif(1, 0, 360)#
		# Draw a random distance for the next move:#
		distance <- abs(rnorm(1, 0, stepsize_sd))#
		# Calculate the new position of the organism following the move:#
		new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
		# If draw means leaving continent:#
		if(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
			stop("")#
			# If response to leaving continent is to redraw:#
			if(response == "redraw") {#
				# As long as the draw removes the taxon from the continent:#
				while(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
					# Redraw the bearing:#
					bearing <- runif(1, 0, 360)#
					# Redraw the distance:#
					distance <- abs(rnorm(1, 0, stepsize_sd))#
					# Calculate the new position:#
					new_position <- EndPoint(start_positions[i, 1], start_positions[i, 2], bearing, distance)[c("long", "lat")]#
				}#
				# Overwrite start positions:#
				start_positions[j, ] <- unlist(new_position)#
				# Record distance from centre of continent:#
				end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
			# If response to leaving continent is not to redraw (i.e., is to bounce off of, or stop at, continent edge):#
			} else {#
# Find collision point here (needed by both bounce and stop):#
#
# Will proportion of bearing as distances help find spot?#
				# Scalar which describes the proportion of the disatcne the organism has to travel before colliding with the continent edge:#
				distance_modifier <- 0.5#
				# Starting stepsize (will shrink as answer is honed in on more precisely):#
				stepsize <- 0.1#
				new_position <- EndPoint(start_positions[i, 1], start_positions[i, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
				while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
				}#
				continent_centre_angle_bearing_1 <- BearingBetweenTwoLongLatPoints(continent_centre[1], continent_centre[2], new_position$long, new_position$lat)#
				continent_centre_angle_bearing_2 <- BearingBetweenTwoLongLatPoints(continent_centre[1], continent_centre[2], start_positions[j, 1], start_positions[j, 2])#
				continent_centre_angle <- min(c(abs(continent_centre_angle_bearing_1 - continent_centre_angle_bearing_2), 360 - abs(continent_centre_angle_bearing_1 - continent_centre_angle_bearing_2)))#
				if(all.equal((continent_centre_angle_bearing_1 - continent_centre_angle) %% 360, continent_centre_angle_bearing_2) == TRUE) angle_sign <- -1#
				if(all.equal((continent_centre_angle_bearing_1 + continent_centre_angle) %% 360, continent_centre_angle_bearing_2) == TRUE) angle_sign <- 1#
				continent_2_start_distance <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_positions[j, 1], start_positions[j, 2])#
#
				continent_2_end_distance <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat)#
				distance_proportion <- (continent_radius - continent_2_start_distance) / (continent_2_end_distance - continent_2_start_distance)#
				collision_point_guess <- EndPoint(continent_centre[1], continent_centre[2], continent_centre_angle_bearing_1 + (distance_proportion * continent_centre_angle * angle_sign), continent_radius)[c("long", "lat")]#
				distance_to_collision_guess <- GreatCircleDistanceFromLongLat(collision_point_guess$long, collision_point_guess$lat, start_positions[j, 1], start_positions[j, 2])#
				EndPoint(start_positions[i, 1], start_positions[i, 2], bearing, distance_to_collision_guess)[c("long", "lat")]#
				collision_point_guess#
#start_position_angle_bearing_1 <- BearingBetweenTwoLongLatPoints(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#start_position_angle_bearing_2 <- BearingBetweenTwoLongLatPoints(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat)#
				# If response to hitting a continent edge is to bounce off it:#
				if(response == "bounce") {#
				}#
				# If response to hitting a continent edge is to stick to it:#
				if(response == "stop") {#
				}#
			}#
		# If draw means staying on continent:#
		} else {#
			# Overwrite start positions:#
			start_positions[j, ] <- unlist(new_position)#
			# Record distance from centre of continent:#
			end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
		}#
	}#
}#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="blue", cex=0.5)#
#
quartz()#
hist(start_distances)#
quartz()#
hist(end_distances)
GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)
# Scalar which describes the proportion of the disatcne the organism has to travel before colliding with the continent edge:#
				distance_modifier <- 0.5#
				# Starting stepsize (will shrink as answer is honed in on more precisely):#
				stepsize <- 0.1#
				new_position <- EndPoint(start_positions[i, 1], start_positions[i, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
				while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
				}
as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))
distance
current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
					# Do we need to increase the degree modifier value?:#
					if(current_distance_from_centre > continent_radius) {#
						# Create potential better value by adding step size to modifier:#
						limit <- degree_modifier + stepsize#
					# Or do we need to decrease the degree modifier value?:#
					} else {#
						# Create potential better value by subtracting step size to modifier:#
						limit <- degree_modifier - stepsize#
					}
current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
					# Do we need to increase the degree modifier value?:#
					if(current_distance_from_centre > continent_radius) {#
						# Create potential better value by adding step size to modifier:#
						limit <- distance_modifier + stepsize#
					# Or do we need to decrease the degree modifier value?:#
					} else {#
						# Create potential better value by subtracting step size to modifier:#
						limit <- distance_modifier - stepsize#
					}
limit
current_distance_from_centre
current_distance_from_centre > continent_radius
# Do we need to increase the degree modifier value?:#
					if(current_distance_from_centre < continent_radius) {#
						# Create potential better value by adding step size to modifier:#
						limit <- distance_modifier + stepsize#
					# Or do we need to decrease the degree modifier value?:#
					} else {#
						# Create potential better value by subtracting step size to modifier:#
						limit <- distance_modifier - stepsize#
					}
limit
current_distance_from_centre < continent_radius
# Scalar which describes the proportion of the disatcne the organism has to travel before colliding with the continent edge:#
				distance_modifier <- 0.5#
				# Starting stepsize (will shrink as answer is honed in on more precisely):#
				stepsize <- 0.1#
				new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]
new_position
all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE
as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))
new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]
new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, 1 * distance)[c("long", "lat")]
as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))
new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]
current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))
current_distance_from_centre
# Scalar which describes the proportion of the disatcne the organism has to travel before colliding with the continent edge:#
				distance_modifier <- 0.5#
				# Starting stepsize (will shrink as answer is honed in on more precisely):#
				stepsize <- 0.1
# Do we need to increase the distance modifier value?:#
					if(current_distance_from_centre < continent_radius) {#
						# Create potential better value by adding step size to modifier:#
						limit <- distance_modifier + stepsize#
					# Or do we need to decrease the degree modifier value?:#
					} else {#
						# Create potential better value by subtracting step size from modifier:#
						limit <- distance_modifier - stepsize#
					}
limit
new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]
current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
					# Do we need to increase the distance modifier value?:#
					if(current_distance_from_centre < continent_radius) {#
						# Create potential better value by adding step size to modifier:#
						limit <- distance_modifier + stepsize#
					# Or do we need to decrease the degree modifier value?:#
					} else {#
						# Create potential better value by subtracting step size from modifier:#
						limit <- distance_modifier - stepsize#
					}#
					new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
					# Get new distance based on potential better modifer:#
					new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))
new_distance_from_centre
abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)
# Scalar which describes the proportion of the disatcne the organism has to travel before colliding with the continent edge:#
				distance_modifier <- 0.5#
				# Starting stepsize (will shrink as answer is honed in on more precisely):#
				stepsize <- 0.1#
				new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
				while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
					current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
					# Do we need to increase the distance modifier value?:#
					if(current_distance_from_centre < continent_radius) {#
						# Create potential better value by adding step size to modifier:#
						limit <- distance_modifier + stepsize#
					# Or do we need to decrease the degree modifier value?:#
					} else {#
						# Create potential better value by subtracting step size from modifier:#
						limit <- distance_modifier - stepsize#
					}#
					new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
					# Get new distance from continent centre based on potential better modifer:#
					new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
					# If new distance is closer to continent radius:#
					if(abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)) {#
						# Update new position:#
						new_position <- new_new_position#
						# Update distance modifier itself:#
						distance_modifier <- limit#
					# If current distance is stil our best estimate:#
					} else {#
						# Shrink the step size so we can hone in closer:#
						stepsize <- stepsize * 0.1#
					}#
				}
distance_modifier
new_position
as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))
dev.off()
dev.off()
dev.off()
dev.off()
quartz()
library(maps)#
#
EarthRad <- 6367.4447#
#
niter <- 100#
#
n_aminals <- 100#
#
stepsize_sd <- 100#
#
continent_centre <- c(0, 0)#
#
continent_radius <- 2000#
#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
end_distances <- start_distances <- vector(mode="numeric")#
#
#response <- "bounce"#
#response <- "redraw"#
response <- "stop"#
#
for(i in 1:n_aminals) {#
#
	bearing <- runif(1, 0, 360)#
#
	distance <- runif(1, 0, continent_radius)#
	start_positions <- rbind(start_positions, unlist(EndPoint(continent_centre[1], continent_centre[1], bearing, distance)[c("long", "lat")]))#
	# Record distance from centre of continent:#
	start_distances[i] <- distance#
}#
#
map(xlim=c(-radius / ((2 * pi * EarthRad) / 360), radius / ((2 * pi * EarthRad) / 360)), ylim=c(-radius / ((2 * pi * EarthRad) / 360), radius / ((2 * pi * EarthRad) / 360)))#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="red", cex=0.5)#
#
# For each time step:#
for(i in 1:niter) {#
	# For each organism:#
	for(j in 1:n_aminals) {#
		# Draw a random bearing for the next move:#
		bearing <- runif(1, 0, 360)#
		# Draw a random distance for the next move:#
		distance <- abs(rnorm(1, 0, stepsize_sd))#
		# Calculate the new position of the organism following the move:#
		new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
		# If draw means leaving continent:#
		if(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
			stop("")#
			# If response to leaving continent is to redraw:#
			if(response == "redraw") {#
				# As long as the draw removes the taxon from the continent:#
				while(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
					# Redraw the bearing:#
					bearing <- runif(1, 0, 360)#
					# Redraw the distance:#
					distance <- abs(rnorm(1, 0, stepsize_sd))#
					# Calculate the new position:#
					new_position <- EndPoint(start_positions[i, 1], start_positions[i, 2], bearing, distance)[c("long", "lat")]#
				}#
				# Overwrite start positions:#
				start_positions[j, ] <- unlist(new_position)#
				# Record distance from centre of continent:#
				end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
			# If response to leaving continent is not to redraw (i.e., is to bounce off of, or stop at, continent edge):#
			} else {#
# FIND COLLISION POINT STARTS HERE:#
				# Scalar which describes the proportion of the disatcne the organism has to travel before colliding with the continent edge:#
				distance_modifier <- 0.5#
				# Starting stepsize (will shrink as answer is honed in on more precisely):#
				stepsize <- 0.1#
				new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
				while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
					current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
					# Do we need to increase the distance modifier value?:#
					if(current_distance_from_centre < continent_radius) {#
						# Create potential better value by adding step size to modifier:#
						limit <- distance_modifier + stepsize#
					# Or do we need to decrease the degree modifier value?:#
					} else {#
						# Create potential better value by subtracting step size from modifier:#
						limit <- distance_modifier - stepsize#
					}#
					new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
					# Get new distance from continent centre based on potential better modifer:#
					new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
					# If new distance is closer to continent radius:#
					if(abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)) {#
						# Update new position:#
						new_position <- new_new_position#
						# Update distance modifier itself:#
						distance_modifier <- limit#
					# If current distance is stil our best estimate:#
					} else {#
						# Shrink the step size so we can hone in closer:#
						stepsize <- stepsize * 0.1#
					}#
				}#
# FIND COLLISION POINT ENDS HERE:#
				# If response to hitting a continent edge is to bounce off it:#
				if(response == "bounce") {#
# Still need to fill in this part#
				}#
				# If response to hitting a continent edge is to stick to it:#
				if(response == "stop") {#
					# Overwrite start positions:#
					start_positions[j, ] <- unlist(new_position)#
					# Record distance from centre of continent:#
					end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
				}#
			}#
		# If draw means staying on continent:#
		} else {#
			# Overwrite start positions:#
			start_positions[j, ] <- unlist(new_position)#
			# Record distance from centre of continent:#
			end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
		}#
	}#
}#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="blue", cex=0.5)#
#
quartz()#
hist(start_distances)#
quartz()#
hist(end_distances)
quartz()library(maps)#
#
EarthRad <- 6367.4447#
#
niter <- 100#
#
n_aminals <- 100#
#
stepsize_sd <- 100#
#
continent_centre <- c(0, 0)#
#
continent_radius <- 2000#
#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
end_distances <- start_distances <- vector(mode="numeric")#
#
#response <- "bounce"#
#response <- "redraw"#
response <- "stop"#
#
for(i in 1:n_aminals) {#
#
	bearing <- runif(1, 0, 360)#
#
	distance <- runif(1, 0, continent_radius)#
	start_positions <- rbind(start_positions, unlist(EndPoint(continent_centre[1], continent_centre[1], bearing, distance)[c("long", "lat")]))#
	# Record distance from centre of continent:#
	start_distances[i] <- distance#
}#
#
map(xlim=c(-radius / ((2 * pi * EarthRad) / 360), radius / ((2 * pi * EarthRad) / 360)), ylim=c(-radius / ((2 * pi * EarthRad) / 360), radius / ((2 * pi * EarthRad) / 360)))#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="red", cex=0.5)#
#
# For each time step:#
for(i in 1:niter) {#
	# For each organism:#
	for(j in 1:n_aminals) {#
		# Draw a random bearing for the next move:#
		bearing <- runif(1, 0, 360)#
		# Draw a random distance for the next move:#
		distance <- abs(rnorm(1, 0, stepsize_sd))#
		# Calculate the new position of the organism following the move:#
		new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
		# If draw means leaving continent:#
		if(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
			# If response to leaving continent is to redraw:#
			if(response == "redraw") {#
				# As long as the draw removes the taxon from the continent:#
				while(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
					# Redraw the bearing:#
					bearing <- runif(1, 0, 360)#
					# Redraw the distance:#
					distance <- abs(rnorm(1, 0, stepsize_sd))#
					# Calculate the new position:#
					new_position <- EndPoint(start_positions[i, 1], start_positions[i, 2], bearing, distance)[c("long", "lat")]#
				}#
				# Overwrite start positions:#
				start_positions[j, ] <- unlist(new_position)#
				# Record distance from centre of continent:#
				end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
			# If response to leaving continent is not to redraw (i.e., is to bounce off of, or stop at, continent edge):#
			} else {#
# FIND COLLISION POINT STARTS HERE:#
				# Scalar which describes the proportion of the disatcne the organism has to travel before colliding with the continent edge:#
				distance_modifier <- 0.5#
				# Starting stepsize (will shrink as answer is honed in on more precisely):#
				stepsize <- 0.1#
				new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
				while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
					current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
					# Do we need to increase the distance modifier value?:#
					if(current_distance_from_centre < continent_radius) {#
						# Create potential better value by adding step size to modifier:#
						limit <- distance_modifier + stepsize#
					# Or do we need to decrease the degree modifier value?:#
					} else {#
						# Create potential better value by subtracting step size from modifier:#
						limit <- distance_modifier - stepsize#
					}#
					new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
					# Get new distance from continent centre based on potential better modifer:#
					new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
					# If new distance is closer to continent radius:#
					if(abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)) {#
						# Update new position:#
						new_position <- new_new_position#
						# Update distance modifier itself:#
						distance_modifier <- limit#
					# If current distance is stil our best estimate:#
					} else {#
						# Shrink the step size so we can hone in closer:#
						stepsize <- stepsize * 0.1#
					}#
				}#
# FIND COLLISION POINT ENDS HERE:#
				# If response to hitting a continent edge is to bounce off it:#
				if(response == "bounce") {#
# Still need to fill in this part#
				}#
				# If response to hitting a continent edge is to stick to it:#
				if(response == "stop") {#
					# Overwrite start positions:#
					start_positions[j, ] <- unlist(new_position)#
					# Record distance from centre of continent:#
					end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
				}#
			}#
		# If draw means staying on continent:#
		} else {#
			# Overwrite start positions:#
			start_positions[j, ] <- unlist(new_position)#
			# Record distance from centre of continent:#
			end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
		}#
	}#
}#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="blue", cex=0.5)#
#
quartz()#
hist(start_distances)#
quartz()#
hist(end_distances)
library(maps)#
#
EarthRad <- 6367.4447#
#
niter <- 100#
#
n_aminals <- 100#
#
stepsize_sd <- 100#
#
continent_centre <- c(0, 0)#
#
continent_radius <- 2000#
#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
end_distances <- start_distances <- vector(mode="numeric")#
#
#response <- "bounce"#
#response <- "redraw"#
response <- "stop"#
#
for(i in 1:n_aminals) {#
#
	bearing <- runif(1, 0, 360)#
#
	distance <- runif(1, 0, continent_radius)#
	start_positions <- rbind(start_positions, unlist(EndPoint(continent_centre[1], continent_centre[1], bearing, distance)[c("long", "lat")]))#
	# Record distance from centre of continent:#
	start_distances[i] <- distance#
}#
#
map(xlim=c(-radius / ((2 * pi * EarthRad) / 360), radius / ((2 * pi * EarthRad) / 360)), ylim=c(-radius / ((2 * pi * EarthRad) / 360), radius / ((2 * pi * EarthRad) / 360)))#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="red", cex=0.5)
library(maps)#
#
EarthRad <- 6367.4447#
#
niter <- 100#
#
n_aminals <- 100#
#
stepsize_sd <- 100#
#
continent_centre <- c(0, 0)#
#
continent_radius <- 2000#
#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
end_distances <- start_distances <- vector(mode="numeric")#
#
#response <- "bounce"#
#response <- "redraw"#
response <- "stop"#
#
for(i in 1:n_aminals) {#
#
	bearing <- runif(1, 0, 360)#
#
	distance <- runif(1, 0, continent_radius)#
	start_positions <- rbind(start_positions, unlist(EndPoint(continent_centre[1], continent_centre[1], bearing, distance)[c("long", "lat")]))#
	# Record distance from centre of continent:#
	start_distances[i] <- distance#
}#
#
map(xlim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), ylim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="red", cex=0.5)
library(maps)#
#
EarthRad <- 6367.4447#
#
niter <- 100#
#
n_aminals <- 100#
#
stepsize_sd <- 100#
#
continent_centre <- c(0, 0)#
#
continent_radius <- 2000#
#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
end_distances <- start_distances <- vector(mode="numeric")#
#
#response <- "bounce"#
#response <- "redraw"#
response <- "stop"#
#
for(i in 1:n_aminals) {#
#
	bearing <- runif(1, 0, 360)#
#
	distance <- runif(1, 0, continent_radius)#
	start_positions <- rbind(start_positions, unlist(EndPoint(continent_centre[1], continent_centre[1], bearing, distance)[c("long", "lat")]))#
	# Record distance from centre of continent:#
	start_distances[i] <- distance#
}#
#
map(xlim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), ylim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="red", cex=0.5)#
#
# For each time step:#
for(i in 1:niter) {#
	# For each organism:#
	for(j in 1:n_aminals) {#
		# Draw a random bearing for the next move:#
		bearing <- runif(1, 0, 360)#
		# Draw a random distance for the next move:#
		distance <- abs(rnorm(1, 0, stepsize_sd))#
		# Calculate the new position of the organism following the move:#
		new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
		# If draw means leaving continent:#
		if(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
			# If response to leaving continent is to redraw:#
			if(response == "redraw") {#
				# As long as the draw removes the taxon from the continent:#
				while(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
					# Redraw the bearing:#
					bearing <- runif(1, 0, 360)#
					# Redraw the distance:#
					distance <- abs(rnorm(1, 0, stepsize_sd))#
					# Calculate the new position:#
					new_position <- EndPoint(start_positions[i, 1], start_positions[i, 2], bearing, distance)[c("long", "lat")]#
				}#
				# Overwrite start positions:#
				start_positions[j, ] <- unlist(new_position)#
				# Record distance from centre of continent:#
				end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
			# If response to leaving continent is not to redraw (i.e., is to bounce off of, or stop at, continent edge):#
			} else {#
# FIND COLLISION POINT STARTS HERE:#
				# Scalar which describes the proportion of the disatcne the organism has to travel before colliding with the continent edge:#
				distance_modifier <- 0.5#
				# Starting stepsize (will shrink as answer is honed in on more precisely):#
				stepsize <- 0.1#
				new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
				while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
					current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
					# Do we need to increase the distance modifier value?:#
					if(current_distance_from_centre < continent_radius) {#
						# Create potential better value by adding step size to modifier:#
						limit <- distance_modifier + stepsize#
					# Or do we need to decrease the degree modifier value?:#
					} else {#
						# Create potential better value by subtracting step size from modifier:#
						limit <- distance_modifier - stepsize#
					}#
					new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
					# Get new distance from continent centre based on potential better modifer:#
					new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
					# If new distance is closer to continent radius:#
					if(abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)) {#
						# Update new position:#
						new_position <- new_new_position#
						# Update distance modifier itself:#
						distance_modifier <- limit#
					# If current distance is stil our best estimate:#
					} else {#
						# Shrink the step size so we can hone in closer:#
						stepsize <- stepsize * 0.1#
					}#
				}#
# FIND COLLISION POINT ENDS HERE:#
				# If response to hitting a continent edge is to bounce off it:#
				if(response == "bounce") {#
# Still need to fill in this part#
				}#
				# If response to hitting a continent edge is to stick to it:#
				if(response == "stop") {#
					# Overwrite start positions:#
					start_positions[j, ] <- unlist(new_position)#
					# Record distance from centre of continent:#
					end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
				}#
			}#
		# If draw means staying on continent:#
		} else {#
			# Overwrite start positions:#
			start_positions[j, ] <- unlist(new_position)#
			# Record distance from centre of continent:#
			end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
		}#
	}#
}#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="blue", cex=0.5)#
#
quartz()#
hist(start_distances)#
quartz()#
hist(end_distances)
library(maps)#
#
EarthRad <- 6367.4447#
#
niter <- 100#
#
n_aminals <- 10000#
#
stepsize_sd <- 100#
#
continent_centre <- c(0, 0)#
#
continent_radius <- 2000#
#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
end_distances <- start_distances <- vector(mode="numeric")#
#
#response <- "bounce"#
#response <- "redraw"#
response <- "stop"#
#
for(i in 1:n_aminals) {#
#
	bearing <- runif(1, 0, 360)#
#
	distance <- runif(1, 0, continent_radius)#
	start_positions <- rbind(start_positions, unlist(EndPoint(continent_centre[1], continent_centre[1], bearing, distance)[c("long", "lat")]))#
	# Record distance from centre of continent:#
	start_distances[i] <- distance#
}#
#
map(xlim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), ylim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="red", cex=0.5)#
#
# For each time step:#
for(i in 1:niter) {#
	# For each organism:#
	for(j in 1:n_aminals) {#
		# Draw a random bearing for the next move:#
		bearing <- runif(1, 0, 360)#
		# Draw a random distance for the next move:#
		distance <- abs(rnorm(1, 0, stepsize_sd))#
		# Calculate the new position of the organism following the move:#
		new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
		# If draw means leaving continent:#
		if(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
			# If response to leaving continent is to redraw:#
			if(response == "redraw") {#
				# As long as the draw removes the taxon from the continent:#
				while(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
					# Redraw the bearing:#
					bearing <- runif(1, 0, 360)#
					# Redraw the distance:#
					distance <- abs(rnorm(1, 0, stepsize_sd))#
					# Calculate the new position:#
					new_position <- EndPoint(start_positions[i, 1], start_positions[i, 2], bearing, distance)[c("long", "lat")]#
				}#
				# Overwrite start positions:#
				start_positions[j, ] <- unlist(new_position)#
				# Record distance from centre of continent:#
				end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
			# If response to leaving continent is not to redraw (i.e., is to bounce off of, or stop at, continent edge):#
			} else {#
# FIND COLLISION POINT STARTS HERE:#
				# Scalar which describes the proportion of the disatcne the organism has to travel before colliding with the continent edge:#
				distance_modifier <- 0.5#
				# Starting stepsize (will shrink as answer is honed in on more precisely):#
				stepsize <- 0.1#
				new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
				while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
					current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
					# Do we need to increase the distance modifier value?:#
					if(current_distance_from_centre < continent_radius) {#
						# Create potential better value by adding step size to modifier:#
						limit <- distance_modifier + stepsize#
					# Or do we need to decrease the degree modifier value?:#
					} else {#
						# Create potential better value by subtracting step size from modifier:#
						limit <- distance_modifier - stepsize#
					}#
					new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
					# Get new distance from continent centre based on potential better modifer:#
					new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
					# If new distance is closer to continent radius:#
					if(abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)) {#
						# Update new position:#
						new_position <- new_new_position#
						# Update distance modifier itself:#
						distance_modifier <- limit#
					# If current distance is stil our best estimate:#
					} else {#
						# Shrink the step size so we can hone in closer:#
						stepsize <- stepsize * 0.1#
					}#
				}#
# FIND COLLISION POINT ENDS HERE:#
				# If response to hitting a continent edge is to bounce off it:#
				if(response == "bounce") {#
# Still need to fill in this part#
				}#
				# If response to hitting a continent edge is to stick to it:#
				if(response == "stop") {#
					# Overwrite start positions:#
					start_positions[j, ] <- unlist(new_position)#
					# Record distance from centre of continent:#
					end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
				}#
			}#
		# If draw means staying on continent:#
		} else {#
			# Overwrite start positions:#
			start_positions[j, ] <- unlist(new_position)#
			# Record distance from centre of continent:#
			end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
		}#
	}#
}#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="blue", cex=0.5)#
#
quartz()#
hist(start_distances)#
quartz()#
hist(end_distances)
end_distances
max(end_distances)
end_distances[9735]
all.equal(end_distances[9735], 2000)
all.equal(max(end_distances), 2000)
new_position
new_position$long, new_position
library(maps)#
#
EarthRad <- 6367.4447#
#
niter <- 100#
#
n_aminals <- 100#
#
stepsize_sd <- 100#
#
continent_centre <- c(0, 0)#
#
continent_radius <- 2000#
#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
end_distances <- start_distances <- vector(mode="numeric")#
#
response <- "bounce"#
#response <- "redraw"#
#response <- "stop"#
#
for(i in 1:n_aminals) {#
#
	bearing <- runif(1, 0, 360)#
#
	distance <- runif(1, 0, continent_radius)#
	start_positions <- rbind(start_positions, unlist(EndPoint(continent_centre[1], continent_centre[1], bearing, distance)[c("long", "lat")]))#
	# Record distance from centre of continent:#
	start_distances[i] <- distance#
}#
#
map(xlim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), ylim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="red", cex=0.5)#
#
# For each time step:#
for(i in 1:niter) {#
	# For each organism:#
	for(j in 1:n_aminals) {#
		# Draw a random bearing for the next move:#
		bearing <- runif(1, 0, 360)#
		# Draw a random distance for the next move:#
		distance <- abs(rnorm(1, 0, stepsize_sd))#
		# Calculate the new position of the organism following the move:#
		new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
		# If draw means leaving continent:#
		if(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
			# If response to leaving continent is to redraw:#
			if(response == "redraw") {#
				# As long as the draw removes the taxon from the continent:#
				while(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
					# Redraw the bearing:#
					bearing <- runif(1, 0, 360)#
					# Redraw the distance:#
					distance <- abs(rnorm(1, 0, stepsize_sd))#
					# Calculate the new position:#
					new_position <- EndPoint(start_positions[i, 1], start_positions[i, 2], bearing, distance)[c("long", "lat")]#
				}#
				# Overwrite start positions:#
				start_positions[j, ] <- unlist(new_position)#
				# Record distance from centre of continent:#
				end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
			# If response to leaving continent is not to redraw (i.e., is to bounce off of, or stop at, continent edge):#
			} else {#
# FIND COLLISION POINT STARTS HERE:#
				# Scalar which describes the proportion of the disatcne the organism has to travel before colliding with the continent edge:#
				distance_modifier <- 0.5#
				# Starting stepsize (will shrink as answer is honed in on more precisely):#
				stepsize <- 0.1#
				new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
				while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
					current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
					# Do we need to increase the distance modifier value?:#
					if(current_distance_from_centre < continent_radius) {#
						# Create potential better value by adding step size to modifier:#
						limit <- distance_modifier + stepsize#
					# Or do we need to decrease the degree modifier value?:#
					} else {#
						# Create potential better value by subtracting step size from modifier:#
						limit <- distance_modifier - stepsize#
					}#
					new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
					# Get new distance from continent centre based on potential better modifer:#
					new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
					# If new distance is closer to continent radius:#
					if(abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)) {#
						# Update new position:#
						new_position <- new_new_position#
						# Update distance modifier itself:#
						distance_modifier <- limit#
					# If current distance is stil our best estimate:#
					} else {#
						# Shrink the step size so we can hone in closer:#
						stepsize <- stepsize * 0.1#
					}#
				}#
# FIND COLLISION POINT ENDS HERE:#
				# If response to hitting a continent edge is to bounce off it:#
				if(response == "bounce") {#
					stop("")#
# Still need to fill in this part#
				}#
				# If response to hitting a continent edge is to stick to it:#
				if(response == "stop") {#
					# Overwrite start positions:#
					start_positions[j, ] <- unlist(new_position)#
					# Record distance from centre of continent:#
					end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
				}#
			}#
		# If draw means staying on continent:#
		} else {#
			# Overwrite start positions:#
			start_positions[j, ] <- unlist(new_position)#
			# Record distance from centre of continent:#
			end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
		}#
	}#
}
warn()
warning()
warning("Some text")
print("Some text")
new_position$long
GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat)
distance
remaining_distance <- distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat)
remaining_distance
library(maps)#
#
EarthRad <- 6367.4447#
#
niter <- 100#
#
n_aminals <- 10000#
#
stepsize_sd <- 100#
#
continent_centre <- c(0, 0)#
#
continent_radius <- 2000#
#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
end_distances <- start_distances <- vector(mode="numeric")#
#
#response <- "bounce"#
response <- "redraw"#
#response <- "stop"#
#
for(i in 1:n_aminals) {#
#
	bearing <- runif(1, 0, 360)#
#
	distance <- runif(1, 0, continent_radius)#
	start_positions <- rbind(start_positions, unlist(EndPoint(continent_centre[1], continent_centre[1], bearing, distance)[c("long", "lat")]))#
	# Record distance from centre of continent:#
	start_distances[i] <- distance#
}#
#
map(xlim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), ylim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="red", cex=0.5)#
#
# For each time step:#
for(i in 1:niter) {#
	# For each organism:#
	for(j in 1:n_aminals) {#
		# Draw a random bearing for the next move:#
		bearing <- runif(1, 0, 360)#
		# Draw a random distance for the next move:#
		distance <- abs(rnorm(1, 0, stepsize_sd))#
		# Calculate the new position of the organism following the move:#
		new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
		# If draw means leaving continent:#
		if(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
			# If response to leaving continent is to redraw:#
			if(response == "redraw") {#
				# As long as the draw removes the taxon from the continent:#
				while(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
					# Redraw the bearing:#
					bearing <- runif(1, 0, 360)#
					# Redraw the distance:#
					distance <- abs(rnorm(1, 0, stepsize_sd))#
					# Calculate the new position:#
					new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
				}#
				# Overwrite start positions:#
				start_positions[j, ] <- unlist(new_position)#
				# Record distance from centre of continent:#
				end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
			# If response to leaving continent is not to redraw (i.e., is to bounce off of, or stop at, continent edge):#
			} else {#
# FIND COLLISION POINT STARTS HERE:#
				# Scalar which describes the proportion of the disatcne the organism has to travel before colliding with the continent edge:#
				distance_modifier <- 0.5#
				# Starting stepsize (will shrink as answer is honed in on more precisely):#
				stepsize <- 0.1#
				new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
				while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
					current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
					# Do we need to increase the distance modifier value?:#
					if(current_distance_from_centre < continent_radius) {#
						# Create potential better value by adding step size to modifier:#
						limit <- distance_modifier + stepsize#
					# Or do we need to decrease the degree modifier value?:#
					} else {#
						# Create potential better value by subtracting step size from modifier:#
						limit <- distance_modifier - stepsize#
					}#
					new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
					# Get new distance from continent centre based on potential better modifer:#
					new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
					# If new distance is closer to continent radius:#
					if(abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)) {#
						# Update new position:#
						new_position <- new_new_position#
						# Update distance modifier itself:#
						distance_modifier <- limit#
					# If current distance is stil our best estimate:#
					} else {#
						# Shrink the step size so we can hone in closer:#
						stepsize <- stepsize * 0.1#
					}#
				}#
# FIND COLLISION POINT ENDS HERE:#
				# If response to hitting a continent edge is to bounce off it:#
				if(response == "bounce") {#
					remaining_distance <- distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat)#
				}#
				# If response to hitting a continent edge is to stick to it:#
				if(response == "stop") {#
					# Overwrite start positions:#
					start_positions[j, ] <- unlist(new_position)#
					# Record distance from centre of continent:#
					end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
				}#
			}#
		# If draw means staying on continent:#
		} else {#
			# Overwrite start positions:#
			start_positions[j, ] <- unlist(new_position)#
			# Record distance from centre of continent:#
			end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
		}#
	}#
}#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="blue", cex=0.5)#
#
quartz()#
hist(start_distances)#
quartz()#
hist(end_distances)
map(xlim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), ylim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="red", cex=0.5)
points(start_positions[, 1], start_positions[, 2], pch=19, col="blue", cex=0.5)
library(maps)#
#
EarthRad <- 6367.4447#
#
niter <- 100#
#
n_aminals <- 100#
#
stepsize_sd <- 100#
#
continent_centre <- c(0, 0)#
#
continent_radius <- 2000#
#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
end_distances <- start_distances <- vector(mode="numeric")#
#
response <- "bounce"#
#response <- "redraw"#
#response <- "stop"#
#
for(i in 1:n_aminals) {#
#
	bearing <- runif(1, 0, 360)#
#
	distance <- runif(1, 0, continent_radius)#
	start_positions <- rbind(start_positions, unlist(EndPoint(continent_centre[1], continent_centre[1], bearing, distance)[c("long", "lat")]))#
	# Record distance from centre of continent:#
	start_distances[i] <- distance#
}#
#
map(xlim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), ylim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="red", cex=0.5)#
#
# For each time step:#
for(i in 1:niter) {#
	# For each organism:#
	for(j in 1:n_aminals) {#
		# Draw a random bearing for the next move:#
		bearing <- runif(1, 0, 360)#
		# Draw a random distance for the next move:#
		distance <- abs(rnorm(1, 0, stepsize_sd))#
		# Calculate the new position of the organism following the move:#
		new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
		# If draw means leaving continent:#
		if(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
			# If response to leaving continent is to redraw:#
			if(response == "redraw") {#
				# As long as the draw removes the taxon from the continent:#
				while(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
					# Redraw the bearing:#
					bearing <- runif(1, 0, 360)#
					# Redraw the distance:#
					distance <- abs(rnorm(1, 0, stepsize_sd))#
					# Calculate the new position:#
					new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
				}#
				# Overwrite start positions:#
				start_positions[j, ] <- unlist(new_position)#
				# Record distance from centre of continent:#
				end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
			# If response to leaving continent is not to redraw (i.e., is to bounce off of, or stop at, continent edge):#
			} else {#
# FIND COLLISION POINT STARTS HERE:#
				# Scalar which describes the proportion of the disatcne the organism has to travel before colliding with the continent edge:#
				distance_modifier <- 0.5#
				# Starting stepsize (will shrink as answer is honed in on more precisely):#
				stepsize <- 0.1#
				new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
				while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
					current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
					# Do we need to increase the distance modifier value?:#
					if(current_distance_from_centre < continent_radius) {#
						# Create potential better value by adding step size to modifier:#
						limit <- distance_modifier + stepsize#
					# Or do we need to decrease the degree modifier value?:#
					} else {#
						# Create potential better value by subtracting step size from modifier:#
						limit <- distance_modifier - stepsize#
					}#
					new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
					# Get new distance from continent centre based on potential better modifer:#
					new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
					# If new distance is closer to continent radius:#
					if(abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)) {#
						# Update new position:#
						new_position <- new_new_position#
						# Update distance modifier itself:#
						distance_modifier <- limit#
					# If current distance is stil our best estimate:#
					} else {#
						# Shrink the step size so we can hone in closer:#
						stepsize <- stepsize * 0.1#
					}#
				}#
# FIND COLLISION POINT ENDS HERE:#
				# If response to hitting a continent edge is to bounce off it:#
				if(response == "bounce") {#
					stop("")#
					remaining_distance <- distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat)#
				}#
				# If response to hitting a continent edge is to stick to it:#
				if(response == "stop") {#
					# Overwrite start positions:#
					start_positions[j, ] <- unlist(new_position)#
					# Record distance from centre of continent:#
					end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
				}#
			}#
		# If draw means staying on continent:#
		} else {#
			# Overwrite start positions:#
			start_positions[j, ] <- unlist(new_position)#
			# Record distance from centre of continent:#
			end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
		}#
	}#
}
remaining_distance <- distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat)
remaining_distance
remaining_distance <- as.vector(distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat))
remaining_distance
remaining_distance
BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, continent_centre[1], continent_centre[2])
as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]))
remaining_distance <- as.vector(distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat))#
					bearing_to_centre <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]))#
					bearing_to_start <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, start_positions[j, 1], start_positions[j, 2]))
bearing_to_start
bearing_to_centre
bearing_to_start - bearing_to_centre
abs(bearing_to_start - bearing_to_centre)
min(c(abs(bearing_to_start - bearing_to_centre), 360 - abs(bearing_to_start - bearing_to_centre)))
(bearing_to_centre + bearing_difference) %% 360
remaining_distance <- as.vector(distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat))#
					bearing_to_centre <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]))#
					bearing_to_start <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, start_positions[j, 1], start_positions[j, 2]))#
					bearing_difference <- min(c(abs(bearing_to_start - bearing_to_centre), 360 - abs(bearing_to_start - bearing_to_centre)))
(bearing_to_centre + bearing_difference) %% 360
all.equal((bearing_to_centre + bearing_difference) %% 360, bearing_to_start)
all.equal((bearing_to_centre - bearing_difference) %% 360, bearing_to_start)
all.equal((bearing_to_centre + bearing_difference) %% 360, bearing_to_start) == TRUE
remaining_distance <- as.vector(distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat))#
					bearing_to_centre <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]))#
					bearing_to_start <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, start_positions[j, 1], start_positions[j, 2]))#
					bearing_difference <- min(c(abs(bearing_to_start - bearing_to_centre), 360 - abs(bearing_to_start - bearing_to_centre)))#
					if(all.equal((bearing_to_centre + bearing_difference) %% 360, bearing_to_start) == TRUE) {#
						bearing_to_end <- (bearing_to_centre + bearing_difference) %% 360#
					} else {#
						bearing_to_end <- (bearing_to_centre - bearing_difference) %% 360#
					}#
					bearing_to_end
bearing_to_centre
bearing_to_start
remaining_distance <- as.vector(distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat))#
					bearing_to_centre <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]))#
					bearing_to_start <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, start_positions[j, 1], start_positions[j, 2]))#
					bearing_difference <- min(c(abs(bearing_to_start - bearing_to_centre), 360 - abs(bearing_to_start - bearing_to_centre)))#
					if(all.equal((bearing_to_centre + bearing_difference) %% 360, bearing_to_start) == TRUE) {#
						bearing_to_end <- (bearing_to_centre - bearing_difference) %% 360#
					} else {#
						bearing_to_end <- (bearing_to_centre + bearing_difference) %% 360#
					}#
					bearing_to_end
EndPoint(new_position$long, new_position$lat, bearing_to_end, remaining_distance)
EndPoint(new_position$long, new_position$lat, bearing_to_end, remaining_distance)[c("long", "lat")]
library(maps)#
#
EarthRad <- 6367.4447#
#
niter <- 100#
#
n_aminals <- 100#
#
stepsize_sd <- 100#
#
continent_centre <- c(0, 0)#
#
continent_radius <- 2000#
#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
end_distances <- start_distances <- vector(mode="numeric")#
#
response <- "bounce"#
#response <- "redraw"#
#response <- "stop"#
#
for(i in 1:n_aminals) {#
#
	bearing <- runif(1, 0, 360)#
#
	distance <- runif(1, 0, continent_radius)#
	start_positions <- rbind(start_positions, unlist(EndPoint(continent_centre[1], continent_centre[1], bearing, distance)[c("long", "lat")]))#
	# Record distance from centre of continent:#
	start_distances[i] <- distance#
}#
#
map(xlim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), ylim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="red", cex=0.5)#
#
# For each time step:#
for(i in 1:niter) {#
	# For each organism:#
	for(j in 1:n_aminals) {#
		# Draw a random bearing for the next move:#
		bearing <- runif(1, 0, 360)#
		# Draw a random distance for the next move:#
		distance <- abs(rnorm(1, 0, stepsize_sd))#
		# Calculate the new position of the organism following the move:#
		new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
		# If draw means leaving continent:#
		if(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
			# If response to leaving continent is to redraw:#
			if(response == "redraw") {#
				# As long as the draw removes the taxon from the continent:#
				while(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
					# Redraw the bearing:#
					bearing <- runif(1, 0, 360)#
					# Redraw the distance:#
					distance <- abs(rnorm(1, 0, stepsize_sd))#
					# Calculate the new position:#
					new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
				}#
				# Overwrite start positions:#
				start_positions[j, ] <- unlist(new_position)#
				# Record distance from centre of continent:#
				end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
			# If response to leaving continent is not to redraw (i.e., is to bounce off of, or stop at, continent edge):#
			} else {#
# FIND COLLISION POINT STARTS HERE:#
				# Scalar which describes the proportion of the disatcne the organism has to travel before colliding with the continent edge:#
				distance_modifier <- 0.5#
				# Starting stepsize (will shrink as answer is honed in on more precisely):#
				stepsize <- 0.1#
				new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
				while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
					current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
					# Do we need to increase the distance modifier value?:#
					if(current_distance_from_centre < continent_radius) {#
						# Create potential better value by adding step size to modifier:#
						limit <- distance_modifier + stepsize#
					# Or do we need to decrease the degree modifier value?:#
					} else {#
						# Create potential better value by subtracting step size from modifier:#
						limit <- distance_modifier - stepsize#
					}#
					new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
					# Get new distance from continent centre based on potential better modifer:#
					new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
					# If new distance is closer to continent radius:#
					if(abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)) {#
						# Update new position:#
						new_position <- new_new_position#
						# Update distance modifier itself:#
						distance_modifier <- limit#
					# If current distance is stil our best estimate:#
					} else {#
						# Shrink the step size so we can hone in closer:#
						stepsize <- stepsize * 0.1#
					}#
				}#
# FIND COLLISION POINT ENDS HERE:#
				# If response to hitting a continent edge is to bounce off it:#
				if(response == "bounce") {#
					remaining_distance <- as.vector(distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat))#
					bearing_to_centre <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]))#
					bearing_to_start <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, start_positions[j, 1], start_positions[j, 2]))#
					bearing_difference <- min(c(abs(bearing_to_start - bearing_to_centre), 360 - abs(bearing_to_start - bearing_to_centre)))#
					if(all.equal((bearing_to_centre + bearing_difference) %% 360, bearing_to_start) == TRUE) {#
						bearing_to_end <- (bearing_to_centre - bearing_difference) %% 360#
					} else {#
						bearing_to_end <- (bearing_to_centre + bearing_difference) %% 360#
					}#
					new_position <- EndPoint(new_position$long, new_position$lat, bearing_to_end, remaining_distance)[c("long", "lat")]#
					# Overwrite start positions:#
					start_positions[j, ] <- unlist(new_position)#
					# Record distance from centre of continent:#
					end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
					if(end_distances[j] > continent_radius) stop("Fallen off after bouncing!")#
				}#
				# If response to hitting a continent edge is to stick to it:#
				if(response == "stop") {#
					# Overwrite start positions:#
					start_positions[j, ] <- unlist(new_position)#
					# Record distance from centre of continent:#
					end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
				}#
			}#
		# If draw means staying on continent:#
		} else {#
			# Overwrite start positions:#
			start_positions[j, ] <- unlist(new_position)#
			# Record distance from centre of continent:#
			end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
		}#
	}#
}#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="blue", cex=0.5)#
#
quartz()#
hist(start_distances)#
quartz()#
hist(end_distances)
library(maps)#
#
EarthRad <- 6367.4447#
#
niter <- 100#
#
n_aminals <- 10000#
#
stepsize_sd <- 100#
#
continent_centre <- c(0, 0)#
#
continent_radius <- 2000#
#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
end_distances <- start_distances <- vector(mode="numeric")#
#
response <- "bounce"#
#response <- "redraw"#
#response <- "stop"#
#
for(i in 1:n_aminals) {#
#
	bearing <- runif(1, 0, 360)#
#
	distance <- runif(1, 0, continent_radius)#
	start_positions <- rbind(start_positions, unlist(EndPoint(continent_centre[1], continent_centre[1], bearing, distance)[c("long", "lat")]))#
	# Record distance from centre of continent:#
	start_distances[i] <- distance#
}#
#
map(xlim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), ylim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="red", cex=0.5)#
#
# For each time step:#
for(i in 1:niter) {#
	# For each organism:#
	for(j in 1:n_aminals) {#
		# Draw a random bearing for the next move:#
		bearing <- runif(1, 0, 360)#
		# Draw a random distance for the next move:#
		distance <- abs(rnorm(1, 0, stepsize_sd))#
		# Calculate the new position of the organism following the move:#
		new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
		# If draw means leaving continent:#
		if(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
			# If response to leaving continent is to redraw:#
			if(response == "redraw") {#
				# As long as the draw removes the taxon from the continent:#
				while(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
					# Redraw the bearing:#
					bearing <- runif(1, 0, 360)#
					# Redraw the distance:#
					distance <- abs(rnorm(1, 0, stepsize_sd))#
					# Calculate the new position:#
					new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
				}#
				# Overwrite start positions:#
				start_positions[j, ] <- unlist(new_position)#
				# Record distance from centre of continent:#
				end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
			# If response to leaving continent is not to redraw (i.e., is to bounce off of, or stop at, continent edge):#
			} else {#
# FIND COLLISION POINT STARTS HERE:#
				# Scalar which describes the proportion of the disatcne the organism has to travel before colliding with the continent edge:#
				distance_modifier <- 0.5#
				# Starting stepsize (will shrink as answer is honed in on more precisely):#
				stepsize <- 0.1#
				new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
				while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
					current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
					# Do we need to increase the distance modifier value?:#
					if(current_distance_from_centre < continent_radius) {#
						# Create potential better value by adding step size to modifier:#
						limit <- distance_modifier + stepsize#
					# Or do we need to decrease the degree modifier value?:#
					} else {#
						# Create potential better value by subtracting step size from modifier:#
						limit <- distance_modifier - stepsize#
					}#
					new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
					# Get new distance from continent centre based on potential better modifer:#
					new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
					# If new distance is closer to continent radius:#
					if(abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)) {#
						# Update new position:#
						new_position <- new_new_position#
						# Update distance modifier itself:#
						distance_modifier <- limit#
					# If current distance is stil our best estimate:#
					} else {#
						# Shrink the step size so we can hone in closer:#
						stepsize <- stepsize * 0.1#
					}#
				}#
# FIND COLLISION POINT ENDS HERE:#
				# If response to hitting a continent edge is to bounce off it:#
				if(response == "bounce") {#
					remaining_distance <- as.vector(distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat))#
					bearing_to_centre <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]))#
					bearing_to_start <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, start_positions[j, 1], start_positions[j, 2]))#
					bearing_difference <- min(c(abs(bearing_to_start - bearing_to_centre), 360 - abs(bearing_to_start - bearing_to_centre)))#
					if(all.equal((bearing_to_centre + bearing_difference) %% 360, bearing_to_start) == TRUE) {#
						bearing_to_end <- (bearing_to_centre - bearing_difference) %% 360#
					} else {#
						bearing_to_end <- (bearing_to_centre + bearing_difference) %% 360#
					}#
					new_position <- EndPoint(new_position$long, new_position$lat, bearing_to_end, remaining_distance)[c("long", "lat")]#
					# Overwrite start positions:#
					start_positions[j, ] <- unlist(new_position)#
					# Record distance from centre of continent:#
					end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
					if(end_distances[j] > continent_radius) stop("Fallen off after bouncing!")#
				}#
				# If response to hitting a continent edge is to stick to it:#
				if(response == "stop") {#
					# Overwrite start positions:#
					start_positions[j, ] <- unlist(new_position)#
					# Record distance from centre of continent:#
					end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
				}#
			}#
		# If draw means staying on continent:#
		} else {#
			# Overwrite start positions:#
			start_positions[j, ] <- unlist(new_position)#
			# Record distance from centre of continent:#
			end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
		}#
	}#
}#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="blue", cex=0.5)#
#
quartz()#
hist(start_distances)#
quartz()#
hist(end_distances)
map(xlim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), ylim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="red", cex=0.5)
map(xlim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), ylim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="red", cex=0.3)
library(maps)#
#
EarthRad <- 6367.4447#
#
niter <- 100#
#
n_aminals <- 10000#
#
stepsize_sd <- 100#
#
continent_centre <- c(0, 0)#
#
continent_radius <- 2000#
#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
end_distances <- start_distances <- vector(mode="numeric")#
#
#response <- "bounce"#
response <- "redraw"#
#response <- "stop"#
#
for(i in 1:n_aminals) {#
#
	bearing <- runif(1, 0, 360)#
#
	distance <- runif(1, 0, continent_radius)#
	start_positions <- rbind(start_positions, unlist(EndPoint(continent_centre[1], continent_centre[1], bearing, distance)[c("long", "lat")]))#
	# Record distance from centre of continent:#
	start_distances[i] <- distance#
}#
#
map(xlim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), ylim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="red", cex=0.5)#
#
# For each time step:#
for(i in 1:niter) {#
	# For each organism:#
	for(j in 1:n_aminals) {#
		# Draw a random bearing for the next move:#
		bearing <- runif(1, 0, 360)#
		# Draw a random distance for the next move:#
		distance <- abs(rnorm(1, 0, stepsize_sd))#
		# Calculate the new position of the organism following the move:#
		new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
		# If draw means leaving continent:#
		if(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
			# If response to leaving continent is to redraw:#
			if(response == "redraw") {#
				# As long as the draw removes the taxon from the continent:#
				while(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
					# Redraw the bearing:#
					bearing <- runif(1, 0, 360)#
					# Redraw the distance:#
					distance <- abs(rnorm(1, 0, stepsize_sd))#
					# Calculate the new position:#
					new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
				}#
				# Overwrite start positions:#
				start_positions[j, ] <- unlist(new_position)#
				# Record distance from centre of continent:#
				end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
			# If response to leaving continent is not to redraw (i.e., is to bounce off of, or stop at, continent edge):#
			} else {#
# FIND COLLISION POINT STARTS HERE:#
				# Scalar which describes the proportion of the disatcne the organism has to travel before colliding with the continent edge:#
				distance_modifier <- 0.5#
				# Starting stepsize (will shrink as answer is honed in on more precisely):#
				stepsize <- 0.1#
				new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
				while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
					current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
					# Do we need to increase the distance modifier value?:#
					if(current_distance_from_centre < continent_radius) {#
						# Create potential better value by adding step size to modifier:#
						limit <- distance_modifier + stepsize#
					# Or do we need to decrease the degree modifier value?:#
					} else {#
						# Create potential better value by subtracting step size from modifier:#
						limit <- distance_modifier - stepsize#
					}#
					new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
					# Get new distance from continent centre based on potential better modifer:#
					new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
					# If new distance is closer to continent radius:#
					if(abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)) {#
						# Update new position:#
						new_position <- new_new_position#
						# Update distance modifier itself:#
						distance_modifier <- limit#
					# If current distance is stil our best estimate:#
					} else {#
						# Shrink the step size so we can hone in closer:#
						stepsize <- stepsize * 0.1#
					}#
				}#
# FIND COLLISION POINT ENDS HERE:#
				# If response to hitting a continent edge is to bounce off it:#
				if(response == "bounce") {#
					remaining_distance <- as.vector(distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat))#
					bearing_to_centre <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]))#
					bearing_to_start <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, start_positions[j, 1], start_positions[j, 2]))#
					bearing_difference <- min(c(abs(bearing_to_start - bearing_to_centre), 360 - abs(bearing_to_start - bearing_to_centre)))#
					if(all.equal((bearing_to_centre + bearing_difference) %% 360, bearing_to_start) == TRUE) {#
						bearing_to_end <- (bearing_to_centre - bearing_difference) %% 360#
					} else {#
						bearing_to_end <- (bearing_to_centre + bearing_difference) %% 360#
					}#
					new_position <- EndPoint(new_position$long, new_position$lat, bearing_to_end, remaining_distance)[c("long", "lat")]#
					# Overwrite start positions:#
					start_positions[j, ] <- unlist(new_position)#
					# Record distance from centre of continent:#
					end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
					if(end_distances[j] > continent_radius) stop("Fallen off after bouncing!")#
				}#
				# If response to hitting a continent edge is to stick to it:#
				if(response == "stop") {#
					# Overwrite start positions:#
					start_positions[j, ] <- unlist(new_position)#
					# Record distance from centre of continent:#
					end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
				}#
			}#
		# If draw means staying on continent:#
		} else {#
			# Overwrite start positions:#
			start_positions[j, ] <- unlist(new_position)#
			# Record distance from centre of continent:#
			end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
		}#
	}#
}#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="blue", cex=0.5)#
#
quartz()#
hist(start_distances)#
quartz()#
hist(end_distances)
map(xlim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), ylim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="red", cex=0.5)
c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360))
runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360))
c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))
GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])
start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))
GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])
start_distances[i]
start_distances[i] > continent_radius
library(maps)#
#
EarthRad <- 6367.4447#
#
niter <- 100#
#
n_aminals <- 10000#
#
stepsize_sd <- 100#
#
continent_centre <- c(0, 0)#
#
continent_radius <- 2000#
#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
end_distances <- start_distances <- vector(mode="numeric")#
#
#response <- "bounce"#
response <- "redraw"#
#response <- "stop"#
#
for(i in 1:n_aminals) {#
#
	start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
	# Record distance from centre of continent:#
	start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
	if(start_distances[i] > continent_radius) {#
		while(start_distances[i] > continent_radius) {#
			start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
			# Record distance from centre of continent:#
			start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
		}#
	}#
	start_positions <- rbind(start_positions, start_position)#
}#
#
map(xlim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), ylim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="red", cex=0.5)
library(maps)#
#
EarthRad <- 6367.4447#
#
niter <- 100#
#
n_aminals <- 100#
#
stepsize_sd <- 100#
#
continent_centre <- c(0, 0)#
#
continent_radius <- 2000#
#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
end_distances <- start_distances <- vector(mode="numeric")#
#
#response <- "bounce"#
response <- "redraw"#
#response <- "stop"#
#
for(i in 1:n_aminals) {#
#
	start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
	# Record distance from centre of continent:#
	start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
	if(start_distances[i] > continent_radius) {#
		while(start_distances[i] > continent_radius) {#
			start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
			# Record distance from centre of continent:#
			start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
		}#
	}#
	start_positions <- rbind(start_positions, start_position)#
}#
#
ossified_start_positions <- start_positions#
#
# For each time step:#
for(i in 1:niter) {#
	# For each organism:#
	for(j in 1:n_aminals) {#
		# Draw a random bearing for the next move:#
		bearing <- runif(1, 0, 360)#
		# Draw a random distance for the next move:#
		distance <- abs(rnorm(1, 0, stepsize_sd))#
		# Calculate the new position of the organism following the move:#
		new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
		# If draw means leaving continent:#
		if(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
			# If response to leaving continent is to redraw:#
			if(response == "redraw") {#
				# As long as the draw removes the taxon from the continent:#
				while(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
					# Redraw the bearing:#
					bearing <- runif(1, 0, 360)#
					# Redraw the distance:#
					distance <- abs(rnorm(1, 0, stepsize_sd))#
					# Calculate the new position:#
					new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
				}#
				# Overwrite start positions:#
				start_positions[j, ] <- unlist(new_position)#
				# Record distance from centre of continent:#
				end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
			# If response to leaving continent is not to redraw (i.e., is to bounce off of, or stop at, continent edge):#
			} else {#
# FIND COLLISION POINT STARTS HERE:#
				# Scalar which describes the proportion of the disatcne the organism has to travel before colliding with the continent edge:#
				distance_modifier <- 0.5#
				# Starting stepsize (will shrink as answer is honed in on more precisely):#
				stepsize <- 0.1#
				new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
				while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
					current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
					# Do we need to increase the distance modifier value?:#
					if(current_distance_from_centre < continent_radius) {#
						# Create potential better value by adding step size to modifier:#
						limit <- distance_modifier + stepsize#
					# Or do we need to decrease the degree modifier value?:#
					} else {#
						# Create potential better value by subtracting step size from modifier:#
						limit <- distance_modifier - stepsize#
					}#
					new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
					# Get new distance from continent centre based on potential better modifer:#
					new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
					# If new distance is closer to continent radius:#
					if(abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)) {#
						# Update new position:#
						new_position <- new_new_position#
						# Update distance modifier itself:#
						distance_modifier <- limit#
					# If current distance is stil our best estimate:#
					} else {#
						# Shrink the step size so we can hone in closer:#
						stepsize <- stepsize * 0.1#
					}#
				}#
# FIND COLLISION POINT ENDS HERE:#
				# If response to hitting a continent edge is to bounce off it:#
				if(response == "bounce") {#
					remaining_distance <- as.vector(distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat))#
					bearing_to_centre <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]))#
					bearing_to_start <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, start_positions[j, 1], start_positions[j, 2]))#
					bearing_difference <- min(c(abs(bearing_to_start - bearing_to_centre), 360 - abs(bearing_to_start - bearing_to_centre)))#
					if(all.equal((bearing_to_centre + bearing_difference) %% 360, bearing_to_start) == TRUE) {#
						bearing_to_end <- (bearing_to_centre - bearing_difference) %% 360#
					} else {#
						bearing_to_end <- (bearing_to_centre + bearing_difference) %% 360#
					}#
					new_position <- EndPoint(new_position$long, new_position$lat, bearing_to_end, remaining_distance)[c("long", "lat")]#
					# Overwrite start positions:#
					start_positions[j, ] <- unlist(new_position)#
					# Record distance from centre of continent:#
					end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
					if(end_distances[j] > continent_radius) stop("Fallen off after bouncing!")#
				}#
				# If response to hitting a continent edge is to stick to it:#
				if(response == "stop") {#
					# Overwrite start positions:#
					start_positions[j, ] <- unlist(new_position)#
					# Record distance from centre of continent:#
					end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
				}#
			}#
		# If draw means staying on continent:#
		} else {#
			# Overwrite start positions:#
			start_positions[j, ] <- unlist(new_position)#
			# Record distance from centre of continent:#
			end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
		}#
	}#
}#
#
map(xlim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), ylim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
points(ossified_start_positions[, 1], ossified_start_positions[, 2], pch=19, col="red", cex=0.5)#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="blue", cex=0.5)
continent_radius / 10
seq(0, continent_radius, continent_radius / 10)
SphericalCapArea(concentric_circles[i])
concentric_circles <- seq(0, continent_radius, continent_radius / 10)
i<-2
concentric_circles <- seq(0, continent_radius, continent_radius / 10)
SphericalCapArea(concentric_circles[i])
SphericalCapArea(concentric_circles[i]) - SphericalCapArea(concentric_circles[(i - 1)])
concentric_circles <- seq(0, continent_radius, continent_radius / 10)#
#
sphere_areas <- vector(mode="numeric")#
#
for(i in 2:length(concentric_circles)) sphere_areas[(i - 1)] <- SphericalCapArea(concentric_circles[i]) - SphericalCapArea(concentric_circles[(i - 1)])
concentric_circles
sphere_areas
plot(sphere_areas
)
concentric_circles[i]
end_distances
end_distances > concentric_circles[(i - 1)]
end_distances > concentric_circles[(i - 1)] && end_distances <= concentric_circles[i]
intersect(which(end_distances > concentric_circles[(i - 1)]), which(end_distances <= concentric_circles[i]))
length(intersect(which(end_distances > concentric_circles[(i - 1)]), which(end_distances <= concentric_circles[i])))
start_N_animals_per_ring <- end_N_animals_per_ring <- sphere_areas <- vector(mode="numeric")#
for(i in 2:length(concentric_circles)) {#
	sphere_areas[(i - 1)] <- SphericalCapArea(concentric_circles[i]) - SphericalCapArea(concentric_circles[(i - 1)])#
#
	start_N_animals_per_ring <- length(intersect(which(start_distances > concentric_circles[(i - 1)]), which(start_distances <= concentric_circles[i])))#
	end_N_animals_per_ring <- length(intersect(which(end_distances > concentric_circles[(i - 1)]), which(end_distances <= concentric_circles[i])))#
}
start_N_animals_per_ring
end_N_animals_per_ring
start_N_animals_per_ring <- end_N_animals_per_ring <- sphere_areas <- vector(mode="numeric")#
for(i in 2:length(concentric_circles)) {#
	sphere_areas[(i - 1)] <- SphericalCapArea(concentric_circles[i]) - SphericalCapArea(concentric_circles[(i - 1)])#
#
	start_N_animals_per_ring[(i - 1)] <- length(intersect(which(start_distances > concentric_circles[(i - 1)]), which(start_distances <= concentric_circles[i])))#
	end_N_animals_per_ring[(i - 1)] <- length(intersect(which(end_distances > concentric_circles[(i - 1)]), which(end_distances <= concentric_circles[i])))#
}
start_N_animals_per_ring
end_N_animals_per_ring
library(maps)#
#
EarthRad <- 6367.4447#
#
niter <- 100#
#
n_aminals <- 100#
#
stepsize_sd <- 100#
#
continent_centre <- c(0, 0)#
#
continent_radius <- 2000#
#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
end_distances <- start_distances <- vector(mode="numeric")#
#
#response <- "bounce"#
response <- "redraw"#
#response <- "stop"#
#
for(i in 1:n_aminals) {#
#
	start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
	# Record distance from centre of continent:#
	start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
	if(start_distances[i] > continent_radius) {#
		while(start_distances[i] > continent_radius) {#
			start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
			# Record distance from centre of continent:#
			start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
		}#
	}#
	start_positions <- rbind(start_positions, start_position)#
}#
#
ossified_start_positions <- start_positions#
#
# For each time step:#
for(i in 1:niter) {#
	# For each organism:#
	for(j in 1:n_aminals) {#
		# Draw a random bearing for the next move:#
		bearing <- runif(1, 0, 360)#
		# Draw a random distance for the next move:#
		distance <- abs(rnorm(1, 0, stepsize_sd))#
		# Calculate the new position of the organism following the move:#
		new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
		# If draw means leaving continent:#
		if(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
			# If response to leaving continent is to redraw:#
			if(response == "redraw") {#
				# As long as the draw removes the taxon from the continent:#
				while(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
					# Redraw the bearing:#
					bearing <- runif(1, 0, 360)#
					# Redraw the distance:#
					distance <- abs(rnorm(1, 0, stepsize_sd))#
					# Calculate the new position:#
					new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
				}#
				# Overwrite start positions:#
				start_positions[j, ] <- unlist(new_position)#
				# Record distance from centre of continent:#
				end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
			# If response to leaving continent is not to redraw (i.e., is to bounce off of, or stop at, continent edge):#
			} else {#
# FIND COLLISION POINT STARTS HERE:#
				# Scalar which describes the proportion of the disatcne the organism has to travel before colliding with the continent edge:#
				distance_modifier <- 0.5#
				# Starting stepsize (will shrink as answer is honed in on more precisely):#
				stepsize <- 0.1#
				new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
				while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
					current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
					# Do we need to increase the distance modifier value?:#
					if(current_distance_from_centre < continent_radius) {#
						# Create potential better value by adding step size to modifier:#
						limit <- distance_modifier + stepsize#
					# Or do we need to decrease the degree modifier value?:#
					} else {#
						# Create potential better value by subtracting step size from modifier:#
						limit <- distance_modifier - stepsize#
					}#
					new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
					# Get new distance from continent centre based on potential better modifer:#
					new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
					# If new distance is closer to continent radius:#
					if(abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)) {#
						# Update new position:#
						new_position <- new_new_position#
						# Update distance modifier itself:#
						distance_modifier <- limit#
					# If current distance is stil our best estimate:#
					} else {#
						# Shrink the step size so we can hone in closer:#
						stepsize <- stepsize * 0.1#
					}#
				}#
# FIND COLLISION POINT ENDS HERE:#
				# If response to hitting a continent edge is to bounce off it:#
				if(response == "bounce") {#
					remaining_distance <- as.vector(distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat))#
					bearing_to_centre <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]))#
					bearing_to_start <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, start_positions[j, 1], start_positions[j, 2]))#
					bearing_difference <- min(c(abs(bearing_to_start - bearing_to_centre), 360 - abs(bearing_to_start - bearing_to_centre)))#
					if(all.equal((bearing_to_centre + bearing_difference) %% 360, bearing_to_start) == TRUE) {#
						bearing_to_end <- (bearing_to_centre - bearing_difference) %% 360#
					} else {#
						bearing_to_end <- (bearing_to_centre + bearing_difference) %% 360#
					}#
					new_position <- EndPoint(new_position$long, new_position$lat, bearing_to_end, remaining_distance)[c("long", "lat")]#
					# Overwrite start positions:#
					start_positions[j, ] <- unlist(new_position)#
					# Record distance from centre of continent:#
					end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
					if(end_distances[j] > continent_radius) stop("Fallen off after bouncing!")#
				}#
				# If response to hitting a continent edge is to stick to it:#
				if(response == "stop") {#
					# Overwrite start positions:#
					start_positions[j, ] <- unlist(new_position)#
					# Record distance from centre of continent:#
					end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
				}#
			}#
		# If draw means staying on continent:#
		} else {#
			# Overwrite start positions:#
			start_positions[j, ] <- unlist(new_position)#
			# Record distance from centre of continent:#
			end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
		}#
	}#
}#
#
map(xlim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), ylim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
points(ossified_start_positions[, 1], ossified_start_positions[, 2], pch=19, col="red", cex=0.5)#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="blue", cex=0.5)#
#
concentric_circles <- seq(0, continent_radius, continent_radius / 10)#
#
start_N_animals_per_ring <- end_N_animals_per_ring <- sphere_areas <- vector(mode="numeric")#
#
for(i in 2:length(concentric_circles)) {#
	sphere_areas[(i - 1)] <- SphericalCapArea(concentric_circles[i]) - SphericalCapArea(concentric_circles[(i - 1)])#
#
	start_N_animals_per_ring[(i - 1)] <- length(intersect(which(start_distances > concentric_circles[(i - 1)]), which(start_distances <= concentric_circles[i])))#
	end_N_animals_per_ring[(i - 1)] <- length(intersect(which(end_distances > concentric_circles[(i - 1)]), which(end_distances <= concentric_circles[i])))#
}#
#
start_N_animals_per_ring / sphere_areas#
end_N_animals_per_ring / sphere_areas
plot(start_N_animals_per_ring / sphere_areas)
barplot(start_N_animals_per_ring / sphere_areas)#
barplot(end_N_animals_per_ring / sphere_areas)
library(maps)#
#
EarthRad <- 6367.4447#
#
niter <- 100#
#
n_aminals <- 100#
#
stepsize_sd <- 100#
#
continent_centre <- c(0, 0)#
#
continent_radius <- 2000#
#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
end_distances <- start_distances <- vector(mode="numeric")#
#
#response <- "bounce"#
response <- "redraw"#
#response <- "stop"#
#
for(i in 1:n_aminals) {#
#
	start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
	# Record distance from centre of continent:#
	start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
	if(start_distances[i] > continent_radius) {#
		while(start_distances[i] > continent_radius) {#
			start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
			# Record distance from centre of continent:#
			start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
		}#
	}#
	start_positions <- rbind(start_positions, start_position)#
}#
#
ossified_start_positions <- start_positions#
#
# For each time step:#
for(i in 1:niter) {#
	# For each organism:#
	for(j in 1:n_aminals) {#
		# Draw a random bearing for the next move:#
		bearing <- runif(1, 0, 360)#
		# Draw a random distance for the next move:#
		distance <- abs(rnorm(1, 0, stepsize_sd))#
		# Calculate the new position of the organism following the move:#
		new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
		# If draw means leaving continent:#
		if(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
			# If response to leaving continent is to redraw:#
			if(response == "redraw") {#
				# As long as the draw removes the taxon from the continent:#
				while(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
					# Redraw the bearing:#
					bearing <- runif(1, 0, 360)#
					# Redraw the distance:#
					distance <- abs(rnorm(1, 0, stepsize_sd))#
					# Calculate the new position:#
					new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
				}#
				# Overwrite start positions:#
				start_positions[j, ] <- unlist(new_position)#
				# Record distance from centre of continent:#
				end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
			# If response to leaving continent is not to redraw (i.e., is to bounce off of, or stop at, continent edge):#
			} else {#
# FIND COLLISION POINT STARTS HERE:#
				# Scalar which describes the proportion of the disatcne the organism has to travel before colliding with the continent edge:#
				distance_modifier <- 0.5#
				# Starting stepsize (will shrink as answer is honed in on more precisely):#
				stepsize <- 0.1#
				new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
				while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
					current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
					# Do we need to increase the distance modifier value?:#
					if(current_distance_from_centre < continent_radius) {#
						# Create potential better value by adding step size to modifier:#
						limit <- distance_modifier + stepsize#
					# Or do we need to decrease the degree modifier value?:#
					} else {#
						# Create potential better value by subtracting step size from modifier:#
						limit <- distance_modifier - stepsize#
					}#
					new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
					# Get new distance from continent centre based on potential better modifer:#
					new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
					# If new distance is closer to continent radius:#
					if(abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)) {#
						# Update new position:#
						new_position <- new_new_position#
						# Update distance modifier itself:#
						distance_modifier <- limit#
					# If current distance is stil our best estimate:#
					} else {#
						# Shrink the step size so we can hone in closer:#
						stepsize <- stepsize * 0.1#
					}#
				}#
# FIND COLLISION POINT ENDS HERE:#
				# If response to hitting a continent edge is to bounce off it:#
				if(response == "bounce") {#
					remaining_distance <- as.vector(distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat))#
					bearing_to_centre <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]))#
					bearing_to_start <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, start_positions[j, 1], start_positions[j, 2]))#
					bearing_difference <- min(c(abs(bearing_to_start - bearing_to_centre), 360 - abs(bearing_to_start - bearing_to_centre)))#
					if(all.equal((bearing_to_centre + bearing_difference) %% 360, bearing_to_start) == TRUE) {#
						bearing_to_end <- (bearing_to_centre - bearing_difference) %% 360#
					} else {#
						bearing_to_end <- (bearing_to_centre + bearing_difference) %% 360#
					}#
					new_position <- EndPoint(new_position$long, new_position$lat, bearing_to_end, remaining_distance)[c("long", "lat")]#
					# Overwrite start positions:#
					start_positions[j, ] <- unlist(new_position)#
					# Record distance from centre of continent:#
					end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
					if(end_distances[j] > continent_radius) stop("Fallen off after bouncing!")#
				}#
				# If response to hitting a continent edge is to stick to it:#
				if(response == "stop") {#
					# Overwrite start positions:#
					start_positions[j, ] <- unlist(new_position)#
					# Record distance from centre of continent:#
					end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
				}#
			}#
		# If draw means staying on continent:#
		} else {#
			# Overwrite start positions:#
			start_positions[j, ] <- unlist(new_position)#
			# Record distance from centre of continent:#
			end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
		}#
	}#
}#
#
map(xlim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), ylim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
points(ossified_start_positions[, 1], ossified_start_positions[, 2], pch=19, col="red", cex=0.5)#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="blue", cex=0.5)#
#
concentric_circles <- seq(0, continent_radius, continent_radius / 10)#
#
start_N_animals_per_ring <- end_N_animals_per_ring <- sphere_areas <- vector(mode="numeric")#
#
for(i in 2:length(concentric_circles)) {#
	sphere_areas[(i - 1)] <- SphericalCapArea(concentric_circles[i]) - SphericalCapArea(concentric_circles[(i - 1)])#
#
	start_N_animals_per_ring[(i - 1)] <- length(intersect(which(start_distances > concentric_circles[(i - 1)]), which(start_distances <= concentric_circles[i])))#
	end_N_animals_per_ring[(i - 1)] <- length(intersect(which(end_distances > concentric_circles[(i - 1)]), which(end_distances <= concentric_circles[i])))#
}#
#
quartz()#
barplot(start_N_animals_per_ring / sphere_areas)#
quartz()#
barplot(end_N_animals_per_ring / sphere_areas)
?barplot
library(maps)#
#
EarthRad <- 6367.4447#
#
niter <- 100#
#
n_aminals <- 10000#
#
stepsize_sd <- 100#
#
continent_centre <- c(0, 0)#
#
continent_radius <- 2000#
#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
end_distances <- start_distances <- vector(mode="numeric")#
#
#response <- "bounce"#
response <- "redraw"#
#response <- "stop"#
#
for(i in 1:n_aminals) {#
#
	start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
	# Record distance from centre of continent:#
	start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
	if(start_distances[i] > continent_radius) {#
		while(start_distances[i] > continent_radius) {#
			start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
			# Record distance from centre of continent:#
			start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
		}#
	}#
	start_positions <- rbind(start_positions, start_position)#
}#
#
ossified_start_positions <- start_positions#
#
# For each time step:#
for(i in 1:niter) {#
	# For each organism:#
	for(j in 1:n_aminals) {#
		# Draw a random bearing for the next move:#
		bearing <- runif(1, 0, 360)#
		# Draw a random distance for the next move:#
		distance <- abs(rnorm(1, 0, stepsize_sd))#
		# Calculate the new position of the organism following the move:#
		new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
		# If draw means leaving continent:#
		if(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
			# If response to leaving continent is to redraw:#
			if(response == "redraw") {#
				# As long as the draw removes the taxon from the continent:#
				while(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
					# Redraw the bearing:#
					bearing <- runif(1, 0, 360)#
					# Redraw the distance:#
					distance <- abs(rnorm(1, 0, stepsize_sd))#
					# Calculate the new position:#
					new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
				}#
				# Overwrite start positions:#
				start_positions[j, ] <- unlist(new_position)#
				# Record distance from centre of continent:#
				end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
			# If response to leaving continent is not to redraw (i.e., is to bounce off of, or stop at, continent edge):#
			} else {#
# FIND COLLISION POINT STARTS HERE:#
				# Scalar which describes the proportion of the disatcne the organism has to travel before colliding with the continent edge:#
				distance_modifier <- 0.5#
				# Starting stepsize (will shrink as answer is honed in on more precisely):#
				stepsize <- 0.1#
				new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
				while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
					current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
					# Do we need to increase the distance modifier value?:#
					if(current_distance_from_centre < continent_radius) {#
						# Create potential better value by adding step size to modifier:#
						limit <- distance_modifier + stepsize#
					# Or do we need to decrease the degree modifier value?:#
					} else {#
						# Create potential better value by subtracting step size from modifier:#
						limit <- distance_modifier - stepsize#
					}#
					new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
					# Get new distance from continent centre based on potential better modifer:#
					new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
					# If new distance is closer to continent radius:#
					if(abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)) {#
						# Update new position:#
						new_position <- new_new_position#
						# Update distance modifier itself:#
						distance_modifier <- limit#
					# If current distance is stil our best estimate:#
					} else {#
						# Shrink the step size so we can hone in closer:#
						stepsize <- stepsize * 0.1#
					}#
				}#
# FIND COLLISION POINT ENDS HERE:#
				# If response to hitting a continent edge is to bounce off it:#
				if(response == "bounce") {#
					remaining_distance <- as.vector(distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat))#
					bearing_to_centre <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]))#
					bearing_to_start <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, start_positions[j, 1], start_positions[j, 2]))#
					bearing_difference <- min(c(abs(bearing_to_start - bearing_to_centre), 360 - abs(bearing_to_start - bearing_to_centre)))#
					if(all.equal((bearing_to_centre + bearing_difference) %% 360, bearing_to_start) == TRUE) {#
						bearing_to_end <- (bearing_to_centre - bearing_difference) %% 360#
					} else {#
						bearing_to_end <- (bearing_to_centre + bearing_difference) %% 360#
					}#
					new_position <- EndPoint(new_position$long, new_position$lat, bearing_to_end, remaining_distance)[c("long", "lat")]#
					# Overwrite start positions:#
					start_positions[j, ] <- unlist(new_position)#
					# Record distance from centre of continent:#
					end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
					if(end_distances[j] > continent_radius) stop("Fallen off after bouncing!")#
				}#
				# If response to hitting a continent edge is to stick to it:#
				if(response == "stop") {#
					# Overwrite start positions:#
					start_positions[j, ] <- unlist(new_position)#
					# Record distance from centre of continent:#
					end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
				}#
			}#
		# If draw means staying on continent:#
		} else {#
			# Overwrite start positions:#
			start_positions[j, ] <- unlist(new_position)#
			# Record distance from centre of continent:#
			end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
		}#
	}#
}#
#
map(xlim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), ylim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
points(ossified_start_positions[, 1], ossified_start_positions[, 2], pch=19, col="red", cex=0.5)#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="blue", cex=0.5)#
#
concentric_circles <- seq(0, continent_radius, continent_radius / 10)#
#
start_N_animals_per_ring <- end_N_animals_per_ring <- sphere_areas <- vector(mode="numeric")#
#
for(i in 2:length(concentric_circles)) {#
	sphere_areas[(i - 1)] <- SphericalCapArea(concentric_circles[i]) - SphericalCapArea(concentric_circles[(i - 1)])#
#
	start_N_animals_per_ring[(i - 1)] <- length(intersect(which(start_distances > concentric_circles[(i - 1)]), which(start_distances <= concentric_circles[i])))#
	end_N_animals_per_ring[(i - 1)] <- length(intersect(which(end_distances > concentric_circles[(i - 1)]), which(end_distances <= concentric_circles[i])))#
}#
#
quartz()#
barplot(start_N_animals_per_ring / sphere_areas, main="Start")#
quartz()#
barplot(end_N_animals_per_ring / sphere_areas, main="End")
library(maps)#
#
EarthRad <- 6367.4447#
#
niter <- 100#
#
n_aminals <- 10000#
#
stepsize_sd <- 100#
#
continent_centre <- c(0, 0)#
#
continent_radius <- 2000#
#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
end_distances <- start_distances <- vector(mode="numeric")#
#
response <- "bounce"#
#response <- "redraw"#
#response <- "stop"#
#
for(i in 1:n_aminals) {#
#
	start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
	# Record distance from centre of continent:#
	start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
	if(start_distances[i] > continent_radius) {#
		while(start_distances[i] > continent_radius) {#
			start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
			# Record distance from centre of continent:#
			start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
		}#
	}#
	start_positions <- rbind(start_positions, start_position)#
}#
#
ossified_start_positions <- start_positions#
#
# For each time step:#
for(i in 1:niter) {#
	# For each organism:#
	for(j in 1:n_aminals) {#
		# Draw a random bearing for the next move:#
		bearing <- runif(1, 0, 360)#
		# Draw a random distance for the next move:#
		distance <- abs(rnorm(1, 0, stepsize_sd))#
		# Calculate the new position of the organism following the move:#
		new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
		# If draw means leaving continent:#
		if(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
			# If response to leaving continent is to redraw:#
			if(response == "redraw") {#
				# As long as the draw removes the taxon from the continent:#
				while(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
					# Redraw the bearing:#
					bearing <- runif(1, 0, 360)#
					# Redraw the distance:#
					distance <- abs(rnorm(1, 0, stepsize_sd))#
					# Calculate the new position:#
					new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
				}#
				# Overwrite start positions:#
				start_positions[j, ] <- unlist(new_position)#
				# Record distance from centre of continent:#
				end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
			# If response to leaving continent is not to redraw (i.e., is to bounce off of, or stop at, continent edge):#
			} else {#
# FIND COLLISION POINT STARTS HERE:#
				# Scalar which describes the proportion of the disatcne the organism has to travel before colliding with the continent edge:#
				distance_modifier <- 0.5#
				# Starting stepsize (will shrink as answer is honed in on more precisely):#
				stepsize <- 0.1#
				new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
				while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
					current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
					# Do we need to increase the distance modifier value?:#
					if(current_distance_from_centre < continent_radius) {#
						# Create potential better value by adding step size to modifier:#
						limit <- distance_modifier + stepsize#
					# Or do we need to decrease the degree modifier value?:#
					} else {#
						# Create potential better value by subtracting step size from modifier:#
						limit <- distance_modifier - stepsize#
					}#
					new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
					# Get new distance from continent centre based on potential better modifer:#
					new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
					# If new distance is closer to continent radius:#
					if(abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)) {#
						# Update new position:#
						new_position <- new_new_position#
						# Update distance modifier itself:#
						distance_modifier <- limit#
					# If current distance is stil our best estimate:#
					} else {#
						# Shrink the step size so we can hone in closer:#
						stepsize <- stepsize * 0.1#
					}#
				}#
# FIND COLLISION POINT ENDS HERE:#
				# If response to hitting a continent edge is to bounce off it:#
				if(response == "bounce") {#
					remaining_distance <- as.vector(distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat))#
					bearing_to_centre <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]))#
					bearing_to_start <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, start_positions[j, 1], start_positions[j, 2]))#
					bearing_difference <- min(c(abs(bearing_to_start - bearing_to_centre), 360 - abs(bearing_to_start - bearing_to_centre)))#
					if(all.equal((bearing_to_centre + bearing_difference) %% 360, bearing_to_start) == TRUE) {#
						bearing_to_end <- (bearing_to_centre - bearing_difference) %% 360#
					} else {#
						bearing_to_end <- (bearing_to_centre + bearing_difference) %% 360#
					}#
					new_position <- EndPoint(new_position$long, new_position$lat, bearing_to_end, remaining_distance)[c("long", "lat")]#
					# Overwrite start positions:#
					start_positions[j, ] <- unlist(new_position)#
					# Record distance from centre of continent:#
					end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
					if(end_distances[j] > continent_radius) stop("Fallen off after bouncing!")#
				}#
				# If response to hitting a continent edge is to stick to it:#
				if(response == "stop") {#
					# Overwrite start positions:#
					start_positions[j, ] <- unlist(new_position)#
					# Record distance from centre of continent:#
					end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
				}#
			}#
		# If draw means staying on continent:#
		} else {#
			# Overwrite start positions:#
			start_positions[j, ] <- unlist(new_position)#
			# Record distance from centre of continent:#
			end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
		}#
	}#
}#
#
map(xlim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), ylim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
points(ossified_start_positions[, 1], ossified_start_positions[, 2], pch=19, col="red", cex=0.5)#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="blue", cex=0.5)#
#
concentric_circles <- seq(0, continent_radius, continent_radius / 10)#
#
start_N_animals_per_ring <- end_N_animals_per_ring <- sphere_areas <- vector(mode="numeric")#
#
for(i in 2:length(concentric_circles)) {#
	sphere_areas[(i - 1)] <- SphericalCapArea(concentric_circles[i]) - SphericalCapArea(concentric_circles[(i - 1)])#
#
	start_N_animals_per_ring[(i - 1)] <- length(intersect(which(start_distances > concentric_circles[(i - 1)]), which(start_distances <= concentric_circles[i])))#
	end_N_animals_per_ring[(i - 1)] <- length(intersect(which(end_distances > concentric_circles[(i - 1)]), which(end_distances <= concentric_circles[i])))#
}#
#
quartz()#
barplot(start_N_animals_per_ring / sphere_areas, main="Start")#
quartz()#
barplot(end_N_animals_per_ring / sphere_areas, main="End")
library(maps)#
#
EarthRad <- 6367.4447#
#
niter <- 100#
#
n_aminals <- 10000#
#
stepsize_sd <- 100#
#
continent_centre <- c(0, 0)#
#
continent_radius <- 2000#
#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
end_distances <- start_distances <- vector(mode="numeric")#
#
#response <- "bounce"#
#response <- "redraw"#
response <- "stop"#
#
for(i in 1:n_aminals) {#
#
	start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
	# Record distance from centre of continent:#
	start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
	if(start_distances[i] > continent_radius) {#
		while(start_distances[i] > continent_radius) {#
			start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
			# Record distance from centre of continent:#
			start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
		}#
	}#
	start_positions <- rbind(start_positions, start_position)#
}#
#
ossified_start_positions <- start_positions#
#
# For each time step:#
for(i in 1:niter) {#
	# For each organism:#
	for(j in 1:n_aminals) {#
		# Draw a random bearing for the next move:#
		bearing <- runif(1, 0, 360)#
		# Draw a random distance for the next move:#
		distance <- abs(rnorm(1, 0, stepsize_sd))#
		# Calculate the new position of the organism following the move:#
		new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
		# If draw means leaving continent:#
		if(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
			# If response to leaving continent is to redraw:#
			if(response == "redraw") {#
				# As long as the draw removes the taxon from the continent:#
				while(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
					# Redraw the bearing:#
					bearing <- runif(1, 0, 360)#
					# Redraw the distance:#
					distance <- abs(rnorm(1, 0, stepsize_sd))#
					# Calculate the new position:#
					new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
				}#
				# Overwrite start positions:#
				start_positions[j, ] <- unlist(new_position)#
				# Record distance from centre of continent:#
				end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
			# If response to leaving continent is not to redraw (i.e., is to bounce off of, or stop at, continent edge):#
			} else {#
# FIND COLLISION POINT STARTS HERE:#
				# Scalar which describes the proportion of the disatcne the organism has to travel before colliding with the continent edge:#
				distance_modifier <- 0.5#
				# Starting stepsize (will shrink as answer is honed in on more precisely):#
				stepsize <- 0.1#
				new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
				while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
					current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
					# Do we need to increase the distance modifier value?:#
					if(current_distance_from_centre < continent_radius) {#
						# Create potential better value by adding step size to modifier:#
						limit <- distance_modifier + stepsize#
					# Or do we need to decrease the degree modifier value?:#
					} else {#
						# Create potential better value by subtracting step size from modifier:#
						limit <- distance_modifier - stepsize#
					}#
					new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
					# Get new distance from continent centre based on potential better modifer:#
					new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
					# If new distance is closer to continent radius:#
					if(abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)) {#
						# Update new position:#
						new_position <- new_new_position#
						# Update distance modifier itself:#
						distance_modifier <- limit#
					# If current distance is stil our best estimate:#
					} else {#
						# Shrink the step size so we can hone in closer:#
						stepsize <- stepsize * 0.1#
					}#
				}#
# FIND COLLISION POINT ENDS HERE:#
				# If response to hitting a continent edge is to bounce off it:#
				if(response == "bounce") {#
					remaining_distance <- as.vector(distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat))#
					bearing_to_centre <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]))#
					bearing_to_start <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, start_positions[j, 1], start_positions[j, 2]))#
					bearing_difference <- min(c(abs(bearing_to_start - bearing_to_centre), 360 - abs(bearing_to_start - bearing_to_centre)))#
					if(all.equal((bearing_to_centre + bearing_difference) %% 360, bearing_to_start) == TRUE) {#
						bearing_to_end <- (bearing_to_centre - bearing_difference) %% 360#
					} else {#
						bearing_to_end <- (bearing_to_centre + bearing_difference) %% 360#
					}#
					new_position <- EndPoint(new_position$long, new_position$lat, bearing_to_end, remaining_distance)[c("long", "lat")]#
					# Overwrite start positions:#
					start_positions[j, ] <- unlist(new_position)#
					# Record distance from centre of continent:#
					end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
					if(end_distances[j] > continent_radius) stop("Fallen off after bouncing!")#
				}#
				# If response to hitting a continent edge is to stick to it:#
				if(response == "stop") {#
					# Overwrite start positions:#
					start_positions[j, ] <- unlist(new_position)#
					# Record distance from centre of continent:#
					end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
				}#
			}#
		# If draw means staying on continent:#
		} else {#
			# Overwrite start positions:#
			start_positions[j, ] <- unlist(new_position)#
			# Record distance from centre of continent:#
			end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
		}#
	}#
}#
#
map(xlim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), ylim=c(-continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
points(ossified_start_positions[, 1], ossified_start_positions[, 2], pch=19, col="red", cex=0.5)#
#
points(start_positions[, 1], start_positions[, 2], pch=19, col="blue", cex=0.5)#
#
concentric_circles <- seq(0, continent_radius, continent_radius / 10)#
#
start_N_animals_per_ring <- end_N_animals_per_ring <- sphere_areas <- vector(mode="numeric")#
#
for(i in 2:length(concentric_circles)) {#
	sphere_areas[(i - 1)] <- SphericalCapArea(concentric_circles[i]) - SphericalCapArea(concentric_circles[(i - 1)])#
#
	start_N_animals_per_ring[(i - 1)] <- length(intersect(which(start_distances > concentric_circles[(i - 1)]), which(start_distances <= concentric_circles[i])))#
	end_N_animals_per_ring[(i - 1)] <- length(intersect(which(end_distances > concentric_circles[(i - 1)]), which(end_distances <= concentric_circles[i])))#
}#
#
quartz()#
barplot(start_N_animals_per_ring / sphere_areas, main="Start")#
quartz()#
barplot(end_N_animals_per_ring / sphere_areas, main="End")
Sys.time()
# Load maps library:#
library(maps)#
#
# Set Earth radius in kilometres:#
EarthRad <- 6367.4447#
#
# Set number of time steps to run simulation for:#
niter <- 100#
#
# Set number of animals to run simulation for:#
n_aminals <- 10000#
#
# Set standard deviation of step size for dispersal in kilometres:#
stepsize_sd <- 100#
#
# Set centre of continent (long, lat):#
continent_centre <- c(0, 0)#
#
# Set radius of continent in kilometres:#
continent_radius <- 2000#
#
# Create empty matrix to store start positions (long, lat) of each animal:#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
# Create vectors to store distances from continent centre at beginning and end of simlation:#
end_distances <- start_distances <- vector(mode="numeric")#
#
# Pick a response type (one of "bounce", "redraw", or "stop")#
response <- "bounce"#
#
start_time <- Sys.time()#
#
# For each animal:#
for(i in 1:n_aminals) {#
#
    # Pick a random start position from the square in which the circular continent sits:#
    start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
    # Record distance from centre of continent:#
    start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
#
    # If the starting point is not on the circular continent:#
    if(start_distances[i] > continent_radius) {#
#
        # Whilst the starting point is not on the circular continent:#
        while(start_distances[i] > continent_radius) {#
#
            # Pick a new starting point:#
            start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
            # Record distance from centre of continent:#
            start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
#
        }#
#
    }#
#
    # Store point as start position (now we know it is safely on the continent:#
    start_positions <- rbind(start_positions, start_position)#
#
}#
#
# Ossify start positions now as they will get overwritten later:#
ossified_start_positions <- start_positions#
#
# For each time step:#
for(i in 1:niter) {#
#
    # For each organism:#
    for(j in 1:n_aminals) {#
#
        # Draw a random bearing for the next move:#
        bearing <- runif(1, 0, 360)#
#
        # Draw a random distance for the next move:#
        distance <- abs(rnorm(1, 0, stepsize_sd))#
#
        # Calculate the new position of the organism following the move:#
        new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
        # If draw means leaving continent:#
        if(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
#
            # If response to leaving continent is to redraw:#
            if(response == "redraw") {#
#
                # As long as the draw removes the taxon from the continent:#
                while(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
#
                    # Redraw the bearing:#
                    bearing <- runif(1, 0, 360)#
#
                    # Redraw the distance:#
                    distance <- abs(rnorm(1, 0, stepsize_sd))#
#
                    # Calculate the new position:#
                    new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
                }#
#
                # Overwrite start positions:#
                start_positions[j, ] <- unlist(new_position)#
#
                # Record distance from centre of continent:#
                end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
            # If response to leaving continent is not to redraw (i.e., is to bounce off of, or stop at, continent edge):#
            } else {#
#
# FIND COLLISION POINT STARTS HERE:#
#
                # Scalar which describes the proportion of the disatnce the organism has to travel before colliding with the continent edge:#
                distance_modifier <- 0.5#
#
                # Starting stepsize (will shrink as answer is honed in on more precisely):#
                stepsize <- 0.1#
#
                # Get starting new position (that will eb overwritten until the collision point is found):#
                new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
#
                # Whilst the collision point has not been found:#
                while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
#
                    # Record current distance of new position from centre of continent:#
                    current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
                    # Do we need to increase the distance modifier value?:#
                    if(current_distance_from_centre < continent_radius) {#
#
                        # Create potential better value by adding step size to modifier:#
                        limit <- distance_modifier + stepsize#
#
                    # Or do we need to decrease the degree modifier value?:#
                    } else {#
#
                        # Create potential better value by subtracting step size from modifier:#
                        limit <- distance_modifier - stepsize#
#
                    }#
#
                    # Store the new new position (so we can ask if this is better):#
                    new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
#
                    # Get new distance from continent centre based on potential better modifer:#
                    new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
                    # If new distance is closer to continent radius:#
                    if(abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)) {#
#
                        # Update new position:#
                        new_position <- new_new_position#
#
                        # Update distance modifier itself:#
                        distance_modifier <- limit#
#
                    # If current distance is stil our best estimate:#
                    } else {#
#
                        # Shrink the step size so we can hone in closer:#
                        stepsize <- stepsize * 0.1#
#
                    }#
#
                }#
#
# FIND COLLISION POINT ENDS HERE:#
#
                # If response to hitting a continent edge is to bounce off it:#
                if(response == "bounce") {#
#
                    # Get the remaining distance of the step:#
                    remaining_distance <- as.vector(distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat))#
#
                    # Get the bearing to the centre of the continent from the colision point:#
                    bearing_to_centre <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]))#
#
                    # Get the bearing to the start of the dispersal step from the colision point:#
                    bearing_to_start <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, start_positions[j, 1], start_positions[j, 2]))#
#
                    # Get the difference between these two bearings:#
                    bearing_difference <- min(c(abs(bearing_to_start - bearing_to_centre), 360 - abs(bearing_to_start - bearing_to_centre)))#
#
                    # If bearing difference should be subtracted to get new "bounce" bearing:#
                    if(all.equal((bearing_to_centre + bearing_difference) %% 360, bearing_to_start) == TRUE) {#
#
                        # Get new "bounce" bearing:#
                        bearing_to_end <- (bearing_to_centre - bearing_difference) %% 360#
#
                    # If bearing difference should be added to get new "bounce" bearing:#
                    } else {#
#
                        # Get new "bounce" bearing:#
                        bearing_to_end <- (bearing_to_centre + bearing_difference) %% 360#
#
                    }#
#
                    # Record actual new position (after bounce):#
                    new_position <- EndPoint(new_position$long, new_position$lat, bearing_to_end, remaining_distance)[c("long", "lat")]#
#
                    # Overwrite start positions:#
                    start_positions[j, ] <- unlist(new_position)#
#
                    # Record distance from centre of continent:#
                    end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
                    # Little conditional to catch a second collision (does not do what it should, this is just a test to see if it happens):#
                    if(end_distances[j] > continent_radius) stop("Fallen off after bouncing!")#
#
                }#
#
                # If response to hitting a continent edge is to stick to it:#
                if(response == "stop") {#
#
                    # Overwrite start positions:#
                    start_positions[j, ] <- unlist(new_position)#
#
                    # Record distance from centre of continent:#
                    end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
                }#
#
            }#
#
        # If draw means staying on continent:#
        } else {#
#
            # Overwrite start positions:#
            start_positions[j, ] <- unlist(new_position)#
#
            # Record distance from centre of continent:#
            end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
        }#
#
    }#
#
}#
#
end_time <- Sys.time()#
#
end_time - start_time
# Load maps library:#
library(maps)#
#
# Set Earth radius in kilometres:#
EarthRad <- 6367.4447#
#
# Set number of time steps to run simulation for:#
niter <- 100#
#
# Set number of animals to run simulation for:#
n_aminals <- 10000#
#
# Set standard deviation of step size for dispersal in kilometres:#
stepsize_sd <- 100#
#
# Set centre of continent (long, lat):#
continent_centre <- c(0, 0)#
#
# Set radius of continent in kilometres:#
continent_radius <- 2000#
#
# Create empty matrix to store start positions (long, lat) of each animal:#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
# Create vectors to store distances from continent centre at beginning and end of simlation:#
end_distances <- start_distances <- vector(mode="numeric")#
#
# Pick a response type (one of "bounce", "redraw", or "stop")#
response <- "bounce"#
#
start_time <- Sys.time()#
#
# For each animal:#
for(i in 1:n_aminals) {#
#
    # Pick a random start position from the square in which the circular continent sits:#
    start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
    # Record distance from centre of continent:#
    start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
#
    # If the starting point is not on the circular continent:#
    if(start_distances[i] > continent_radius) {#
#
        # Whilst the starting point is not on the circular continent:#
        while(start_distances[i] > continent_radius) {#
#
            # Pick a new starting point:#
            start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
            # Record distance from centre of continent:#
            start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
#
        }#
#
    }#
#
    # Store point as start position (now we know it is safely on the continent:#
    start_positions <- rbind(start_positions, start_position)#
#
}#
#
# Ossify start positions now as they will get overwritten later:#
ossified_start_positions <- start_positions#
#
# For each time step:#
for(i in 1:niter) {#
#
    # For each organism:#
    for(j in 1:n_aminals) {#
#
        # Draw a random bearing for the next move:#
        bearing <- runif(1, 0, 360)#
#
        # Draw a random distance for the next move:#
        distance <- abs(rnorm(1, 0, stepsize_sd))#
#
        # Calculate the new position of the organism following the move:#
        new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
        # If draw means leaving continent:#
        if(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
#
            # If response to leaving continent is to redraw:#
            if(response == "redraw") {#
#
                # As long as the draw removes the taxon from the continent:#
                while(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
#
                    # Redraw the bearing:#
                    bearing <- runif(1, 0, 360)#
#
                    # Redraw the distance:#
                    distance <- abs(rnorm(1, 0, stepsize_sd))#
#
                    # Calculate the new position:#
                    new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
                }#
#
                # Overwrite start positions:#
                start_positions[j, ] <- unlist(new_position)#
#
                # Record distance from centre of continent:#
                end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
            # If response to leaving continent is not to redraw (i.e., is to bounce off of, or stop at, continent edge):#
            } else {#
#
# FIND COLLISION POINT STARTS HERE:#
#
                # Scalar which describes the proportion of the disatnce the organism has to travel before colliding with the continent edge:#
                distance_modifier <- 0.5#
#
                # Starting stepsize (will shrink as answer is honed in on more precisely):#
                stepsize <- 0.1#
#
                # Get starting new position (that will eb overwritten until the collision point is found):#
                new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
#
                # Whilst the collision point has not been found:#
                while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
#
                    # Record current distance of new position from centre of continent:#
                    current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
                    # Do we need to increase the distance modifier value?:#
                    if(current_distance_from_centre < continent_radius) {#
#
                        # Create potential better value by adding step size to modifier:#
                        limit <- distance_modifier + stepsize#
#
                    # Or do we need to decrease the degree modifier value?:#
                    } else {#
#
                        # Create potential better value by subtracting step size from modifier:#
                        limit <- distance_modifier - stepsize#
#
                    }#
#
                    # Store the new new position (so we can ask if this is better):#
                    new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
#
                    # Get new distance from continent centre based on potential better modifer:#
                    new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
                    # If new distance is closer to continent radius:#
                    if(abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)) {#
#
                        # Update new position:#
                        new_position <- new_new_position#
#
                        # Update distance modifier itself:#
                        distance_modifier <- limit#
#
                    # If current distance is stil our best estimate:#
                    } else {#
#
                        # Shrink the step size so we can hone in closer:#
                        stepsize <- stepsize * 0.1#
#
                    }#
#
                }#
#
# FIND COLLISION POINT ENDS HERE:#
#
                # If response to hitting a continent edge is to bounce off it:#
                if(response == "bounce") {#
#
                    # Get the remaining distance of the step:#
                    remaining_distance <- as.vector(distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat))#
#
                    # Get the bearing to the centre of the continent from the colision point:#
                    bearing_to_centre <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]))#
#
                    # Get the bearing to the start of the dispersal step from the colision point:#
                    bearing_to_start <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, start_positions[j, 1], start_positions[j, 2]))#
#
                    # Get the difference between these two bearings:#
                    bearing_difference <- min(c(abs(bearing_to_start - bearing_to_centre), 360 - abs(bearing_to_start - bearing_to_centre)))#
#
                    # If bearing difference should be subtracted to get new "bounce" bearing:#
                    if(all.equal((bearing_to_centre + bearing_difference) %% 360, bearing_to_start) == TRUE) {#
#
                        # Get new "bounce" bearing:#
                        bearing_to_end <- (bearing_to_centre - bearing_difference) %% 360#
#
                    # If bearing difference should be added to get new "bounce" bearing:#
                    } else {#
#
                        # Get new "bounce" bearing:#
                        bearing_to_end <- (bearing_to_centre + bearing_difference) %% 360#
#
                    }#
#
                    # Record actual new position (after bounce):#
                    new_position <- EndPoint(new_position$long, new_position$lat, bearing_to_end, remaining_distance)[c("long", "lat")]#
#
                    # Overwrite start positions:#
                    start_positions[j, ] <- unlist(new_position)#
#
                    # Record distance from centre of continent:#
                    end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
                    # Little conditional to catch a second collision (does not do what it should, this is just a test to see if it happens):#
                    if(end_distances[j] > continent_radius) stop("Fallen off after bouncing!")#
#
                }#
#
                # If response to hitting a continent edge is to stick to it:#
                if(response == "stop") {#
#
                    # Overwrite start positions:#
                    start_positions[j, ] <- unlist(new_position)#
#
                    # Record distance from centre of continent:#
                    end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
                }#
#
            }#
#
        # If draw means staying on continent:#
        } else {#
#
            # Overwrite start positions:#
            start_positions[j, ] <- unlist(new_position)#
#
            # Record distance from centre of continent:#
            end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
        }#
#
    }#
#
}#
#
end_time <- Sys.time()#
#
end_time - start_time
# Load maps library:#
library(maps)#
#
# Set Earth radius in kilometres:#
EarthRad <- 6367.4447#
#
# Set number of time steps to run simulation for:#
niter <- 100#
#
# Set number of animals to run simulation for:#
n_aminals <- 10000#
#
# Set standard deviation of step size for dispersal in kilometres:#
stepsize_sd <- 100#
#
# Set centre of continent (long, lat):#
continent_centre <- c(0, 0)#
#
# Set radius of continent in kilometres:#
continent_radius <- 2000#
#
# Create empty matrix to store start positions (long, lat) of each animal:#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
# Create vectors to store distances from continent centre at beginning and end of simlation:#
end_distances <- start_distances <- vector(mode="numeric")#
#
# Pick a response type (one of "bounce", "redraw", or "stop")#
response <- "bounce"#
#
start_time <- Sys.time()#
#
# For each animal:#
for(i in 1:n_aminals) {#
#
    # Pick a random start position from the square in which the circular continent sits:#
    start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
    # Record distance from centre of continent:#
    start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
#
    # If the starting point is not on the circular continent:#
    if(start_distances[i] > continent_radius) {#
#
        # Whilst the starting point is not on the circular continent:#
        while(start_distances[i] > continent_radius) {#
#
            # Pick a new starting point:#
            start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
            # Record distance from centre of continent:#
            start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
#
        }#
#
    }#
#
    # Store point as start position (now we know it is safely on the continent:#
    start_positions <- rbind(start_positions, start_position)#
#
}#
#
# Ossify start positions now as they will get overwritten later:#
ossified_start_positions <- start_positions#
#
# For each time step:#
for(i in 1:niter) {#
#
    # For each organism:#
    for(j in 1:n_aminals) {#
#
        # Draw a random bearing for the next move:#
        bearing <- runif(1, 0, 360)#
#
        # Draw a random distance for the next move:#
        distance <- abs(rnorm(1, 0, stepsize_sd))#
#
        # Calculate the new position of the organism following the move:#
        new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
        # If draw means leaving continent:#
        if(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
#
            # If response to leaving continent is to redraw:#
            if(response == "redraw") {#
#
                # As long as the draw removes the taxon from the continent:#
                while(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
#
                    # Redraw the bearing:#
                    bearing <- runif(1, 0, 360)#
#
                    # Redraw the distance:#
                    distance <- abs(rnorm(1, 0, stepsize_sd))#
#
                    # Calculate the new position:#
                    new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
                }#
#
                # Overwrite start positions:#
                start_positions[j, ] <- unlist(new_position)#
#
                # Record distance from centre of continent:#
                end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
            # If response to leaving continent is not to redraw (i.e., is to bounce off of, or stop at, continent edge):#
            } else {#
#
# FIND COLLISION POINT STARTS HERE:#
#
                # Scalar which describes the proportion of the disatnce the organism has to travel before colliding with the continent edge:#
                distance_modifier <- 0.5#
#
                # Starting stepsize (will shrink as answer is honed in on more precisely):#
                stepsize <- 0.1#
#
                # Get starting new position (that will eb overwritten until the collision point is found):#
                new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
#
                # Whilst the collision point has not been found:#
                while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
#
                    # Record current distance of new position from centre of continent:#
                    current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
                    # Do we need to increase the distance modifier value?:#
                    if(current_distance_from_centre < continent_radius) {#
#
                        # Create potential better value by adding step size to modifier:#
                        limit <- distance_modifier + stepsize#
#
                    # Or do we need to decrease the degree modifier value?:#
                    } else {#
#
                        # Create potential better value by subtracting step size from modifier:#
                        limit <- distance_modifier - stepsize#
#
                    }#
#
                    # Store the new new position (so we can ask if this is better):#
                    new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
#
                    # Get new distance from continent centre based on potential better modifer:#
                    new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
                    # If new distance is closer to continent radius:#
                    if(abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)) {#
#
                        # Update new position:#
                        new_position <- new_new_position#
#
                        # Update distance modifier itself:#
                        distance_modifier <- limit#
#
                    # If current distance is stil our best estimate:#
                    } else {#
#
                        # Shrink the step size so we can hone in closer:#
                        stepsize <- stepsize * 0.1#
#
                    }#
#
                }#
#
# FIND COLLISION POINT ENDS HERE:#
#
                # If response to hitting a continent edge is to bounce off it:#
                if(response == "bounce") {#
#
                    # Get the remaining distance of the step:#
                    remaining_distance <- as.vector(distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat))#
#
                    # Get the bearing to the centre of the continent from the colision point:#
                    bearing_to_centre <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]))#
#
                    # Get the bearing to the start of the dispersal step from the colision point:#
                    bearing_to_start <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, start_positions[j, 1], start_positions[j, 2]))#
#
                    # Get the difference between these two bearings:#
                    bearing_difference <- min(c(abs(bearing_to_start - bearing_to_centre), 360 - abs(bearing_to_start - bearing_to_centre)))#
#
                    # If bearing difference should be subtracted to get new "bounce" bearing:#
                    if(all.equal((bearing_to_centre + bearing_difference) %% 360, bearing_to_start) == TRUE) {#
#
                        # Get new "bounce" bearing:#
                        bearing_to_end <- (bearing_to_centre - bearing_difference) %% 360#
#
                    # If bearing difference should be added to get new "bounce" bearing:#
                    } else {#
#
                        # Get new "bounce" bearing:#
                        bearing_to_end <- (bearing_to_centre + bearing_difference) %% 360#
#
                    }#
#
                    # Record actual new position (after bounce):#
                    new_position <- EndPoint(new_position$long, new_position$lat, bearing_to_end, remaining_distance)[c("long", "lat")]#
#
                    # Overwrite start positions:#
                    start_positions[j, ] <- unlist(new_position)#
#
                    # Record distance from centre of continent:#
                    end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
                    # Little conditional to catch a second collision (does not do what it should, this is just a test to see if it happens):#
                    if(end_distances[j] > continent_radius) stop("Fallen off after bouncing!")#
#
                }#
#
                # If response to hitting a continent edge is to stick to it:#
                if(response == "stop") {#
#
                    # Overwrite start positions:#
                    start_positions[j, ] <- unlist(new_position)#
#
                    # Record distance from centre of continent:#
                    end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
                }#
#
            }#
#
        # If draw means staying on continent:#
        } else {#
#
            # Overwrite start positions:#
            start_positions[j, ] <- unlist(new_position)#
#
            # Record distance from centre of continent:#
            end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
        }#
#
    }#
#
}#
#
end_time <- Sys.time()#
#
end_time - start_time
# Load maps library:#
library(maps)#
#
# Set Earth radius in kilometres:#
EarthRad <- 6367.4447#
#
# Set number of time steps to run simulation for:#
niter <- 100#
#
# Set number of animals to run simulation for:#
n_aminals <- 10000#
#
# Set standard deviation of step size for dispersal in kilometres:#
stepsize_sd <- 100#
#
# Set centre of continent (long, lat):#
continent_centre <- c(0, 0)#
#
# Set radius of continent in kilometres:#
continent_radius <- 2000#
#
# Create empty matrix to store start positions (long, lat) of each animal:#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
# Create vectors to store distances from continent centre at beginning and end of simlation:#
end_distances <- start_distances <- vector(mode="numeric")#
#
# Pick a response type (one of "bounce", "redraw", or "stop")#
response <- "bounce"#
#
start_time <- Sys.time()#
#
# For each animal:#
for(i in 1:n_aminals) {#
#
    # Pick a random start position from the square in which the circular continent sits:#
    start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
    # Record distance from centre of continent:#
    start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
#
    # If the starting point is not on the circular continent:#
    if(start_distances[i] > continent_radius) {#
#
        # Whilst the starting point is not on the circular continent:#
        while(start_distances[i] > continent_radius) {#
#
            # Pick a new starting point:#
            start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
            # Record distance from centre of continent:#
            start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
#
        }#
#
    }#
#
    # Store point as start position (now we know it is safely on the continent:#
    start_positions <- rbind(start_positions, start_position)#
#
}#
#
# Ossify start positions now as they will get overwritten later:#
ossified_start_positions <- start_positions#
#
# For each time step:#
for(i in 1:niter) {#
#
    # For each organism:#
    for(j in 1:n_aminals) {#
#
        # Draw a random bearing for the next move:#
        bearing <- runif(1, 0, 360)#
#
        # Draw a random distance for the next move:#
        distance <- abs(rnorm(1, 0, stepsize_sd))#
#
        # Calculate the new position of the organism following the move:#
        new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
        # If draw means leaving continent:#
        if(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
#
            # If response to leaving continent is to redraw:#
            if(response == "redraw") {#
#
                # As long as the draw removes the taxon from the continent:#
                while(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
#
                    # Redraw the bearing:#
                    bearing <- runif(1, 0, 360)#
#
                    # Redraw the distance:#
                    distance <- abs(rnorm(1, 0, stepsize_sd))#
#
                    # Calculate the new position:#
                    new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
                }#
#
                # Overwrite start positions:#
                start_positions[j, ] <- unlist(new_position)#
#
                # Record distance from centre of continent:#
                end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
            # If response to leaving continent is not to redraw (i.e., is to bounce off of, or stop at, continent edge):#
            } else {#
#
# FIND COLLISION POINT STARTS HERE:#
#
                # Scalar which describes the proportion of the disatnce the organism has to travel before colliding with the continent edge:#
                distance_modifier <- 0.5#
#
                # Starting stepsize (will shrink as answer is honed in on more precisely):#
                stepsize <- 0.1#
#
                # Get starting new position (that will eb overwritten until the collision point is found):#
                new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
#
                # Whilst the collision point has not been found:#
                while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
#
                    # Record current distance of new position from centre of continent:#
                    current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
                    # Do we need to increase the distance modifier value?:#
                    if(current_distance_from_centre < continent_radius) {#
#
                        # Create potential better value by adding step size to modifier:#
                        limit <- distance_modifier + stepsize#
#
                    # Or do we need to decrease the degree modifier value?:#
                    } else {#
#
                        # Create potential better value by subtracting step size from modifier:#
                        limit <- distance_modifier - stepsize#
#
                    }#
#
                    # Store the new new position (so we can ask if this is better):#
                    new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
#
                    # Get new distance from continent centre based on potential better modifer:#
                    new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
                    # If new distance is closer to continent radius:#
                    if(abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)) {#
#
                        # Update new position:#
                        new_position <- new_new_position#
#
                        # Update distance modifier itself:#
                        distance_modifier <- limit#
#
                    # If current distance is stil our best estimate:#
                    } else {#
#
                        # Shrink the step size so we can hone in closer:#
                        stepsize <- stepsize * 0.1#
#
                    }#
#
                }#
#
# FIND COLLISION POINT ENDS HERE:#
#
                # If response to hitting a continent edge is to bounce off it:#
                if(response == "bounce") {#
#
                    # Get the remaining distance of the step:#
                    remaining_distance <- as.vector(distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat))#
#
                    # Get the bearing to the centre of the continent from the colision point:#
                    bearing_to_centre <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]))#
#
                    # Get the bearing to the start of the dispersal step from the colision point:#
                    bearing_to_start <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, start_positions[j, 1], start_positions[j, 2]))#
#
                    # Get the difference between these two bearings:#
                    bearing_difference <- min(c(abs(bearing_to_start - bearing_to_centre), 360 - abs(bearing_to_start - bearing_to_centre)))#
#
                    # If bearing difference should be subtracted to get new "bounce" bearing:#
                    if(all.equal((bearing_to_centre + bearing_difference) %% 360, bearing_to_start) == TRUE) {#
#
                        # Get new "bounce" bearing:#
                        bearing_to_end <- (bearing_to_centre - bearing_difference) %% 360#
#
                    # If bearing difference should be added to get new "bounce" bearing:#
                    } else {#
#
                        # Get new "bounce" bearing:#
                        bearing_to_end <- (bearing_to_centre + bearing_difference) %% 360#
#
                    }#
#
                    # Record actual new position (after bounce):#
                    new_position <- EndPoint(new_position$long, new_position$lat, bearing_to_end, remaining_distance)[c("long", "lat")]#
#
                    # Overwrite start positions:#
                    start_positions[j, ] <- unlist(new_position)#
#
                    # Record distance from centre of continent:#
                    end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
                    # Little conditional to catch a second collision (does not do what it should, this is just a test to see if it happens):#
                    if(end_distances[j] > continent_radius) stop("Fallen off after bouncing!")#
#
                }#
#
                # If response to hitting a continent edge is to stick to it:#
                if(response == "stop") {#
#
                    # Overwrite start positions:#
                    start_positions[j, ] <- unlist(new_position)#
#
                    # Record distance from centre of continent:#
                    end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
                }#
#
            }#
#
        # If draw means staying on continent:#
        } else {#
#
            # Overwrite start positions:#
            start_positions[j, ] <- unlist(new_position)#
#
            # Record distance from centre of continent:#
            end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
        }#
#
    }#
#
}#
#
end_time <- Sys.time()#
#
end_time - start_time
# Load maps library:#
library(maps)#
#
# Set Earth radius in kilometres:#
EarthRad <- 6367.4447#
#
# Set number of time steps to run simulation for:#
niter <- 100#
#
# Set number of animals to run simulation for:#
n_aminals <- 10000#
#
# Set standard deviation of step size for dispersal in kilometres:#
stepsize_sd <- 100#
#
# Set centre of continent (long, lat):#
continent_centre <- c(0, 0)#
#
# Set radius of continent in kilometres:#
continent_radius <- 2000#
#
# Create empty matrix to store start positions (long, lat) of each animal:#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
# Create vectors to store distances from continent centre at beginning and end of simlation:#
end_distances <- start_distances <- vector(mode="numeric")#
#
# Pick a response type (one of "bounce", "redraw", or "stop")#
response <- "bounce"#
#
start_time <- Sys.time()#
#
# For each animal:#
for(i in 1:n_aminals) {#
#
    # Pick a random start position from the square in which the circular continent sits:#
    start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
    # Record distance from centre of continent:#
    start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
#
    # If the starting point is not on the circular continent:#
    if(start_distances[i] > continent_radius) {#
#
        # Whilst the starting point is not on the circular continent:#
        while(start_distances[i] > continent_radius) {#
#
            # Pick a new starting point:#
            start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
            # Record distance from centre of continent:#
            start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
#
        }#
#
    }#
#
    # Store point as start position (now we know it is safely on the continent:#
    start_positions <- rbind(start_positions, start_position)#
#
}#
#
# Ossify start positions now as they will get overwritten later:#
ossified_start_positions <- start_positions#
#
# For each time step:#
for(i in 1:niter) {#
#
    # For each organism:#
    for(j in 1:n_aminals) {#
#
        # Draw a random bearing for the next move:#
        bearing <- runif(1, 0, 360)#
#
        # Draw a random distance for the next move:#
        distance <- abs(rnorm(1, 0, stepsize_sd))#
#
        # Calculate the new position of the organism following the move:#
        new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
        # If draw means leaving continent:#
        if(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
#
            # If response to leaving continent is to redraw:#
            if(response == "redraw") {#
#
                # As long as the draw removes the taxon from the continent:#
                while(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
#
                    # Redraw the bearing:#
                    bearing <- runif(1, 0, 360)#
#
                    # Redraw the distance:#
                    distance <- abs(rnorm(1, 0, stepsize_sd))#
#
                    # Calculate the new position:#
                    new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
                }#
#
                # Overwrite start positions:#
                start_positions[j, ] <- unlist(new_position)#
#
                # Record distance from centre of continent:#
                end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
            # If response to leaving continent is not to redraw (i.e., is to bounce off of, or stop at, continent edge):#
            } else {#
#
# FIND COLLISION POINT STARTS HERE:#
#
                # Scalar which describes the proportion of the disatnce the organism has to travel before colliding with the continent edge:#
                distance_modifier <- 0.5#
#
                # Starting stepsize (will shrink as answer is honed in on more precisely):#
                stepsize <- 0.1#
#
                # Get starting new position (that will eb overwritten until the collision point is found):#
                new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
#
                # Whilst the collision point has not been found:#
                while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
#
                    # Record current distance of new position from centre of continent:#
                    current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
                    # Do we need to increase the distance modifier value?:#
                    if(current_distance_from_centre < continent_radius) {#
#
                        # Create potential better value by adding step size to modifier:#
                        limit <- distance_modifier + stepsize#
#
                    # Or do we need to decrease the degree modifier value?:#
                    } else {#
#
                        # Create potential better value by subtracting step size from modifier:#
                        limit <- distance_modifier - stepsize#
#
                    }#
#
                    # Store the new new position (so we can ask if this is better):#
                    new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
#
                    # Get new distance from continent centre based on potential better modifer:#
                    new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
                    # If new distance is closer to continent radius:#
                    if(abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)) {#
#
                        # Update new position:#
                        new_position <- new_new_position#
#
                        # Update distance modifier itself:#
                        distance_modifier <- limit#
#
                    # If current distance is stil our best estimate:#
                    } else {#
#
                        # Shrink the step size so we can hone in closer:#
                        stepsize <- stepsize * 0.1#
#
                    }#
#
                }#
#
# FIND COLLISION POINT ENDS HERE:#
#
                # If response to hitting a continent edge is to bounce off it:#
                if(response == "bounce") {#
#
                    # Get the remaining distance of the step:#
                    remaining_distance <- as.vector(distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat))#
#
                    # Get the bearing to the centre of the continent from the colision point:#
                    bearing_to_centre <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]))#
#
                    # Get the bearing to the start of the dispersal step from the colision point:#
                    bearing_to_start <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, start_positions[j, 1], start_positions[j, 2]))#
#
                    # Get the difference between these two bearings:#
                    bearing_difference <- min(c(abs(bearing_to_start - bearing_to_centre), 360 - abs(bearing_to_start - bearing_to_centre)))#
#
                    # If bearing difference should be subtracted to get new "bounce" bearing:#
                    if(all.equal((bearing_to_centre + bearing_difference) %% 360, bearing_to_start) == TRUE) {#
#
                        # Get new "bounce" bearing:#
                        bearing_to_end <- (bearing_to_centre - bearing_difference) %% 360#
#
                    # If bearing difference should be added to get new "bounce" bearing:#
                    } else {#
#
                        # Get new "bounce" bearing:#
                        bearing_to_end <- (bearing_to_centre + bearing_difference) %% 360#
#
                    }#
#
                    # Record actual new position (after bounce):#
                    new_position <- EndPoint(new_position$long, new_position$lat, bearing_to_end, remaining_distance)[c("long", "lat")]#
#
                    # Overwrite start positions:#
                    start_positions[j, ] <- unlist(new_position)#
#
                    # Record distance from centre of continent:#
                    end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
                    # Little conditional to catch a second collision (does not do what it should, this is just a test to see if it happens):#
                    if(end_distances[j] > continent_radius) stop("Fallen off after bouncing!")#
#
                }#
#
                # If response to hitting a continent edge is to stick to it:#
                if(response == "stop") {#
#
                    # Overwrite start positions:#
                    start_positions[j, ] <- unlist(new_position)#
#
                    # Record distance from centre of continent:#
                    end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
                }#
#
            }#
#
        # If draw means staying on continent:#
        } else {#
#
            # Overwrite start positions:#
            start_positions[j, ] <- unlist(new_position)#
#
            # Record distance from centre of continent:#
            end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
        }#
#
    }#
#
}#
#
end_time <- Sys.time()#
#
end_time - start_time
end_distances
end_distances[j]
# Load maps library:#
library(maps)#
#
# Set Earth radius in kilometres:#
EarthRad <- 6367.4447#
#
# Set number of time steps to run simulation for:#
niter <- 100#
#
# Set number of animals to run simulation for:#
n_aminals <- 10000#
#
# Set standard deviation of step size for dispersal in kilometres:#
stepsize_sd <- 100#
#
# Set centre of continent (long, lat):#
continent_centre <- c(0, 0)#
#
# Set radius of continent in kilometres:#
continent_radius <- 2000#
#
# Create empty matrix to store start positions (long, lat) of each animal:#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
# Create vectors to store distances from continent centre at beginning and end of simlation:#
end_distances <- start_distances <- vector(mode="numeric")#
#
# Pick a response type (one of "bounce", "redraw", or "stop")#
response <- "bounce"#
#
start_time <- Sys.time()#
#
# For each animal:#
for(i in 1:n_aminals) {#
#
    # Pick a random start position from the square in which the circular continent sits:#
    start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
    # Record distance from centre of continent:#
    start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
#
    # If the starting point is not on the circular continent:#
    if(start_distances[i] > continent_radius) {#
#
        # Whilst the starting point is not on the circular continent:#
        while(start_distances[i] > continent_radius) {#
#
            # Pick a new starting point:#
            start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
            # Record distance from centre of continent:#
            start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
#
        }#
#
    }#
#
    # Store point as start position (now we know it is safely on the continent:#
    start_positions <- rbind(start_positions, start_position)#
#
}#
#
# Ossify start positions now as they will get overwritten later:#
ossified_start_positions <- start_positions#
#
# For each time step:#
for(i in 1:niter) {#
#
    # For each organism:#
    for(j in 1:n_aminals) {#
#
        # Draw a random bearing for the next move:#
        bearing <- runif(1, 0, 360)#
#
        # Draw a random distance for the next move:#
        distance <- abs(rnorm(1, 0, stepsize_sd))#
#
        # Calculate the new position of the organism following the move:#
        new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
        # If draw means leaving continent:#
        if(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
#
            # If response to leaving continent is to redraw:#
            if(response == "redraw") {#
#
                # As long as the draw removes the taxon from the continent:#
                while(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
#
                    # Redraw the bearing:#
                    bearing <- runif(1, 0, 360)#
#
                    # Redraw the distance:#
                    distance <- abs(rnorm(1, 0, stepsize_sd))#
#
                    # Calculate the new position:#
                    new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
                }#
#
                # Overwrite start positions:#
                start_positions[j, ] <- unlist(new_position)#
#
                # Record distance from centre of continent:#
                end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
            # If response to leaving continent is not to redraw (i.e., is to bounce off of, or stop at, continent edge):#
            } else {#
#
# FIND COLLISION POINT STARTS HERE:#
#
                # Scalar which describes the proportion of the disatnce the organism has to travel before colliding with the continent edge:#
                distance_modifier <- 0.5#
#
                # Starting stepsize (will shrink as answer is honed in on more precisely):#
                stepsize <- 0.1#
#
                # Get starting new position (that will eb overwritten until the collision point is found):#
                new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
#
                # Whilst the collision point has not been found:#
                while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
#
                    # Record current distance of new position from centre of continent:#
                    current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
                    # Do we need to increase the distance modifier value?:#
                    if(current_distance_from_centre < continent_radius) {#
#
                        # Create potential better value by adding step size to modifier:#
                        limit <- distance_modifier + stepsize#
#
                    # Or do we need to decrease the degree modifier value?:#
                    } else {#
#
                        # Create potential better value by subtracting step size from modifier:#
                        limit <- distance_modifier - stepsize#
#
                    }#
#
                    # Store the new new position (so we can ask if this is better):#
                    new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
#
                    # Get new distance from continent centre based on potential better modifer:#
                    new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
                    # If new distance is closer to continent radius:#
                    if(abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)) {#
#
                        # Update new position:#
                        new_position <- new_new_position#
#
                        # Update distance modifier itself:#
                        distance_modifier <- limit#
#
                    # If current distance is stil our best estimate:#
                    } else {#
#
                        # Shrink the step size so we can hone in closer:#
                        stepsize <- stepsize * 0.1#
#
                    }#
#
                }#
#
# FIND COLLISION POINT ENDS HERE:#
#
                # If response to hitting a continent edge is to bounce off it:#
                if(response == "bounce") {#
#
                    # Get the remaining distance of the step:#
                    remaining_distance <- as.vector(distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat))#
#
                    # Get the bearing to the centre of the continent from the colision point:#
                    bearing_to_centre <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]))#
#
                    # Get the bearing to the start of the dispersal step from the colision point:#
                    bearing_to_start <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, start_positions[j, 1], start_positions[j, 2]))#
#
                    # Get the difference between these two bearings:#
                    bearing_difference <- min(c(abs(bearing_to_start - bearing_to_centre), 360 - abs(bearing_to_start - bearing_to_centre)))#
#
                    # If bearing difference should be subtracted to get new "bounce" bearing:#
                    if(all.equal((bearing_to_centre + bearing_difference) %% 360, bearing_to_start) == TRUE) {#
#
                        # Get new "bounce" bearing:#
                        bearing_to_end <- (bearing_to_centre - bearing_difference) %% 360#
#
                    # If bearing difference should be added to get new "bounce" bearing:#
                    } else {#
#
                        # Get new "bounce" bearing:#
                        bearing_to_end <- (bearing_to_centre + bearing_difference) %% 360#
#
                    }#
#
                    # Record actual new position (after bounce):#
                    new_position <- EndPoint(new_position$long, new_position$lat, bearing_to_end, remaining_distance)[c("long", "lat")]#
#
                    # Overwrite start positions:#
                    start_positions[j, ] <- unlist(new_position)#
#
                    # Record distance from centre of continent:#
                    end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
                    # Little conditional to catch a second collision (does not do what it should, this is just a test to see if it happens):#
                    if(end_distances[j] > continent_radius) print("Fallen off after bouncing!")#
#
                }#
#
                # If response to hitting a continent edge is to stick to it:#
                if(response == "stop") {#
#
                    # Overwrite start positions:#
                    start_positions[j, ] <- unlist(new_position)#
#
                    # Record distance from centre of continent:#
                    end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
                }#
#
            }#
#
        # If draw means staying on continent:#
        } else {#
#
            # Overwrite start positions:#
            start_positions[j, ] <- unlist(new_position)#
#
            # Record distance from centre of continent:#
            end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
        }#
#
    }#
#
}#
#
end_time <- Sys.time()#
#
end_time - start_time
# Load maps library:#
library(maps)#
#
# Set Earth radius in kilometres:#
EarthRad <- 6367.4447#
#
# Set number of time steps to run simulation for:#
niter <- 100#
#
# Set number of animals to run simulation for:#
n_aminals <- 10000#
#
# Set standard deviation of step size for dispersal in kilometres:#
stepsize_sd <- 100#
#
# Set centre of continent (long, lat):#
continent_centre <- c(0, 0)#
#
# Set radius of continent in kilometres:#
continent_radius <- 2000#
#
# Create empty matrix to store start positions (long, lat) of each animal:#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
# Create vectors to store distances from continent centre at beginning and end of simlation:#
end_distances <- start_distances <- vector(mode="numeric")#
#
# Pick a response type (one of "bounce", "redraw", or "stop")#
response <- "redraw"#
#
start_time <- Sys.time()#
#
# For each animal:#
for(i in 1:n_aminals) {#
#
    # Pick a random start position from the square in which the circular continent sits:#
    start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
    # Record distance from centre of continent:#
    start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
#
    # If the starting point is not on the circular continent:#
    if(start_distances[i] > continent_radius) {#
#
        # Whilst the starting point is not on the circular continent:#
        while(start_distances[i] > continent_radius) {#
#
            # Pick a new starting point:#
            start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
            # Record distance from centre of continent:#
            start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
#
        }#
#
    }#
#
    # Store point as start position (now we know it is safely on the continent:#
    start_positions <- rbind(start_positions, start_position)#
#
}#
#
# Ossify start positions now as they will get overwritten later:#
ossified_start_positions <- start_positions#
#
# For each time step:#
for(i in 1:niter) {#
#
    # For each organism:#
    for(j in 1:n_aminals) {#
#
        # Draw a random bearing for the next move:#
        bearing <- runif(1, 0, 360)#
#
        # Draw a random distance for the next move:#
        distance <- abs(rnorm(1, 0, stepsize_sd))#
#
        # Calculate the new position of the organism following the move:#
        new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
        # If draw means leaving continent:#
        if(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
#
            # If response to leaving continent is to redraw:#
            if(response == "redraw") {#
#
                # As long as the draw removes the taxon from the continent:#
                while(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
#
                    # Redraw the bearing:#
                    bearing <- runif(1, 0, 360)#
#
                    # Redraw the distance:#
                    distance <- abs(rnorm(1, 0, stepsize_sd))#
#
                    # Calculate the new position:#
                    new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
                }#
#
                # Overwrite start positions:#
                start_positions[j, ] <- unlist(new_position)#
#
                # Record distance from centre of continent:#
                end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
            # If response to leaving continent is not to redraw (i.e., is to bounce off of, or stop at, continent edge):#
            } else {#
#
# FIND COLLISION POINT STARTS HERE:#
#
                # Scalar which describes the proportion of the disatnce the organism has to travel before colliding with the continent edge:#
                distance_modifier <- 0.5#
#
                # Starting stepsize (will shrink as answer is honed in on more precisely):#
                stepsize <- 0.1#
#
                # Get starting new position (that will eb overwritten until the collision point is found):#
                new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
#
                # Whilst the collision point has not been found:#
                while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
#
                    # Record current distance of new position from centre of continent:#
                    current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
                    # Do we need to increase the distance modifier value?:#
                    if(current_distance_from_centre < continent_radius) {#
#
                        # Create potential better value by adding step size to modifier:#
                        limit <- distance_modifier + stepsize#
#
                    # Or do we need to decrease the degree modifier value?:#
                    } else {#
#
                        # Create potential better value by subtracting step size from modifier:#
                        limit <- distance_modifier - stepsize#
#
                    }#
#
                    # Store the new new position (so we can ask if this is better):#
                    new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
#
                    # Get new distance from continent centre based on potential better modifer:#
                    new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
                    # If new distance is closer to continent radius:#
                    if(abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)) {#
#
                        # Update new position:#
                        new_position <- new_new_position#
#
                        # Update distance modifier itself:#
                        distance_modifier <- limit#
#
                    # If current distance is stil our best estimate:#
                    } else {#
#
                        # Shrink the step size so we can hone in closer:#
                        stepsize <- stepsize * 0.1#
#
                    }#
#
                }#
#
# FIND COLLISION POINT ENDS HERE:#
#
                # If response to hitting a continent edge is to bounce off it:#
                if(response == "bounce") {#
#
                    # Get the remaining distance of the step:#
                    remaining_distance <- as.vector(distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat))#
#
                    # Get the bearing to the centre of the continent from the colision point:#
                    bearing_to_centre <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]))#
#
                    # Get the bearing to the start of the dispersal step from the colision point:#
                    bearing_to_start <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, start_positions[j, 1], start_positions[j, 2]))#
#
                    # Get the difference between these two bearings:#
                    bearing_difference <- min(c(abs(bearing_to_start - bearing_to_centre), 360 - abs(bearing_to_start - bearing_to_centre)))#
#
                    # If bearing difference should be subtracted to get new "bounce" bearing:#
                    if(all.equal((bearing_to_centre + bearing_difference) %% 360, bearing_to_start) == TRUE) {#
#
                        # Get new "bounce" bearing:#
                        bearing_to_end <- (bearing_to_centre - bearing_difference) %% 360#
#
                    # If bearing difference should be added to get new "bounce" bearing:#
                    } else {#
#
                        # Get new "bounce" bearing:#
                        bearing_to_end <- (bearing_to_centre + bearing_difference) %% 360#
#
                    }#
#
                    # Record actual new position (after bounce):#
                    new_position <- EndPoint(new_position$long, new_position$lat, bearing_to_end, remaining_distance)[c("long", "lat")]#
#
                    # Overwrite start positions:#
                    start_positions[j, ] <- unlist(new_position)#
#
                    # Record distance from centre of continent:#
                    end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
                    # Little conditional to catch a second collision (does not do what it should, this is just a test to see if it happens):#
                    if(end_distances[j] > continent_radius) print("Fallen off after bouncing!")#
#
                }#
#
                # If response to hitting a continent edge is to stick to it:#
                if(response == "stop") {#
#
                    # Overwrite start positions:#
                    start_positions[j, ] <- unlist(new_position)#
#
                    # Record distance from centre of continent:#
                    end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
                }#
#
            }#
#
        # If draw means staying on continent:#
        } else {#
#
            # Overwrite start positions:#
            start_positions[j, ] <- unlist(new_position)#
#
            # Record distance from centre of continent:#
            end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
        }#
#
    }#
#
}#
#
end_time <- Sys.time()#
#
end_time - start_time
# Load maps library:#
library(maps)#
#
# Set Earth radius in kilometres:#
EarthRad <- 6367.4447#
#
# Set number of time steps to run simulation for:#
niter <- 100#
#
# Set number of animals to run simulation for:#
n_aminals <- 10000#
#
# Set standard deviation of step size for dispersal in kilometres:#
stepsize_sd <- 100#
#
# Set centre of continent (long, lat):#
continent_centre <- c(0, 0)#
#
# Set radius of continent in kilometres:#
continent_radius <- 2000#
#
# Create empty matrix to store start positions (long, lat) of each animal:#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
# Create vectors to store distances from continent centre at beginning and end of simlation:#
end_distances <- start_distances <- vector(mode="numeric")#
#
# Pick a response type (one of "bounce", "redraw", or "stop")#
response <- "stop"#
#
start_time <- Sys.time()#
#
# For each animal:#
for(i in 1:n_aminals) {#
#
    # Pick a random start position from the square in which the circular continent sits:#
    start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
    # Record distance from centre of continent:#
    start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
#
    # If the starting point is not on the circular continent:#
    if(start_distances[i] > continent_radius) {#
#
        # Whilst the starting point is not on the circular continent:#
        while(start_distances[i] > continent_radius) {#
#
            # Pick a new starting point:#
            start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
            # Record distance from centre of continent:#
            start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
#
        }#
#
    }#
#
    # Store point as start position (now we know it is safely on the continent:#
    start_positions <- rbind(start_positions, start_position)#
#
}#
#
# Ossify start positions now as they will get overwritten later:#
ossified_start_positions <- start_positions#
#
# For each time step:#
for(i in 1:niter) {#
#
    # For each organism:#
    for(j in 1:n_aminals) {#
#
        # Draw a random bearing for the next move:#
        bearing <- runif(1, 0, 360)#
#
        # Draw a random distance for the next move:#
        distance <- abs(rnorm(1, 0, stepsize_sd))#
#
        # Calculate the new position of the organism following the move:#
        new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
        # If draw means leaving continent:#
        if(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
#
            # If response to leaving continent is to redraw:#
            if(response == "redraw") {#
#
                # As long as the draw removes the taxon from the continent:#
                while(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
#
                    # Redraw the bearing:#
                    bearing <- runif(1, 0, 360)#
#
                    # Redraw the distance:#
                    distance <- abs(rnorm(1, 0, stepsize_sd))#
#
                    # Calculate the new position:#
                    new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
                }#
#
                # Overwrite start positions:#
                start_positions[j, ] <- unlist(new_position)#
#
                # Record distance from centre of continent:#
                end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
            # If response to leaving continent is not to redraw (i.e., is to bounce off of, or stop at, continent edge):#
            } else {#
#
# FIND COLLISION POINT STARTS HERE:#
#
                # Scalar which describes the proportion of the disatnce the organism has to travel before colliding with the continent edge:#
                distance_modifier <- 0.5#
#
                # Starting stepsize (will shrink as answer is honed in on more precisely):#
                stepsize <- 0.1#
#
                # Get starting new position (that will eb overwritten until the collision point is found):#
                new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
#
                # Whilst the collision point has not been found:#
                while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
#
                    # Record current distance of new position from centre of continent:#
                    current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
                    # Do we need to increase the distance modifier value?:#
                    if(current_distance_from_centre < continent_radius) {#
#
                        # Create potential better value by adding step size to modifier:#
                        limit <- distance_modifier + stepsize#
#
                    # Or do we need to decrease the degree modifier value?:#
                    } else {#
#
                        # Create potential better value by subtracting step size from modifier:#
                        limit <- distance_modifier - stepsize#
#
                    }#
#
                    # Store the new new position (so we can ask if this is better):#
                    new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
#
                    # Get new distance from continent centre based on potential better modifer:#
                    new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
                    # If new distance is closer to continent radius:#
                    if(abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)) {#
#
                        # Update new position:#
                        new_position <- new_new_position#
#
                        # Update distance modifier itself:#
                        distance_modifier <- limit#
#
                    # If current distance is stil our best estimate:#
                    } else {#
#
                        # Shrink the step size so we can hone in closer:#
                        stepsize <- stepsize * 0.1#
#
                    }#
#
                }#
#
# FIND COLLISION POINT ENDS HERE:#
#
                # If response to hitting a continent edge is to bounce off it:#
                if(response == "bounce") {#
#
                    # Get the remaining distance of the step:#
                    remaining_distance <- as.vector(distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat))#
#
                    # Get the bearing to the centre of the continent from the colision point:#
                    bearing_to_centre <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]))#
#
                    # Get the bearing to the start of the dispersal step from the colision point:#
                    bearing_to_start <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, start_positions[j, 1], start_positions[j, 2]))#
#
                    # Get the difference between these two bearings:#
                    bearing_difference <- min(c(abs(bearing_to_start - bearing_to_centre), 360 - abs(bearing_to_start - bearing_to_centre)))#
#
                    # If bearing difference should be subtracted to get new "bounce" bearing:#
                    if(all.equal((bearing_to_centre + bearing_difference) %% 360, bearing_to_start) == TRUE) {#
#
                        # Get new "bounce" bearing:#
                        bearing_to_end <- (bearing_to_centre - bearing_difference) %% 360#
#
                    # If bearing difference should be added to get new "bounce" bearing:#
                    } else {#
#
                        # Get new "bounce" bearing:#
                        bearing_to_end <- (bearing_to_centre + bearing_difference) %% 360#
#
                    }#
#
                    # Record actual new position (after bounce):#
                    new_position <- EndPoint(new_position$long, new_position$lat, bearing_to_end, remaining_distance)[c("long", "lat")]#
#
                    # Overwrite start positions:#
                    start_positions[j, ] <- unlist(new_position)#
#
                    # Record distance from centre of continent:#
                    end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
                    # Little conditional to catch a second collision (does not do what it should, this is just a test to see if it happens):#
                    if(end_distances[j] > continent_radius) print("Fallen off after bouncing!")#
#
                }#
#
                # If response to hitting a continent edge is to stick to it:#
                if(response == "stop") {#
#
                    # Overwrite start positions:#
                    start_positions[j, ] <- unlist(new_position)#
#
                    # Record distance from centre of continent:#
                    end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
                }#
#
            }#
#
        # If draw means staying on continent:#
        } else {#
#
            # Overwrite start positions:#
            start_positions[j, ] <- unlist(new_position)#
#
            # Record distance from centre of continent:#
            end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
        }#
#
    }#
#
}#
#
end_time <- Sys.time()#
#
end_time - start_time#
#
# Redraw: Time difference of 5.047525 mins#
# Stop:
# Load maps library:#
library(maps)#
#
# Set Earth radius in kilometres:#
EarthRad <- 6367.4447#
#
# Set number of time steps to run simulation for:#
niter <- 100#
#
# Set number of animals to run simulation for:#
n_aminals <- 10000#
#
# Set standard deviation of step size for dispersal in kilometres:#
stepsize_sd <- 100#
#
# Set centre of continent (long, lat):#
continent_centre <- c(0, 0)#
#
# Set radius of continent in kilometres:#
continent_radius <- 2000#
#
# Create empty matrix to store start positions (long, lat) of each animal:#
start_positions <- matrix(nrow = 0, ncol = 2)#
#
# Create vectors to store distances from continent centre at beginning and end of simlation:#
end_distances <- start_distances <- vector(mode="numeric")#
#
# Pick a response type (one of "bounce", "redraw", or "stop")#
response <- "stop"#
#
start_time <- Sys.time()#
#
# For each animal:#
for(i in 1:n_aminals) {#
#
    # Pick a random start position from the square in which the circular continent sits:#
    start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
    # Record distance from centre of continent:#
    start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
#
    # If the starting point is not on the circular continent:#
    if(start_distances[i] > continent_radius) {#
#
        # Whilst the starting point is not on the circular continent:#
        while(start_distances[i] > continent_radius) {#
#
            # Pick a new starting point:#
            start_position <- c(runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)), runif(1, -continent_radius / ((2 * pi * EarthRad) / 360), continent_radius / ((2 * pi * EarthRad) / 360)))#
#
            # Record distance from centre of continent:#
            start_distances[i] <- GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], start_position[1], start_position[2])#
#
        }#
#
    }#
#
    # Store point as start position (now we know it is safely on the continent:#
    start_positions <- rbind(start_positions, start_position)#
#
}#
#
# Ossify start positions now as they will get overwritten later:#
ossified_start_positions <- start_positions#
#
# For each time step:#
for(i in 1:niter) {#
#
    # For each organism:#
    for(j in 1:n_aminals) {#
#
        # Draw a random bearing for the next move:#
        bearing <- runif(1, 0, 360)#
#
        # Draw a random distance for the next move:#
        distance <- abs(rnorm(1, 0, stepsize_sd))#
#
        # Calculate the new position of the organism following the move:#
        new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
        # If draw means leaving continent:#
        if(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
#
            # If response to leaving continent is to redraw:#
            if(response == "redraw") {#
#
                # As long as the draw removes the taxon from the continent:#
                while(GreatCircleDistanceFromLongLat(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]) > continent_radius) {#
#
                    # Redraw the bearing:#
                    bearing <- runif(1, 0, 360)#
#
                    # Redraw the distance:#
                    distance <- abs(rnorm(1, 0, stepsize_sd))#
#
                    # Calculate the new position:#
                    new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance)[c("long", "lat")]#
#
                }#
#
                # Overwrite start positions:#
                start_positions[j, ] <- unlist(new_position)#
#
                # Record distance from centre of continent:#
                end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
            # If response to leaving continent is not to redraw (i.e., is to bounce off of, or stop at, continent edge):#
            } else {#
#
# FIND COLLISION POINT STARTS HERE:#
#
                # Scalar which describes the proportion of the disatnce the organism has to travel before colliding with the continent edge:#
                distance_modifier <- 0.5#
#
                # Starting stepsize (will shrink as answer is honed in on more precisely):#
                stepsize <- 0.1#
#
                # Get starting new position (that will eb overwritten until the collision point is found):#
                new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, distance_modifier * distance)[c("long", "lat")]#
#
                # Whilst the collision point has not been found:#
                while(all.equal(as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE)), continent_radius) != TRUE) {#
#
                    # Record current distance of new position from centre of continent:#
                    current_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_position$long, new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
                    # Do we need to increase the distance modifier value?:#
                    if(current_distance_from_centre < continent_radius) {#
#
                        # Create potential better value by adding step size to modifier:#
                        limit <- distance_modifier + stepsize#
#
                    # Or do we need to decrease the degree modifier value?:#
                    } else {#
#
                        # Create potential better value by subtracting step size from modifier:#
                        limit <- distance_modifier - stepsize#
#
                    }#
#
                    # Store the new new position (so we can ask if this is better):#
                    new_new_position <- EndPoint(start_positions[j, 1], start_positions[j, 2], bearing, limit * distance)[c("long", "lat")]#
#
                    # Get new distance from continent centre based on potential better modifer:#
                    new_distance_from_centre <- as.vector(GreatCircleDistanceFromLongLat(continent_centre[1], continent_centre[2], new_new_position$long, new_new_position$lat, EarthRad = EarthRad, Warn = FALSE))#
#
                    # If new distance is closer to continent radius:#
                    if(abs(current_distance_from_centre - continent_radius) > abs(new_distance_from_centre - continent_radius)) {#
#
                        # Update new position:#
                        new_position <- new_new_position#
#
                        # Update distance modifier itself:#
                        distance_modifier <- limit#
#
                    # If current distance is stil our best estimate:#
                    } else {#
#
                        # Shrink the step size so we can hone in closer:#
                        stepsize <- stepsize * 0.1#
#
                    }#
#
                }#
#
# FIND COLLISION POINT ENDS HERE:#
#
                # If response to hitting a continent edge is to bounce off it:#
                if(response == "bounce") {#
#
                    # Get the remaining distance of the step:#
                    remaining_distance <- as.vector(distance - GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], new_position$long, new_position$lat))#
#
                    # Get the bearing to the centre of the continent from the colision point:#
                    bearing_to_centre <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, continent_centre[1], continent_centre[2]))#
#
                    # Get the bearing to the start of the dispersal step from the colision point:#
                    bearing_to_start <- as.vector(BearingBetweenTwoLongLatPoints(new_position$long, new_position$lat, start_positions[j, 1], start_positions[j, 2]))#
#
                    # Get the difference between these two bearings:#
                    bearing_difference <- min(c(abs(bearing_to_start - bearing_to_centre), 360 - abs(bearing_to_start - bearing_to_centre)))#
#
                    # If bearing difference should be subtracted to get new "bounce" bearing:#
                    if(all.equal((bearing_to_centre + bearing_difference) %% 360, bearing_to_start) == TRUE) {#
#
                        # Get new "bounce" bearing:#
                        bearing_to_end <- (bearing_to_centre - bearing_difference) %% 360#
#
                    # If bearing difference should be added to get new "bounce" bearing:#
                    } else {#
#
                        # Get new "bounce" bearing:#
                        bearing_to_end <- (bearing_to_centre + bearing_difference) %% 360#
#
                    }#
#
                    # Record actual new position (after bounce):#
                    new_position <- EndPoint(new_position$long, new_position$lat, bearing_to_end, remaining_distance)[c("long", "lat")]#
#
                    # Overwrite start positions:#
                    start_positions[j, ] <- unlist(new_position)#
#
                    # Record distance from centre of continent:#
                    end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
                    # Little conditional to catch a second collision (does not do what it should, this is just a test to see if it happens):#
                    if(end_distances[j] > continent_radius) print("Fallen off after bouncing!")#
#
                }#
#
                # If response to hitting a continent edge is to stick to it:#
                if(response == "stop") {#
#
                    # Overwrite start positions:#
                    start_positions[j, ] <- unlist(new_position)#
#
                    # Record distance from centre of continent:#
                    end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
                }#
#
            }#
#
        # If draw means staying on continent:#
        } else {#
#
            # Overwrite start positions:#
            start_positions[j, ] <- unlist(new_position)#
#
            # Record distance from centre of continent:#
            end_distances[j] <- GreatCircleDistanceFromLongLat(start_positions[j, 1], start_positions[j, 2], continent_centre[1], continent_centre[2])#
#
        }#
#
    }#
#
}#
#
end_time <- Sys.time()#
#
end_time - start_time#
#
# Redraw: Time difference of 5.047525 mins#
# Stop: Time difference of 9.766932 mins
