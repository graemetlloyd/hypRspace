degrees_of_latitude * (pi / 180)
cos(degrees_of_latitude)
radius / circumference
radius / circumference * 360
cos(degrees_of_latitude * (pi / 180)) * EarthRad
EarthRad
radius
radius <- 5000
circumference <-  2 * pi * EarthRad#
		degrees_of_latitude <- radius / circumference * 360
degrees_of_latitude
2 * pi * EarthRad
radius <- 10000
circumference <-  2 * pi * EarthRad#
		degrees_of_latitude <- radius / circumference * 360
degrees_of_latitude
cos(degrees_of_latitude * (pi / 180)) * EarthRad
circumference <-  2 * pi * EarthRad#
		degrees_of_latitude <- radius / circumference * 360#
		cos(degrees_of_latitude * (pi / 180)) * EarthRad -> R_minus_h
radius <- 5000
circumference <-  2 * pi * EarthRad#
		degrees_of_latitude <- radius / circumference * 360#
		cos(degrees_of_latitude * (pi / 180)) * EarthRad -> R_minus_h
R_minus_h
EarthRad - R_minus_h
circumference <-  2 * pi * EarthRad#
		degrees_of_latitude <- radius / circumference * 360#
		cos(degrees_of_latitude * (pi / 180)) * EarthRad -> R_minus_h#
#
		EarthRad - R_minus_h -> h
h
2 * pi * EarthRad * h
4*pi*(EarthRad ^ 2)
radius <- 2000
circumference <-  2 * pi * EarthRad#
		degrees_of_latitude <- radius / circumference * 360#
		cos(degrees_of_latitude * (pi / 180)) * EarthRad -> R_minus_h#
#
		EarthRad - R_minus_h -> h#
#
		2 * pi * EarthRad * h
degrees_of_latitude
R_minus_h
h
radius <- 3000
circumference <-  2 * pi * EarthRad#
		degrees_of_latitude <- radius / circumference * 360#
		cos(degrees_of_latitude * (pi / 180)) * EarthRad -> R_minus_h#
#
		EarthRad - R_minus_h -> h#
#
		2 * pi * EarthRad * h
height
SphericalCapArea <- function(radius, EarthRad = 6367.4447) {#
		circumference <-  2 * pi * EarthRad#
		degrees_of_latitude <- radius / circumference * 360#
		radius_minus_height <- cos(degrees_of_latitude * (pi / 180)) * EarthRad#
#
		height <- EarthRad - radius_minus_height#
#
		cap_area <- 2 * pi * EarthRad * height#
		return(cap_area)#
	}
SphericalCapArea(1000)
SphericalCapArea(2000)
SphericalCapArea(3000)
SphericalCapArea(4000)
SphericalCapArea(5000)
SphericalCapArea(6000)
SphericalCapArea(7000)
SphericalCapArea(8000)
SphericalCapArea(9000)
SphericalCapArea(10000)
SphericalCapArea(11000)
SphericalCapArea(20000)
document()
SphericalCapArea(radius)
radius
SphericalCapArea(min_separation) * N_continents
4 * pi * (EarthRad ^ 2)
(SphericalCapArea(min_separation) * N_continents) > 4 * pi * (EarthRad ^ 2)
min_separation
(SphericalCapArea(min_separation / 2) * N_continents) > 4 * pi * (EarthRad ^ 2)
(SphericalCapArea(min_separation / 2) * N_continents) > (4 * pi * (EarthRad ^ 2))
N_steps = 1000; N_continents = 7; radius = 2000; start_configuration = "supercontinent"; squishiness = 0.25; stickiness = 0.95; continent_speed_mean = 500; continent_speed_sd = 250; EarthRad = 6367.4447
# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad)
#' Generate a matrix of longitudes and latitudes of contienntal centres#
#'#
#' Generates a matrix of longitudes and latitudes describing the centres of circular continents on a sphere#
#'#
#' @param N_continents The (maximum) number of individual continents#
#' @param radius The radius of each circular continent.#
#' @param start_configuration One of "random separate", "random overlap", "supercontinent", or "max separate".#
#' @param squishiness A value from 0 (continents can never overlap) to 1 (continents can overlap completely)#
#' @return A matrix of longitudes and latitudes describing the centres of circular continents#
#' @details Nothing yet.#
#' @examples#
#' StartingPoints(N_continents = 7, radius = 2000,#
#'    start_configuration = "supercontinent", squishiness = 0.1,#
#'    EarthRad = 6367.4447)#
#
# Inouts for eventual continental function:#
# - N circles#
# - Radius (single value)#
# - Starting points (random; supercontinent; all separate)#
# - Squishiness (How close can they get?; %age of radii; make sure it is 0-100)#
# - Starting bearing (random; disperse; converging) - will need to use Euler Pole function to do this.#
# - Speed - Not sure how we will do this.#
# - Stickiness: how long (in steps) can continents stay at maximum squished-togetherness?#
#
# Outputs:#
# - N separated continents (distance matrix with values less than 2radii)#
# - Long-lat of each circle centre#
# - Bearings after each step change#
# - Total land area all circles - minus#
#
StartingPoints <- function(N_continents = 7, radius = 2000, start_configuration = "supercontinent", squishiness = 0.25, EarthRad = 6367.4447) {#
#
	# Check N_continents at least 1 and is an integer (divisble by one:#
	if(N_continents %% 1 != 0 || N_continents < 1) stop("ERROR: Number of contientns must be a positive integer >= 1.")#
	# Check radius is less than or equal to pi * the radius of the Earth:#
	if(radius > (pi * EarthRad)) stop("ERROR: Radius must be less than pi * EarthRad (and much more if using multiple continents).")#
	# Check configuration option chosen is valid:#
	if(start_configuration != "random separate" && start_configuration != "random overlap" && start_configuration != "supercontinent" && start_configuration != "all separate") stop("ERROR: Starting configuration must be one of \"random separate\", \"random overlap\", \"supercontinent\", or \"all separate\".")#
	# Check squishiness is a proportion:#
	if(squishiness > 1 || squishiness < 0) stop("ERROR: Squishiness is proportional and must be between 0 and 1.")#
#
	# If the start configuration is a supercontinnet (all continents attached togther):#
	if(start_configuration == "supercontinent") {#
		# As long as squishiness is greater than 0 (complete overlap is impossible):#
		if(squishiness > 0) {#
			# Establish minimum distance between continent centres (:#
			min_separation <- (1 - squishiness) * radius * 2#
			# Randomly assign starting longitude:#
			first_circle_long <- runif(1, min = -180, max = 180)#
			# Randomly assign starting latitude:#
			first_circle_lat <- runif(1, min = -90, max = 90)#
			# Create matrix to store circles:#
			circles <- matrix(c(1, first_circle_long, first_circle_lat), ncol=3, dimnames=list(c(), c("Circle", "Longitude", "Latitude")))#
			# If there are two or more continents still to place:#
			if(N_continents > 1) {#
				# Find centre of second continnet by randomly drawing from the circle describing all points within minimum separation of the first continent:#
				second_circle <- EndPoint(slong = first_circle_long, slat = first_circle_lat, bearing = runif(1, min = 0, max = 360), distance = min_separation)#
				# Add second continent to circles matrix:#
				circles <- rbind(circles, c(2, second_circle$long, second_circle$lat))#
				# If there are more than two continents still to place:#
				if(N_continents > 2) {#
					# Get spherical angle of equilateral (spherical) triangle with sides equal to minimum separation:#
					spherical_angle <- SphericalAngleForEquilateralTriangleFromGreatCircleSideLength(min_separation, EarthRad = EarthRad)#
					# Get first of two possible bearings from centre of first continent to centre of third continent:#
					new_bearing_1 <- (BearingBetweenTwoLongLatPoints(circles[1, "Longitude"], circles[1, "Latitude"], circles[2, "Longitude"], circles[2, "Latitude"]) - spherical_angle) %% 360#
					# Get second of two possible bearings from centre of first continent to centre of third continent:#
					new_bearing_2 <- (BearingBetweenTwoLongLatPoints(circles[1, "Longitude"], circles[1, "Latitude"], circles[2, "Longitude"], circles[2, "Latitude"]) + spherical_angle) %% 360#
					# Get lat-long coordinates of first possible site of third continent:#
					new_continent_1 <- EndPoint(circles[1, "Longitude"], circles[1, "Latitude"], new_bearing_1, min_separation)[c("long", "lat")]#
					# Get lat-long coordinates of second possible site of third continent:#
					new_continent_2 <- EndPoint(circles[1, "Longitude"], circles[1, "Latitude"], new_bearing_2, min_separation)[c("long", "lat")]#
					# Randomly pick site for third continent:#
					third_continent_picked <- sample(c(1, 2), 1)#
					# Randomly pick site for third continent:#
					third_circle <- rbind(unlist(new_continent_1), unlist(new_continent_2))[third_continent_picked, ]#
					# Add third continent to circles matrix:#
					circles <- rbind(circles, c(3, third_circle))#
					# If there are more than three continents:#
					if(N_continents > 3) {#
						# Create new matrix for open spots (centres where new continents may reside) with unused spot from third continent choice:#
						open_spots <- matrix(rbind(unlist(new_continent_1), unlist(new_continent_2))[setdiff(c(1:2), third_continent_picked), ], ncol=2)#
						# Add column names:#
						colnames(open_spots) <- c("Longitude", "Latitude")#
						# Vector to store distances from centres:#
						distances_from_centres <- vector(mode="numeric")#
						# For each pre-existing continent:#
						for(i in 1:3) {#
							# Get distance from open spot to ith continent centre:#
							distances_from_centres[i] <- GreatCircleDistanceFromLongLat(open_spots[, "Longitude"], open_spots[, "Latitude"], circles[i, "Longitude"], circles[i, "Latitude"], EarthRad = EarthRad)#
						}#
						# Identify continent centre furthest from current single open spot:#
						furthest_point <- match(max(distances_from_centres), distances_from_centres)#
						# Get bearing from furthest point to first of the two other continent centres:#
						first_bearing <- BearingBetweenTwoLongLatPoints(circles[furthest_point, "Longitude"], circles[furthest_point, "Latitude"], circles[setdiff(c(1:3), furthest_point)[1], "Longitude"], circles[setdiff(c(1:3), furthest_point)[1], "Latitude"])#
						# Get bearing from furthest point to second of the two other continent centres:#
						second_bearing <- BearingBetweenTwoLongLatPoints(circles[furthest_point, "Longitude"], circles[furthest_point, "Latitude"], circles[setdiff(c(1:3), furthest_point)[2], "Longitude"], circles[setdiff(c(1:3), furthest_point)[2], "Latitude"])#
						# Get bearings from furthest point to the two new open spots:#
						new_bearings <- as.vector(sort(c(first_bearing - spherical_angle, first_bearing + spherical_angle, second_bearing - spherical_angle, second_bearing + spherical_angle))[c(1, 4)] %% 360)#
						# Add first new open spot to list:#
						open_spots <- rbind(open_spots, as.vector(unlist(EndPoint(circles[furthest_point, "Longitude"], circles[furthest_point, "Latitude"], new_bearings[1], min_separation)[c("long", "lat")])))#
						# Add second new open spot to list:#
						open_spots <- rbind(open_spots, as.vector(unlist(EndPoint(circles[furthest_point, "Longitude"], circles[furthest_point, "Latitude"], new_bearings[2], min_separation)[c("long", "lat")])))#
						# Keep adding continents unless they all have starting points:#
						while(N_continents > nrow(circles)) {#
							# Error message if too many continents are requested:#
							if(nrow(open_spots) == 0) stop("ERROR: There is not enough space for all your continents! Try making them smaller or choosing fewer of them.")#
							# Randomly pick an open spot to place a new continent:#
							new_continent_point <- sample(c(1:nrow(open_spots)))[1]#
							# Vector to store row numbers for adjacent continents:#
							adjacent_continents <- vector(mode="numeric")#
							# For each pre-existing continent:#
							for(i in 1:nrow(circles)) {#
								# Is the distance from the new continent to the ith pre-existing continent equal to the minimum continental separation?:#
								equal_check <- all.equal(as.vector(GreatCircleDistanceFromLongLat(open_spots[new_continent_point, "Longitude"], open_spots[new_continent_point, "Latitude"], circles[i, "Longitude"], circles[i, "Latitude"], EarthRad = EarthRad)), min_separation)#
								# If one of the nearest continents then add to the list:#
								if(equal_check == TRUE) adjacent_continents <- c(adjacent_continents, i)#
							}#
							# Vector to store bearings from new continent to adjacent continents:#
							bearings_to_adjacents <- vector(mode="numeric")#
							# For each continent adjacent to the new continent:#
							for(i in adjacent_continents) {#
								# Store bearing from new continent to ith adjacent continent:#
								bearings_to_adjacents <- as.vector(c(bearings_to_adjacents, BearingBetweenTwoLongLatPoints(open_spots[new_continent_point, "Longitude"], open_spots[new_continent_point, "Latitude"], circles[i, "Longitude"], circles[i, "Latitude"])))#
							}#
							# Vector to store bearings to potential new open spots:#
							new_bearings <- vector(mode="numeric")#
							# For each bearing to an adjacent continent:#
							for(i in 1:length(bearings_to_adjacents)) {#
								# Get new bearings from plus or minus the psherical angle from the current ebarings:#
								new_bearings <- c(new_bearings, c(bearings_to_adjacents[i] + spherical_angle, bearings_to_adjacents[i] - spherical_angle))#
							}#
							# Get bearings from new continent to two new potential open spots:#
							new_bearings <- sort(new_bearings)[c(1, length(new_bearings))] %% 360#
							# Store potential new open spots for further vetting:#
							potential_new_open_spots <- rbind(as.vector(unlist(EndPoint(open_spots[new_continent_point, "Longitude"], open_spots[new_continent_point, "Latitude"], new_bearings[1], min_separation)[c("long", "lat")])), as.vector(unlist(EndPoint(open_spots[new_continent_point, "Longitude"], open_spots[new_continent_point, "Latitude"], new_bearings[2], min_separation)[c("long", "lat")])))#
							# Add column names:#
							colnames(potential_new_open_spots) <- c("Longitude", "Latitude")#
							# Add new continent to circles matrix:#
							circles <- rbind(circles, c(nrow(circles) + 1, open_spots[new_continent_point, ]))#
							# Vector to store unsuitable new spots (those that are closer than minimum separation to existing continents):#
							unsuitable_spots <- vector(mode="numeric")#
							# For each potential new spot:#
							for(i in 1:2) {#
								# For each existing continent:#
								for(j in 1:nrow(circles)) {#
									# Get distance from ith potential new open spot to jth existing continent:#
									distance_between_centres <- as.vector(GreatCircleDistanceFromLongLat(potential_new_open_spots[i, "Longitude"], potential_new_open_spots[i, "Latitude"], circles[j, "Longitude"], circles[j, "Latitude"], EarthRad = EarthRad))#
									# If ith potential new open spot is closer to a pre-existing continent than the minimum separation allows add to unsuitable spots:#
									if(all.equal(distance_between_centres, min_separation) != TRUE && distance_between_centres < min_separation) unsuitable_spots <- as.vector(c(unsuitable_spots, i))#
								}#
								# For each existing open spot:#
								for(j in 1:nrow(open_spots)) {#
									# Get distance from ith potential new open spot to jth existing open spot:#
									distance_between_centres <- as.vector(GreatCircleDistanceFromLongLat(potential_new_open_spots[i, "Longitude"], potential_new_open_spots[i, "Latitude"], open_spots[j, "Longitude"], open_spots[j, "Latitude"], EarthRad = EarthRad))#
									# If ith potential new open spot is closer to a pre-existing open spot than the minimum separation allows add to unsuitable spots:#
									if(all.equal(distance_between_centres, min_separation) != TRUE && distance_between_centres < min_separation) unsuitable_spots <- as.vector(c(unsuitable_spots, i))#
								}#
							}#
							# If there are unsuitable spots:#
							if(length(unsuitable_spots) > 0) {#
								# Remove unsuitable spots from potential new spots:#
								potential_new_open_spots <- potential_new_open_spots[-unique(unsuitable_spots), ]#
								# If deletions has de-matrixed the data:#
								if(!is.matrix(potential_new_open_spots)) {#
									# Make back into matrix:#
									potential_new_open_spots <- matrix(potential_new_open_spots, ncol=2)#
								}#
								# Add column names:#
								colnames(potential_new_open_spots) <- c("Longitude", "Latitude")#
							}#
							# Add new potential open spots to open spots:#
							open_spots <- rbind(open_spots, potential_new_open_spots)#
							# Remove new continent from open spots:#
							open_spots <- open_spots[-new_continent_point, ]#
							# If deletions has de-matrixed the data:#
							if(!is.matrix(open_spots)) {#
								# Make back into matrix:#
								open_spots <- matrix(open_spots, ncol=2)#
							}#
							# Add column names:#
							colnames(open_spots) <- c("Longitude", "Latitude")#
						}#
					}#
				}#
			}#
		# If squishiness is 1:#
		} else {#
			# Warn user:#
			print("WARNING: Squishiness set to one and supercontinent option employed: all continents will start completely overlapping each other.")#
			# Randomly assign starting longitude:#
			first_circle_long <- runif(1, min = -180, max = 180)#
			# Randomly assign starting latitude:#
			first_circle_lat <- runif(1, min = -90, max = 90)#
			# Create matrix to store circles:#
			circles <- cbind(c(1:N_continents), matrix(rep(c(first_circle_long, first_circle_lat), N_continents), ncol=2, byrow=TRUE))#
			# Add column names:#
			colnames(circles) <- c("Circle", "Longitude", "Latitude")#
		}#
	}#
	# If starting continental configuration is random:#
	if(start_configuration == "random separate" || start_configuration == "random overlap") {#
		# Establish minimum difference between continent centres if overlap allowed:#
		if(start_configuration == "random overlap") min_separation <- (1 - squishiness) * radius * 2#
		# Establish minimum difference between continent centres if overlap not allowed:#
		if(start_configuration == "random separate") min_separation <- radius * 2#
		# Error check for whether all continents can theoretically fit:#
		if((SphericalCapArea(min_separation / 2) * N_continents) > (4 * pi * (EarthRad ^ 2))) stop("ERROR: The current choices for number of continents, radius and squishiness means it is impossible to fit all continents on the sphere. Consider choosing fewer continents, a smaller radius, or larger squishiness.")#
		# Randomly assign starting longitude:#
		first_circle_long <- runif(1, min = -180, max = 180)#
		# Randomly assign starting latitude:#
		first_circle_lat <- runif(1, min = -90, max = 90)#
		# Create matrix to store circles:#
		circles <- matrix(c(1, first_circle_long, first_circle_lat), ncol=3, dimnames=list(c(), c("Circle", "Longitude", "Latitude")))#
		# Keep adding continents until they all have starting points:#
		while(N_continents > nrow(circles)) {#
#
			# Randomly assign starting longitude:#
			new_circle_long <- runif(1, min = -180, max = 180)#
			# Randomly assign starting latitude:#
			new_circle_lat <- runif(1, min = -90, max = 90)#
			# Get the Great Circle distance matrix of the potential new continent and the pre-existing continents:#
			GC_distance_matrix <- GreatCircleDistanceMatrix(rbind(circles[, c("Longitude", "Latitude")], c(new_circle_long, new_circle_lat))[, 1], rbind(circles[, c("Longitude", "Latitude")], c(new_circle_long, new_circle_lat))[, 2], EarthRad = EarthRad)#
			# Reset counter:#
			counter <- 1#
			# As long as the new point is too close to the epre-existing continents:#
			while(min(GC_distance_matrix[lower.tri(GC_distance_matrix)]) < min_separation) {#
				# Randomly assign new starting longitude:#
				new_circle_long <- runif(1, min = -180, max = 180)#
				# Randomly assign new starting latitude:#
				new_circle_lat <- runif(1, min = -90, max = 90)#
				# Update Great Circle distance matrix:#
				GC_distance_matrix <- GreatCircleDistanceMatrix(rbind(circles[, c("Longitude", "Latitude")], c(new_circle_long, new_circle_lat))[, 1], rbind(circles[, c("Longitude", "Latitude")], c(new_circle_long, new_circle_lat))[, 2], EarthRad = EarthRad)#
				# Update counter:#
				counter <- counter + 1#
				# Break loop if it looks like adding the next continent is impossible:#
				if(counter == 1000) stop("ERROR: Have made 1000 attempts to add the next continent without success. Check that number of continents or continent radius are not too large.")#
			}#
			# Add new continent to list:#
			circles <- rbind(circles, c(nrow(circles) + 1, new_circle_long, new_circle_lat))#
		}#
	}#
#
	# If starting continental configuration is maximally separated:#
	if(start_configuration == "max separate") {#
		# Establish minimum difference between points:#
		#min_separation <- ?????#
	}#
	# Output the circles matrix:#
	return(circles)#
}
# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad)
continent_starting_points
GreatCircleDistanceMatrix(continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])
StartingPoints
# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
	GreatCircleDistanceMatrix(continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])
# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad)#
# Are any continents joined at start?:#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
	intercontinental_distance_matrix <- GreatCircleDistanceMatrix(continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])
intercontinental_distance_matrix
# Are any continents joined at start?:#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
	# Get starting intercontinental distances:#
	intercontinental_distance_matrix <- GreatCircleDistanceMatrix(continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])
match(min_separation, intercontinental_distance_matrix)
intercontinental_distance_matrix == min_separation
round(intercontinental_distance_matrix) == min_separation
intercontinental_distance_matrix == min_separation
# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
	# Get starting intercontinental distances:#
	intercontinental_distance_matrix <- GreatCircleDistanceMatrix(continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
	for(i in 1:(nrow(intercontinental_distance_matrix) - 1)) {#
		for(j in (i + 1):nrow(intercontinental_distance_matrix)) {#
			print( all.equal(intercontinental_distance_matrix[i, j], min_separation) )#
		}#
	}
# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
	# Get starting intercontinental distances:#
	intercontinental_links <- intercontinental_distance_matrix <- GreatCircleDistanceMatrix(continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
	for(i in 1:(nrow(intercontinental_distance_matrix) - 1)) {#
		for(j in (i + 1):nrow(intercontinental_distance_matrix)) {#
			if(all.equal(intercontinental_distance_matrix[i, j], min_separation) == TRUE) {#
				intercontinental_links[i, j] <- 1#
			} else {#
				intercontinental_links[i, j] <- 0#
			}#
		}#
	}
intercontinental_links
# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
	# Get starting intercontinental distances:#
	intercontinental_links <- intercontinental_distance_matrix <- GreatCircleDistanceMatrix(continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
	for(i in 1:(nrow(intercontinental_distance_matrix) - 1)) {#
		for(j in (i + 1):nrow(intercontinental_distance_matrix)) {#
			if(all.equal(intercontinental_distance_matrix[i, j], min_separation) == TRUE) {#
				intercontinental_links[j, i] <- intercontinental_links[i, j] <- 1#
			} else {#
				intercontinental_links[j, i] <- intercontinental_links[i, j] <- 0#
			}#
		}#
	}
intercontinental_links
sum(intercontinental_links)
sum(intercontinental_links) == 0
intercontinental_distance_matrix
# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
	HowManySeparateContinents <- function(min_separation, longitudes, latitudes) {#
		# Get starting intercontinental distances:#
		intercontinental_links <- intercontinental_distance_matrix <- GreatCircleDistanceMatrix(, )#
		# For each row:#
		for(i in 1:(nrow(intercontinental_distance_matrix) - 1)) {#
			# For each column:#
			for(j in (i + 1):nrow(intercontinental_distance_matrix)) {#
				# If continents are linked:#
				if(all.equal(intercontinental_distance_matrix[i, j], min_separation) == TRUE) {#
					# Record a one for the link:#
					intercontinental_links[j, i] <- intercontinental_links[i, j] <- 1#
				# If continents are not linked:#
				} else {#
					# Record a zero for no link:#
					intercontinental_links[j, i] <- intercontinental_links[i, j] <- 0#
				}#
			}#
		}#
		# If there are no joined continents:#
		if(sum(intercontinental_links) == 0) {#
			c(1:length(longitudes)#
		} else {#
		}#
		return(intercontinental_links)#
	}#
	HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])
# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
	HowManySeparateContinents <- function(min_separation, longitudes, latitudes) {#
		# Get starting intercontinental distances:#
		intercontinental_links <- intercontinental_distance_matrix <- GreatCircleDistanceMatrix(, )#
		# For each row:#
		for(i in 1:(nrow(intercontinental_distance_matrix) - 1)) {#
			# For each column:#
			for(j in (i + 1):nrow(intercontinental_distance_matrix)) {#
				# If continents are linked:#
				if(all.equal(intercontinental_distance_matrix[i, j], min_separation) == TRUE) {#
					# Record a one for the link:#
					intercontinental_links[j, i] <- intercontinental_links[i, j] <- 1#
				# If continents are not linked:#
				} else {#
					# Record a zero for no link:#
					intercontinental_links[j, i] <- intercontinental_links[i, j] <- 0#
				}#
			}#
		}#
		# If there are no joined continents:#
		if(sum(intercontinental_links) == 0) {#
			c(1:length(longitudes))#
		} else {#
		}#
		return(intercontinental_links)#
	}#
	HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])
HowManySeparateContinents <- function(min_separation, longitudes, latitudes) {#
		# Get starting intercontinental distances:#
		intercontinental_links <- intercontinental_distance_matrix <- GreatCircleDistanceMatrix(longitudes, latitudes)#
		# For each row:#
		for(i in 1:(nrow(intercontinental_distance_matrix) - 1)) {#
			# For each column:#
			for(j in (i + 1):nrow(intercontinental_distance_matrix)) {#
				# If continents are linked:#
				if(all.equal(intercontinental_distance_matrix[i, j], min_separation) == TRUE) {#
					# Record a one for the link:#
					intercontinental_links[j, i] <- intercontinental_links[i, j] <- 1#
				# If continents are not linked:#
				} else {#
					# Record a zero for no link:#
					intercontinental_links[j, i] <- intercontinental_links[i, j] <- 0#
				}#
			}#
		}#
		# If there are no joined continents:#
		if(sum(intercontinental_links) == 0) {#
			c(1:length(longitudes))#
		} else {#
		}#
		return(intercontinental_links)#
	}#
	HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])
intercontinental_links
apply(intercontinental_links, 1, sum)
max(apply(intercontinental_links, 1, sum))
match(max(apply(intercontinental_links, 1, sum)), apply(intercontinental_links, 1, sum))
intercontinental_links[largest_clump, ]
largest_clump <- match(max(apply(intercontinental_links, 1, sum)), apply(intercontinental_links, 1, sum))
intercontinental_links[largest_clump, ]
intercontinental_links[largest_clump, ] == 1
which(intercontinental_links[largest_clump, ] == 1)
sort(c(largest_clump, which(intercontinental_links[largest_clump, ] == 1)))
largest_clump <- match(max(apply(intercontinental_links, 1, sum)), apply(intercontinental_links, 1, sum))#
			largest_clump <- sort(c(largest_clump, which(intercontinental_links[largest_clump, ] == 1)))
largest_clump
intercontinental_links[-largest_clump, ]
intercontinental_links[largest_clump, setdiff(largest_clump, c(1:nrow(intercontinental_links)))]
setdiff(largest_clump, c(1:nrow(intercontinental_links))
)
setdiff(largest_clump, c(1:nrow(intercontinental_links)))
setdiff(c(1:nrow(intercontinental_links)), largest_clump)
intercontinental_links[largest_clump, setdiff(c(1:nrow(intercontinental_links)), largest_clump)]
# taxonomy curation scripts#
taxon<-"Trilobita"#
oldest<-"Cambrian"#
youngest<-"Ordovician"#
end_date<-"2015-04-21"#
start_date<-"2014-01-01"#
format<-".xls"#
paleodb_occurrence_curation(taxon="Trilobita",oldest="Ordovician",youngest="Silurian",start_date="2013-01-01",end_date="2015-04-21",format=".xls")#
#
# taxonomy curation scripts#
# Arguments:#
# 	taxon: proper taxonomic name#
# 	oldest: oldest geological interval from which you want new records#
# 	youngest: youngest geological interval from which you want new records#
# 	start_date: the oldest entered records that you want to include#
# 	end_date: the most recent records that you want to include#
# 	format: the end tag on the output files: '.xls' for Excel, '.txt', '.csv" for comma-delimited#
paleodb_occurrence_curation<-function(taxon,oldest,youngest,start_date,end_date,format)#
{#
#
# get temporal information for search#
strat_names<-vector(length=142)#
for (i in 1:142)	strat_names[i]<-as.character(pbdb_interval(id=i)$nam)#
ons<-end<-1#
while (strat_names[ons]!=oldest && ons<142)	{	#
	if (ons==142 && strat_names[ons]!=oldest) print("Error! ",oldest," is not a term in our chronostratigraphic lexicon!")#
	ons<-ons+1#
	}#
while (strat_names[end]!=youngest)	{#
	if (end==142 && strat_names[end]!=youngest) print("Error! ",youngest," is not a term in our chronostratigraphic lexicon!")#
	end<-end+1#
	}#
start_ma<-pbdb_interval(id=ons)$eag#
end_ma<-pbdb_interval(id=end)$lag#
#
# get occurrence data: if this can be modified to make it species-only, then do that.#
occurrences<-pbdb_occurrences(limit="all", vocab= "pbdb", base_name=taxon, show=c("crmod"),max_ma=start_ma,min_ma=end_ma, modified_since=start_date, modified_before=end_date)#
dd<-dim(occurrences)#
entry_level<-vector(length=dd[1])#
#newby<-0#
for (i in 1:dd[1])  {#
	entry_level[i]<-1#
	temp_name<-as.character(occurrences[i,]$taxon_name)#
#	rank<-pbdb_taxon(id=occurrences[i,]$taxon_no)$rnk#
	temp_name<-gsub(" n. sp.","",temp_name)#
	temp_name<-gsub("n. gen. ","",temp_name)#
	temp_name<-gsub(" cf.","",temp_name)#
	temp_name<-gsub(" aff.","",temp_name)#
	temp_name<-gsub(" ex gr.","",temp_name)#
	temp_name<-gsub(" informal","",temp_name)#
	temp_name<-gsub(" sensu lato","",temp_name)#
	temp_name<- gsub("\" ", "",temp_name)#
	temp_name<-gsub("\\? " ,"",temp_name)#
	temp_name<-gsub(" \\?" ,"",temp_name)#
	temp_name<-gsub("  " ," ",temp_name)#
	words<-length(strsplit(as.character(temp_name)," ")[[1]])#
	last_name<-strsplit(as.character(temp_name)," ")[[1]][words]#
	if (last_name=="sp.")	{#
		entry_level[i]<-0#
		} else if (last_name=="indet.")	{#
		entry_level[i]<-0#
		} else if (last_name=="spp.")	{#
		entry_level[i]<-0#
		} else if (last_name=="nov.")	{#
		entry_level[i]<-0#
		}#
	}#
#
newby<-sum(entry_level)#
new_finds<-vector(length=newby)					# occurrence numbers#
new_collections<-vector(length=newby)		# collection numbers#
new_taxon_no<-vector(length=newby)			# taxon numbers#
new_names<-vector(length=newby)					# taxon names#
new_rank<-vector(length=newby)					# taxon rank#
orig_author<-vector(length=newby)				# original authority#
new_references<-vector(length=newby)		# occurrence reference#
new_data<-1#
for (i in 1:dd[1])	{#
	if (entry_level[i]==1)	{#
		new_finds[new_data]<-occurrences[i,]$occurrence_no#
		new_collections[new_data]<-occurrences[i,]$collection_no#
		new_taxon_no[new_data]<-occurrences[i,]$taxon_no#
		# get and clean up species name#
		new_names[new_data]<-as.character(occurrences[i,]$taxon_name)#
		new_names[new_data]<-gsub(" n. sp.","",new_names[new_data])#
		new_names[new_data]<-gsub("n. gen. ","",new_names[new_data])#
		new_names[new_data]<-gsub(" cf.","",new_names[new_data])#
		new_names[new_data]<-gsub(" aff.","",new_names[new_data])#
		new_names[new_data]<-gsub(" ex gr.","",new_names[new_data])#
		new_names[new_data]<-gsub(" informal","",new_names[new_data])#
		new_names[new_data]<-gsub(" sensu lato","",new_names[new_data])#
		new_names[new_data]<- gsub("\" ", "",new_names[new_data])#
		new_names[new_data]<-gsub(" \\?" ,"",new_names[new_data])#
		new_names[new_data]<-gsub("\\? " ,"",new_names[new_data])#
		new_names[new_data]<-gsub("  " ," ",new_names[new_data])#
		new_references[new_data]<-occurrences[i,]$reference_no#
		new_data<-new_data+1#
		}#
	}#
#
whatcha<-cbind(new_taxon_no,new_names,new_collections,new_references)#
new_data<-dim(whatcha)[1]#
sorted_names <- whatcha[order(new_names),]#
reduced_names<-unique(sorted_names[,2])#
novel_species<-length(reduced_names)#
reduced_numbers<-vector(length=novel_species)#
find_start_end<-matrix(0,novel_species,2)#
# get first and last collection case for each species#
# get list of taxon numbers corresponding to each species#
notu<-1#
reduced_numbers[1]<-sorted_names[1,1]#
find_start_end[notu,1]<-find_start_end[notu,2]<-1#
for (i in 2:dim(sorted_names)[1])	{#
	sp<-sorted_names[i,2]#
	if (sp==sorted_names[i-1,2])	find_start_end[notu,2]<-i#
	if (sp!=sorted_names[i-1,2])	{#
		notu<-notu+1#
		reduced_numbers[notu]<-sorted_names[i,1]#
		find_start_end[notu,1]<-i#
		find_start_end[notu,2]<-i#
		}#
	}#
senior_names<-vector(length=novel_species)#
finds<-vector(length=novel_species)#
original_authors<-vector(length=novel_species)#
latest_opinion<-vector(length=novel_species)#
biggest_ref<-vector(length=novel_species)#
dominant_reference<-vector(length=novel_species)#
status_latest<-vector(length=novel_species)#
sp<-1#
j<-1#
new_species<-old_species<-0#
for (sp in 1:novel_species)	{#
	name<-reduced_names[sp]#
	finds[sp]<-1+(find_start_end[sp,2]-find_start_end[sp,1])#
	species_info<-pbdb_taxon(id=reduced_numbers[sp],vocab="pbdb",show=c("attr","ent", "entname"))#
	rank<-as.character(species_info$rank)#
	# if a species or subspecies that has been entered, collect info#
	if (rank=="species" || rank=="subspecies")	{#
    status_latest[sp]<-as.character(species_info$status)#
		if (status_latest[sp]=='belongs to')  {#
			senior_names[sp]<-as.character(species_info$taxon_name)#
		  } else if (status_latest[sp]=='nomen dubium') {#
		  senior_names[sp]<- "nomen dubium"#
		  } else if (status_latest[sp]=='nomen nudem') {#
		  senior_names[sp]<- "nomen nudem"#
		  } else if (status_latest[sp]=='nomen vanum') {#
		  senior_names[sp]<- "nomen vanum"#
		  } else if (status_latest[sp]=='nomen oblitum') {#
		  senior_names[sp]<-"nomen oblitum"#
		  } else if (status_latest[sp]=='invalid subgroup of') {#
		  senior_names[sp]<-as.character(pbdb_taxon(id=as.numeric(species_info$parent_no),vocab="pbdb")$taxon_name)#
		  } else if (as.character(species_info$status)!='belongs to') {#
			sr<-species_info$senior_no#
			senior_names[sp]<-as.character(pbdb_taxon(id=sr)$nam)#
			}#
		# identify original authors#
		if (length(as.character(species_info$attribution))==0)	{#
			ref<-pbdb_reference(species_info$reference_no)	#
			original_authors[sp]<-as.character(ref$al1)#
			original_authors[sp]<-paste(original_authors[sp],as.character(ref$pby),sep=" ")#
			old_species<-old_species+1#
			}#
		if (length(as.character(species_info$attribution))>0)	{#
			original_authors[sp]<-as.character(species_info$attribution)#
			old_species<-old_species+1#
			}#
		# identify the latest opinion#
		opinions<-pbdb_ref_taxa(id=reduced_numbers[sp],vocab="pbdb")#
		if (dim(opinions)[1]==0)	opinions<-pbdb_ref_taxa(id=species_info$taxon_no,vocab="pbdb")#
		latest<-dim(opinions)[1]#
		if (latest>0)#
			latest_opinion[sp]<-as.character(pbdb_reference(opinions$reference_no[latest],show=c("formatted"))$ref)#
		if (latest==0)#
			latest_opinion[sp]<-"Something got lost"#
		}#
#
	# set author and opinion information to zilch if we have no information#
	if (rank!="species" && rank != "subspecies")	{#
		senior_names[sp]<-name#
		original_authors[sp]<-"Unentered"#
		latest_opinion[sp]<-"None Known"#
    status_latest[sp]<-"Unknown"#
		new_species<-new_species+1#
		}#
	# count collections and find the most important reference#
	reference_cont<-vector(length=max(new_references))#
#	while (j<=dim(sorted_names)[1] && sorted_names[j,2]==name)	{#
	for (j in find_start_end[sp,1]:find_start_end[sp,2])	{#
		a<-as.numeric(sorted_names[j,4])#
		reference_cont[a]<-1+reference_cont[a]#
		}#
	# find the reference contributing the most occurrences#
	biggest_ref[sp]<-order(reference_cont,decreasing=TRUE)[1]#
	# get reference formatted#
	dominant_reference[sp]<-as.character(pbdb_reference(biggest_ref[sp],show=c("formatted"))$ref)#
	}#
#
output<-cbind(reduced_names,senior_names,status_latest,finds,original_authors,latest_opinion,dominant_reference)#
a<-dim(output)[2]#
output1<-matrix(0,new_species,a,dimnames=dimnames(output))#
output2<-matrix(0,old_species,a,dimnames=dimnames(output))#
nsp<-osp<-0#
for (i in 1:novel_species)	{#
	if (original_authors[i]=="Unentered")	{#
		nsp<-nsp+1#
		output1[nsp,]<-output[i,]#
		}#
	if (original_authors[i]!="Unentered")	{#
		osp<-osp+1#
		output2[osp,]<-output[i,]#
		}#
	}#
#
range<-paste(oldest,"-",youngest,sep="")#
filename1<-paste("Unentered",taxon,range,start_date,"to",end_date,sep="_")#
filename2<-paste("Entered",taxon,range,start_date,"to",end_date,sep="_")#
filename1<-paste(filename1,format,sep="")#
filename2<-paste(filename2,format,sep="")#
if (format!=".csv")	{#
	write.table(output1,filename1,sep="\t",eol="\n",row.names=FALSE)#
	write.table(output2,filename2,sep="\t",eol="\n",row.names=FALSE)#
	}#
if (format==".csv")	{#
	write.table(output1,filename1,sep=",",eol="\n",row.names=FALSE)#
	write.table(output2,filename2,sep=",",eol="\n",row.names=FALSE)#
	}#
}
paleodb_occurrence_curation(taxon="Bivalvia",oldest="Triassic",youngest="Jurassic",start_date="2014-01-01",end_date="2015-05-01",format=".xls")
install.packages("paleobiodb")
install.packages("paleobioDB", dependencies=TRUE)
library(paleobioDB)
paleodb_occurrence_curation(taxon="Bivalvia",oldest="Triassic",youngest="Jurassic",start_date="2014-01-01",end_date="2015-05-01",format=".xls")
paleodb_occurrence_curation(taxon="Dipnoi",oldest="Triassic",youngest="Jurassic",start_date="2014-01-01",end_date="2015-05-01",format=".xls")
intercontinental_links
match(max(apply(intercontinental_links, 1, sum)), apply(intercontinental_links, 1, sum))
# First find the (first) continent with the most links to other continents:#
			largest_clump <- match(max(apply(intercontinental_links, 1, sum)), apply(intercontinental_links, 1, sum))#
			largest_clump <- sort(c(largest_clump, which(intercontinental_links[largest_clump, ] == 1)))
largest_clump
# First find the (first) remaining continent with the most links to other continents:#
				largest_clump <- match(max(apply(intercontinental_links, 1, sum)), apply(intercontinental_links, 1, sum))#
				# Define the clump by those continents that form direct links to the first continent:#
				largest_clump <- sort(c(largest_clump, which(intercontinental_links[largest_clump, ] == 1)))
largest_clump
setdiff(c(1:nrow(intercontinental_links)), largest_clump)
# First find the (first) remaining continent with the most links to other continents:#
				largest_clump <- match(max(apply(intercontinental_links, 1, sum)), apply(intercontinental_links, 1, sum))#
				# Define the clump by those continents that form direct links to the first continent:#
				largest_clump <- sort(c(largest_clump, which(intercontinental_links[largest_clump, ] == 1)))#
				# Enumerate remaining continents (not directly linked to first continent#
				remaining_continents <- setdiff(c(1:nrow(intercontinental_links)), largest_clump)
remaining_continents
output <- as.character(c(1:length(longitudes)))
HowManySeparateContinents <- function(min_separation, longitudes, latitudes) {#
		# Get starting intercontinental distances:#
		intercontinental_links <- intercontinental_distance_matrix <- GreatCircleDistanceMatrix(longitudes, latitudes)#
		# For each row:#
		for(i in 1:(nrow(intercontinental_distance_matrix) - 1)) {#
			# For each column:#
			for(j in (i + 1):nrow(intercontinental_distance_matrix)) {#
				# If continents are linked:#
				if(all.equal(intercontinental_distance_matrix[i, j], min_separation) == TRUE) {#
					# Record a one for the link:#
					intercontinental_links[j, i] <- intercontinental_links[i, j] <- 1#
				# If continents are not linked:#
				} else {#
					# Record a zero for no link:#
					intercontinental_links[j, i] <- intercontinental_links[i, j] <- 0#
				}#
			}#
		}#
		# If there are no joined continents:#
		if(sum(intercontinental_links) == 0) {#
			# Simply output a vector of numbers (one for each separate continent:#
			output <- as.character(c(1:length(longitudes)))#
		# If there are joined continents:#
		} else {#
			output <- vector(mode="character")#
			# Whilst there are remaining continental links to delineate:#
			while(nrow(intercontinental_links) > 0) {#
				# First find the (first) remaining continent with the most links to other continents:#
				largest_clump <- match(max(apply(intercontinental_links, 1, sum)), apply(intercontinental_links, 1, sum))#
				# Define the clump by those continents that form direct links to the first continent:#
				largest_clump <- sort(c(largest_clump, which(intercontinental_links[largest_clump, ] == 1)))#
				# Enumerate remaining continents (not directly linked to first continent#
				remaining_continents <- setdiff(c(1:nrow(intercontinental_links)), largest_clump)#
				if(length(remaining_continents) > 0) {#
				}#
			}#
		}#
		return(output)#
	}#
	HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])
largest_clump
paste(sort(largest_clump), sep="&")
paste(sort(largest_clump), collapse="&")
intercontinental_links[largest_clump, ]
intercontinental_links[-largest_clump, -largest_clump]
intercontinental_links <- intercontinental_links[-largest_clump, -largest_clump]
# Get starting intercontinental distances:#
		intercontinental_links <- intercontinental_distance_matrix <- GreatCircleDistanceMatrix(longitudes, latitudes)
longitudes <- continent_starting_points[, "Longitude"]; latitudes <- continent_starting_points[, "Latitude"]
# Get starting intercontinental distances:#
		intercontinental_links <- intercontinental_distance_matrix <- GreatCircleDistanceMatrix(longitudes, latitudes)#
		# For each row:#
		for(i in 1:(nrow(intercontinental_distance_matrix) - 1)) {#
			# For each column:#
			for(j in (i + 1):nrow(intercontinental_distance_matrix)) {#
				# If continents are linked:#
				if(all.equal(intercontinental_distance_matrix[i, j], min_separation) == TRUE) {#
					# Record a one for the link:#
					intercontinental_links[j, i] <- intercontinental_links[i, j] <- 1#
				# If continents are not linked:#
				} else {#
					# Record a zero for no link:#
					intercontinental_links[j, i] <- intercontinental_links[i, j] <- 0#
				}#
			}#
		}
intercontinental_links
# Create empty character vector to store each set of joined continents:#
			output <- vector(mode="character")
# First find the (first) remaining continent with the most links to other continents:#
				largest_clump <- match(max(apply(intercontinental_links, 1, sum)), apply(intercontinental_links, 1, sum))#
				# Define the clump by those continents that form direct links to the first continent:#
				largest_clump <- sort(c(largest_clump, which(intercontinental_links[largest_clump, ] == 1)))#
				# Enumerate remaining continents (not directly linked to first continent):#
				remaining_continents <- setdiff(c(1:nrow(intercontinental_links)), largest_clump)
intercontinental_links[remaining_continents, ]
intercontinental_links[remaining_continents, ] == 1
which(intercontinental_links[remaining_continents, ] == 1)
for(i in remaining_continents) {#
					}
which(intercontinental_links[i, ] == 1)
match(which(intercontinental_links[i, ] == 1), largest_clump)
largest_clump
sort(match(which(intercontinental_links[i, ] == 1), largest_clump))
match(6, largest_clump)
sort(match(which(intercontinental_links[i, ] == 1), largest_clump))
sort(match(6, largest_clump))
length(sort(match(which(intercontinental_links[i, ] == 1), largest_clump)))
if(length(sort(match(which(intercontinental_links[i, ] == 1), largest_clump))) > 0) {}
i
largest_clump
c(largest_clump, i)
HowManySeparateContinents <- function(min_separation, longitudes, latitudes) {#
		# Get starting intercontinental distances:#
		intercontinental_links <- intercontinental_distance_matrix <- GreatCircleDistanceMatrix(longitudes, latitudes)#
		# For each row:#
		for(i in 1:(nrow(intercontinental_distance_matrix) - 1)) {#
			# For each column:#
			for(j in (i + 1):nrow(intercontinental_distance_matrix)) {#
				# If continents are linked:#
				if(all.equal(intercontinental_distance_matrix[i, j], min_separation) == TRUE) {#
					# Record a one for the link:#
					intercontinental_links[j, i] <- intercontinental_links[i, j] <- 1#
				# If continents are not linked:#
				} else {#
					# Record a zero for no link:#
					intercontinental_links[j, i] <- intercontinental_links[i, j] <- 0#
				}#
			}#
		}#
		# If there are no joined continents:#
		if(sum(intercontinental_links) == 0) {#
			# Simply output a vector of numbers (one for each separate continent:#
			output <- as.character(c(1:length(longitudes)))#
		# If there are joined continents:#
		} else {#
			# Create empty character vector to store each set of joined continents:#
			output <- vector(mode="character")#
			# Whilst there are remaining continental links to delineate:#
			while(nrow(intercontinental_links) > 0) {#
				# First find the (first) remaining continent with the most links to other continents:#
				largest_clump <- match(max(apply(intercontinental_links, 1, sum)), apply(intercontinental_links, 1, sum))#
				# Define the clump by those continents that form direct links to the first continent:#
				largest_clump <- sort(c(largest_clump, which(intercontinental_links[largest_clump, ] == 1)))#
				# Enumerate remaining continents (not directly linked to first continent):#
				remaining_continents <- setdiff(c(1:nrow(intercontinental_links)), largest_clump)#
				# If there are continents left to delineate:#
				if(length(remaining_continents) > 0) {#
					# For each remaining continent:#
					for(i in remaining_continents) {#
						# If the continent is linked to any continent already part of the current clump:#
						if(length(sort(match(which(intercontinental_links[i, ] == 1), largest_clump))) > 0) {#
							# Add continent to clump:#
							largest_clump <- c(largest_clump, i)#
						}#
					}#
				}	#
				# Add current continental clump to output:#
				output <- c(output, paste(sort(largest_clump), collapse="&"))#
				# Remove current continental clump from links matrix:#
				intercontinental_links <- intercontinental_links[-largest_clump, -largest_clump]#
			}#
		}#
		return(output)#
	}#
	HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])
intercontinental_links
as.vector(intercontinental_links)
intercontinental_links
intercontinental_links
colnames(intercontinental_links)
colnames(intercontinental_links) <- rownames(intercontinental_links) <- 1:length(longitudes)
intercontinental_links
colnames(intercontinental_links)
# Get starting intercontinental distances:#
		intercontinental_links <- intercontinental_distance_matrix <- GreatCircleDistanceMatrix(longitudes, latitudes)#
		# For each row:#
		for(i in 1:(nrow(intercontinental_distance_matrix) - 1)) {#
			# For each column:#
			for(j in (i + 1):nrow(intercontinental_distance_matrix)) {#
				# If continents are linked:#
				if(all.equal(intercontinental_distance_matrix[i, j], min_separation) == TRUE) {#
					# Record a one for the link:#
					intercontinental_links[j, i] <- intercontinental_links[i, j] <- 1#
				# If continents are not linked:#
				} else {#
					# Record a zero for no link:#
					intercontinental_links[j, i] <- intercontinental_links[i, j] <- 0#
				}#
			}#
		}#
#
		# Add row and column names to matrix:#
		colnames(intercontinental_links) <- rownames(intercontinental_links) <- 1:length(longitudes)
intercontinental_links
# Create empty character vector to store each set of joined continents:#
			output <- vector(mode="character")
# First find the (first) remaining continent with the most links to other continents:#
				largest_clump <- colnames(intercontinental_links)[match(max(apply(intercontinental_links, 1, sum)), apply(intercontinental_links, 1, sum))]
largest_clump
intercontinental_links[largest_clump, ]
which(intercontinental_links[largest_clump, ] == 1)
names(which(intercontinental_links[largest_clump, ] == 1))
sort(c(largest_clump, names(which(intercontinental_links[largest_clump, ] == 1))))
# First find the (first) remaining continent with the most links to other continents:#
				largest_clump <- colnames(intercontinental_links)[match(max(apply(intercontinental_links, 1, sum)), apply(intercontinental_links, 1, sum))]#
				# Define the clump by those continents that form direct links to the first continent:#
				largest_clump <- sort(c(largest_clump, names(which(intercontinental_links[largest_clump, ] == 1))))
setdiff(c(1:nrow(intercontinental_links)), largest_clump)
setdiff(colnames(intercontinental_links), largest_clump)
# First find the (first) remaining continent with the most links to other continents:#
				largest_clump <- colnames(intercontinental_links)[match(max(apply(intercontinental_links, 1, sum)), apply(intercontinental_links, 1, sum))]#
				# Define the clump by those continents that form direct links to the first continent:#
				largest_clump <- sort(c(largest_clump, names(which(intercontinental_links[largest_clump, ] == 1))))#
				# Enumerate remaining continents (not directly linked to first continent):#
				remaining_continents <- setdiff(colnames(intercontinental_links), largest_clump)
remaining_continents
length(remaining_continents) > 0
for(i in remaining_continents) {
}
intercontinental_links[i, ]
which(intercontinental_links[i, ] == 1)
names(which(intercontinental_links[i, ] == 1))
match(names(which(intercontinental_links[i, ] == 1)), largest_clump)
c(largest_clump, i)
# First find the (first) remaining continent with the most links to other continents:#
				largest_clump <- colnames(intercontinental_links)[match(max(apply(intercontinental_links, 1, sum)), apply(intercontinental_links, 1, sum))]#
				# Define the clump by those continents that form direct links to the first continent:#
				largest_clump <- sort(c(largest_clump, names(which(intercontinental_links[largest_clump, ] == 1))))#
				# Enumerate remaining continents (not directly linked to first continent):#
				remaining_continents <- setdiff(colnames(intercontinental_links), largest_clump)#
				# If there are continents left to delineate:#
				if(length(remaining_continents) > 0) {#
					# For each remaining continent:#
					for(i in remaining_continents) {#
						# If the continent is linked to any continent already part of the current clump:#
						if(length(sort(match(names(which(intercontinental_links[i, ] == 1)), largest_clump))) > 0) {#
							# Add continent to clump:#
							largest_clump <- c(largest_clump, i)#
						}#
					}#
				}
largest_clump
intercontinental_links[-largest_clump, -largest_clump]
delete_rows <- match(largest_clump, rownames(intercontinental_links))
delete_rows
intercontinental_links[-delete_rows, -delete_rows]
is.matrix(intercontinental_links)
intercontinental_links[-delete_rows, -delete_rows]
intercontinental_links[-(1:6), -(1:6)]
is.matrix(intercontinental_links[-(1:6), -(1:6)])
# First find the (first) remaining continent with the most links to other continents:#
				largest_clump <- colnames(intercontinental_links)[match(max(apply(intercontinental_links, 1, sum)), apply(intercontinental_links, 1, sum))]#
				# Define the clump by those continents that form direct links to the first continent:#
				largest_clump <- sort(c(largest_clump, names(which(intercontinental_links[largest_clump, ] == 1))))#
				# Enumerate remaining continents (not directly linked to first continent):#
				remaining_continents <- setdiff(colnames(intercontinental_links), largest_clump)#
				# If there are continents left to delineate:#
				if(length(remaining_continents) > 0) {#
					# For each remaining continent:#
					for(i in remaining_continents) {#
						# If the continent is linked to any continent already part of the current clump:#
						if(length(sort(match(names(which(intercontinental_links[i, ] == 1)), largest_clump))) > 0) {#
							# Add continent to clump:#
							largest_clump <- c(largest_clump, i)#
						}#
					}#
					# Update remaining continents:#
					remaining_continents <- setdiff(colnames(intercontinental_links), largest_clump)#
#
				}
remaining_continents
# First find the (first) remaining continent with the most links to other continents:#
				largest_clump <- colnames(intercontinental_links)[match(max(apply(intercontinental_links, 1, sum)), apply(intercontinental_links, 1, sum))]#
				# Define the clump by those continents that form direct links to the first continent:#
				largest_clump <- sort(c(largest_clump, names(which(intercontinental_links[largest_clump, ] == 1))))#
				# Enumerate remaining continents (not directly linked to first continent):#
				remaining_continents <- setdiff(colnames(intercontinental_links), largest_clump)
largest_clump
remaining_continents
intercontinental_links
output <- c(output, paste(sort(largest_clump), collapse="&"))#
				delete_rows <- match(largest_clump, rownames(intercontinental_links))#
				# Remove current continental clump from links matrix:#
				intercontinental_links <- intercontinental_links[-delete_rows, -delete_rows]
output
intercontinental_links
matrix(intercontinental_links, ncol=1, dimnames=list(remaining_continents, remaining_continents))
colnames(intercontinental_links)[match(max(apply(intercontinental_links, 1, sum)), apply(intercontinental_links, 1, sum))]
intercontinental_links
# Catch issue if no longer a matrix and force back into a 1-by-1 matrix:#
				if(!is.matrix(intercontinental_links)) intercontinental_links <- matrix(intercontinental_links, ncol=1, dimnames=list(remaining_continents, remaining_continents))
intercontinental_links
colnames(intercontinental_links)[match(max(apply(intercontinental_links, 1, sum)), apply(intercontinental_links, 1, sum))]
sort(c(largest_clump, names(which(intercontinental_links[largest_clump, ] == 1))))
setdiff(colnames(intercontinental_links), largest_clump)
intercontinental_links
length(intercontinental_links)
length(intercontinental_links) > 1
# First find the (first) remaining continent with the most links to other continents:#
				largest_clump <- colnames(intercontinental_links)[match(max(apply(intercontinental_links, 1, sum)), apply(intercontinental_links, 1, sum))]#
				# If there are multiple continents define the clump by those continents that form direct links to the first continent:#
				if(length(intercontinental_links) > 1) largest_clump <- sort(c(largest_clump, names(which(intercontinental_links[largest_clump, ] == 1))))#
				# Enumerate remaining continents (not directly linked to first continent):#
				remaining_continents <- setdiff(colnames(intercontinental_links), largest_clump)
largest_clump
remaining_continents
# Add current continental clump to output:#
				output <- c(output, paste(sort(largest_clump), collapse="&"))
output
# Find rows to delete:#
				delete_rows <- match(largest_clump, rownames(intercontinental_links))#
				# Remove current continental clump from links matrix:#
				intercontinental_links <- intercontinental_links[-delete_rows, -delete_rows]#
				# Catch issue if no longer a matrix and force back into a 1-by-1 matrix:#
				if(!is.matrix(intercontinental_links)) intercontinental_links <- matrix(intercontinental_links, ncol=1, dimnames=list(remaining_continents, remaining_continents))
intercontinental_links
nrow(intercontinental_links) > 0
HowManySeparateContinents <- function(min_separation, longitudes, latitudes) {#
		# Get starting intercontinental distances:#
		intercontinental_links <- intercontinental_distance_matrix <- GreatCircleDistanceMatrix(longitudes, latitudes)#
		# For each row:#
		for(i in 1:(nrow(intercontinental_distance_matrix) - 1)) {#
			# For each column:#
			for(j in (i + 1):nrow(intercontinental_distance_matrix)) {#
				# If continents are linked:#
				if(all.equal(intercontinental_distance_matrix[i, j], min_separation) == TRUE) {#
					# Record a one for the link:#
					intercontinental_links[j, i] <- intercontinental_links[i, j] <- 1#
				# If continents are not linked:#
				} else {#
					# Record a zero for no link:#
					intercontinental_links[j, i] <- intercontinental_links[i, j] <- 0#
				}#
			}#
		}#
#
		# Add row and column names to matrix:#
		colnames(intercontinental_links) <- rownames(intercontinental_links) <- 1:length(longitudes)#
		# If there are no joined continents:#
		if(sum(intercontinental_links) == 0) {#
			# Simply output a vector of numbers (one for each separate continent):#
			output <- colnames(intercontinental_links)#
		# If there are joined continents:#
		} else {#
			# Create empty character vector to store each set of joined continents:#
			output <- vector(mode="character")#
			# Whilst there are remaining continental links to delineate:#
			while(nrow(intercontinental_links) > 0) {#
				# First find the (first) remaining continent with the most links to other continents:#
				largest_clump <- colnames(intercontinental_links)[match(max(apply(intercontinental_links, 1, sum)), apply(intercontinental_links, 1, sum))]#
				# If there are multiple continents define the clump by those continents that form direct links to the first continent:#
				if(length(intercontinental_links) > 1) largest_clump <- sort(c(largest_clump, names(which(intercontinental_links[largest_clump, ] == 1))))#
				# Enumerate remaining continents (not directly linked to first continent):#
				remaining_continents <- setdiff(colnames(intercontinental_links), largest_clump)#
				# If there are continents left to delineate:#
				if(length(remaining_continents) > 0) {#
					# For each remaining continent:#
					for(i in remaining_continents) {#
						# If the continent is linked to any continent already part of the current clump:#
						if(length(sort(match(names(which(intercontinental_links[i, ] == 1)), largest_clump))) > 0) {#
							# Add continent to clump:#
							largest_clump <- c(largest_clump, i)#
						}#
					}#
					# Update remaining continents:#
					remaining_continents <- setdiff(colnames(intercontinental_links), largest_clump)#
#
				}	#
				# Add current continental clump to output:#
				output <- c(output, paste(sort(largest_clump), collapse="&"))#
				# Find rows to delete:#
				delete_rows <- match(largest_clump, rownames(intercontinental_links))#
				# Remove current continental clump from links matrix:#
				intercontinental_links <- intercontinental_links[-delete_rows, -delete_rows]#
				# Catch issue if no longer a matrix and force back into a 1-by-1 matrix:#
				if(!is.matrix(intercontinental_links)) intercontinental_links <- matrix(intercontinental_links, ncol=1, dimnames=list(remaining_continents, remaining_continents))#
			}#
		}#
		# Return unique continent list:#
		return(output)#
	}#
	HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])
GreatCircleDistanceMatrix
getwd()
document()
document()
document()
document()
document()
# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)#
# Are any continents joined at start?:#
#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
#
	HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])
runif(length(separate_continents), 180, -180)
# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)#
# Are any continents joined at start?:#
#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
#
	# Get list of separate continents:#
	separate_continents <- HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
# Assign Euler poles to each separate continent:#
	runif(length(separate_continents), 180, -180)
length(separate_continents)
?runif
runif(length(separate_continents), -180, 180)
euler_pole_longitudes <- runif(length(separate_continents), -180, 180)#
	euler_pole_latitudes <- runif(length(separate_continents), -90, 90)
euler_pole_longitudes
euler_pole_latitudes
euler_pole_latitudes
euler_pole_latitudes == 90
euler_pole_latitudes == -90
sum(euler_pole_latitudes == 90)
if((sum(euler_pole_latitudes == 90) + sum(euler_pole_latitudes == -90)) > 0)
{}
(sum(euler_pole_latitudes == 90) + sum(euler_pole_latitudes == -90)) > 0
# Assign Euler poles to each separate continent:#
	# Randomly draw longitudes for each separated continent:#
	euler_pole_longitudes <- runif(length(separate_continents), -180, 180)#
	# Randomly draw latitudes for each separated continent:#
	euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
	# Ensure no latitude is directly at a pole (North or South) by redrawing if any are found:#
	if((sum(euler_pole_latitudes == 90) + sum(euler_pole_latitudes == -90)) > 0) euler_pole_latitudes <- runif(length(separate_continents), -90, 90)
euler_pole_longitudes
euler_pole_latitudes
for(i in 1:length(separate_continents)) {#
	}
i
continent_starting_points
# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)
install_github("laurasoul/dispeRse")#
#
# Load the dispeRse package into R:#
library(dispeRse)
# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)
check()
build()
install()
