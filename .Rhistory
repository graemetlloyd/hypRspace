GetThetaFromChordLength(GetChordLengthFromTheta(2))
GetThetaFromChordLength(GetChordLengthFromTheta(3))
GetThetaFromChordLength(GetChordLengthFromTheta(0.5))
GetThetaFromChordLength(GetChordLengthFromTheta(0.01))
GetBearing(first_circle_long, first_circle_lat, second_circle_long, second_circle_lat)
GetBearing(first_circle_long, first_circle_lat, second_circle_long, second_circle_lat) + 60
(GetBearing(first_circle_long, first_circle_lat, second_circle_long, second_circle_lat) + 60) %% 360
EndPoint(first_circle_long, first_circle_lat, (GetBearing(first_circle_long, first_circle_lat, second_circle_long, second_circle_lat) + 60) %% 360, min_separation)
GetGreatCircleDistanceFromLongLat(second_circle_long, second_circle_lat, EndPoint(first_circle_long, first_circle_lat, (GetBearing(first_circle_long, first_circle_lat, second_circle_long, second_circle_lat) + 60) %% 360, min_separation)$long, EndPoint(first_circle_long, first_circle_lat, (GetBearing(first_circle_long, first_circle_lat, second_circle_long, second_circle_lat) + 60) %% 360, min_separation)$lat)
# GreatCircleDistance function:#
	GetGreatCircleDistanceFromLongLat <- function(long1, lat1, long2, lat2, EarthRad = 6367.4447) {#
#
		long1 <- long1 * (pi / 180)#
		lat1 <- lat1 * (pi / 180)#
		long2 <- long2 * (pi / 180)#
		lat2 <- lat2 * (pi / 180)#
# Maybe replace this with Haversine:#
		gcdist <- acos(sin(lat1) * sin(lat2) + cos(lat1) * cos(lat2) * cos(abs(long1 - long2))) * EarthRad#
#
		return(gcdist)#
	}#
	GetBearing <- function(start_long, start_lat, end_long, end_lat) {#
# Check that lat and long are not both identical (where no bearing is possible)#
		start_long <- start_long * (pi / 180)#
		start_lat <- start_lat * (pi / 180)#
		end_long <- end_long * (pi / 180)#
		end_lat <- end_lat * (pi / 180)#
		bearing <- atan2(sin(end_long - start_long) * cos(end_lat), cos(start_lat) * sin(end_lat) - sin(start_lat) * cos(end_lat) * cos(end_long - start_long))#
		bearing <- bearing / (pi / 180)#
		bearing <- (bearing + 360) %% 360#
		return(bearing)#
	}#
	# Get theta in radians from great circle distance:#
	GetThetaFromGreatCircleDistance <- function(great_circle_distance, EarthRad = 6367.4447) {#
		# Get theta in radians from great circle distance:#
		great_circle_distance / EarthRad#
	}#
	# Get chord length from theta in radians and radius in km:#
	GetChordLengthFromTheta <- function(theta, EarthRad = 6367.4447) {#
		# Get chord length from theta (in radians):#
		sin(theta / 2) * EarthRad * 2#
	}#
	# Get theta in radians from chord length and radius in km:#
	GetThetaFromChordLength <- function(chord_length, EarthRad = 6367.4447) {#
		# Get theta in radians from chord length and radius in km:#
		asin((chord_length * 0.5) / EarthRad) * 2#
	}#
	# Get great circle distacne from theta in radians and radius in km:#
	GetGreatCircleDistanceFromTheta <- function(theta, EarthRad = 6367.4447) {#
		# Calculate great circle distance from theta in radians:#
		theta * EarthRad#
	}
# Establish minimum distance between continent centres (:#
		min_separation <- (1 - squishiness) * radius * 2#
# If squishiness is zero then all continents begin with same centre!!!!!!!#
# Need conditional to reflect this.#
		# Randomly assign starting longitude:#
		first_circle_long <- runif(1, min = -180, max = 180)#
#
		# Randomly assign starting latitude:#
		first_circle_lat <- runif(1, min = -90, max = 90)
min_separation
radius
squishiness
squishiness = 0.25
# Establish minimum distance between continent centres (:#
		min_separation <- (1 - squishiness) * radius * 2#
# If squishiness is zero then all continents begin with same centre!!!!!!!#
# Need conditional to reflect this.#
		# Randomly assign starting longitude:#
		first_circle_long <- runif(1, min = -180, max = 180)#
#
		# Randomly assign starting latitude:#
		first_circle_lat <- runif(1, min = -90, max = 90)
min_separation
radius
(1 - squishiness) * radius
# Find centre of second continnet by randomly drawing from the circle describing all points within minimum separation of the first continent:#
			second_circle <- EndPoint(slong = first_circle_long, slat = first_circle_lat, bearing = runif(1, min = 0, max = 360), distance = min_separation)#
#
			# Isolate longitude of second continent:#
			second_circle_long <- second_circle$long#
			# Isolate latitude of second continent:#
			second_circle_lat <- second_circle$lat
GetGreatCircleDistanceFromLongLat(second_circle_long, second_circle_lat, EndPoint(first_circle_long, first_circle_lat, (GetBearing(first_circle_long, first_circle_lat, second_circle_long, second_circle_lat) + 60) %% 360, min_separation)$long, EndPoint(first_circle_long, first_circle_lat, (GetBearing(first_circle_long, first_circle_lat, second_circle_long, second_circle_lat) + 60) %% 360, min_separation)$lat)
EndPoint(0, 90, 180, min_separation)
# Start at pole and head south for the same distance as minimum spearation:#
				South_Point_1 <- EndPoint(0, 90, 180, min_separation)
South_Point_1 <- EndPoint(0, 90, 180, min_separation)#
				EndPoint(South_Point_1$long, South_Point_1$lat, 90, min_separation)
EndPoint(South_Point_1$long, South_Point_1$lat, 90, min_separation)$long - South_Point_1$long
EndPoint(South_Point_1$long, South_Point_1$lat, 90, min_separation)
South_Point_1 <- EndPoint(0, 90, 180, min_separation)#
				South_Point_2 <- EndPoint(South_Point_1$long, South_Point_1$lat, 90, min_separation)
South_Point_1
South_Point_2
GetGreatCircleDistanceFromLongLat(0, 90, South_Point_2$long, South_Point_2$lat)
EndPoint(0, 90, 180, min_separation)
# Start at pole and head south for the same distance as minimum spearation:#
				South_Point_1 <- EndPoint(0, 90, 180, min_separation)#
				South_Point_2 <- EndPoint(South_Point_1$long, South_Point_1$lat, 90, min_separation)
South_Point_1
South_Point_2
South_Point_1
min_separation / 111.2
90 - (min_separation / 111.2)
EarthRad
EndPoint(0, South_Point_1$lat, 90, min_separation)
EndPoint
EndPoint()
EndPoint(distance=111.2)
pi * bearing / 180
bearing<-90
pi * bearing / 180
bearing=0
pi * bearing / 180
asin(90) * (180 / pi)
asin(theta) * (180 / pi)
theta
asin(1) * (180 / pi)
asin(pi) * (180 / pi)
asin(0) * (180 / pi)
asin(0.4) * (180 / pi)
asin(0.8) * (180 / pi)
sin(90 / (180 * pi))
sin(0 / (180 * pi))
sin(0 / (pi / 180))
sin(90 / (pi / 180))
sin(90 * (pi / 180))
sin(80 * (pi / 180))
sin(70 * (pi / 180))
sin(60 * (pi / 180))
sin(50 * (pi / 180))
sin(40 * (pi / 180))
sin(30 * (pi / 180))
sin(abs(30) * (pi / 180))
sin(abs(lat) * (pi / 180))
side_lengt<-min_separation
side_length<-min_separation
side_length
side_length / (2 * pi * EarthRad)
EarthRad = 6367.4447
side_length / (2 * pi * EarthRad)
(side_length * 360) / (2 * pi * EarthRad)
90 - ((side_length * 360) / (2 * pi * EarthRad))
# Get the latitude if travelling south for side-length distance from North pole:#
				latitude_from_north_pole <- 90 - ((side_length * 360) / (2 * pi * EarthRad))
sin(abs(latitude_from_north_pole) * (pi / 180)) * EarthRad
# Get the latitude if travelling south for side-length distance from North pole:#
					latitude_from_north_pole <- 90 - ((side_length * 360) / (2 * pi * EarthRad))#
					# Get adjacent length (height above centre of sphere that corresponds to latitude just derived:#
					adjacent_length <- sin(abs(latitude_from_north_pole) * (pi / 180)) * EarthRad#
#
					# Get opposite length (radius of small circle along which we wish to travel):#
					opposite_length <- sqrt((EarthRad ^ 2) - (adjacent_length ^ 2))
opposite_length
2 * pi * opposite_length
side_length / (2 * pi * opposite_length)
(side_length * 360) / (2 * pi * opposite_length)
sin(90)
sin(180)
sin(seq(360, 0, 360))
sin(seq(360, 1, 360))
latitude_from_north_pole
abs(latitude_from_north_pole) * (pi / 180)
sin(latitude_from_north_pole)
sin(abs(latitude_from_north_pole) * (pi / 180))
# Get the latitude if travelling south for side-length distance from North pole:#
					latitude_from_north_pole <- 90 - ((side_length * 360) / (2 * pi * EarthRad))#
					# Get adjacent length (height above centre of sphere that corresponds to latitude just derived:#
					adjacent_length <- sin(abs(latitude_from_north_pole) * (pi / 180)) * EarthRad#
					adjacent_length <- sin(latitude_from_north_pole) * EarthRad#
#
					# Get opposite length (radius of small circle along which we wish to travel):#
					opposite_length <- sqrt((EarthRad ^ 2) - (adjacent_length ^ 2))
opposite_length
(side_length * 360) / (2 * pi * opposite_length)
adjacent_length
latitude_from_north_pole
# Get the latitude if travelling south for side-length distance from North pole:#
					latitude_from_north_pole <- 90 - ((side_length * 360) / (2 * pi * EarthRad))#
					# Get adjacent length (height above centre of sphere that corresponds to latitude just derived:#
					adjacent_length <- sin(abs(latitude_from_north_pole) * (pi / 180)) * EarthRad#
					adjacent_length <- sin(latitude_from_north_pole) * EarthRad
adjacent_length
sin(abs(latitude_from_north_pole) * (pi / 180)) * EarthRad
EarthRad
side_length / (2 * pi * opposite_length)
360 / (side_length / (2 * pi * opposite_length))
# Get the latitude if travelling south for side-length distance from North pole:#
					latitude_from_north_pole <- 90 - ((side_length * 360) / (2 * pi * EarthRad))#
					# Get adjacent length (height above centre of sphere that corresponds to latitude just derived:#
					adjacent_length <- sin(abs(latitude_from_north_pole) * (pi / 180)) * EarthRad#
					adjacent_length <- cos(latitude_from_north_pole) * EarthRad#
#
					# Get opposite length (radius of small circle along which we wish to travel):#
					opposite_length <- sqrt((EarthRad ^ 2) - (adjacent_length ^ 2))
opposite_length
adjacent_length
side_length / (2 * pi * adjacent_length)
?atan
s <- (3 * side_length) / 2
4 * atan(sqrt(tan(s / 2) * tan((s - side_length) / 2) * tan((s - side_length) / 2) * tan((s - side_length) / 2)))
s
side_length
sqrt(tan(s / 2) * tan((s - side_length) / 2) * tan((s - side_length) / 2) * tan((s - side_length) / 2))
tan(s / 2)
tan((s - side_length) / 2)
tan(s / 2) * tan((s - side_length) / 2) * tan((s - side_length) / 2) * tan((s - side_length) / 2)
tan(1.1)
tan(90)
tan(0)
tan(180)
tan(270)
tan(360)
tan(1234801)
tan(-1234801)
s - side_length
side_length
s <- (3 * side_length) / 2
tan((s - side_length) / 2)
?geosphere
areaPolygon
areaPolygon-method
?geosphere
showMethods("areaPolygon")
library(geosphere)
min_separation
min_separation * 2
GetThetaFromGreatCircleDistance(min_separation * 2)
GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(min_separation * 2))
x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))
x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
				(y / 2)  / (z / 2)
asin((y / 2) / (z / 2))
asin((y / 2) / (z / 2)) * (pi / 180)
asin((y / 2) / (z / 2)) / (pi / 180)
asin((y / 2) / (z / 2)) / (pi / 180) * 2
x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2
spherical_angle
first_circle_long
first_circle_lat
GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat)
GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat) + spherical_angle
(GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat) + spherical_angle)
(GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat) + spherical_angle) %% 360
x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2#
#
				new_bearing <- (GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat) + spherical_angle) %% 360
EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)
GetGreatCircleDistanceFromLongLat(second_circle_long, second_circle_lat, EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)$long, EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)$lat)
min_separation
x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2#
#
				new_bearing <- (GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat) - spherical_angle) %% 360#
				GetGreatCircleDistanceFromLongLat(second_circle_long, second_circle_lat, EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)$long, EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)$lat)
min_separation
x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2#
#
				new_bearing <- (GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat) - spherical_angle) %% 360#
				GetGreatCircleDistanceFromLongLat(first_circle_long, first_circle_lat, EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)$long, EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)$lat)
x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2#
#
				new_bearing <- (GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat) + spherical_angle) %% 360#
				GetGreatCircleDistanceFromLongLat(first_circle_long, first_circle_lat, EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)$long, EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)$lat)
GetGreatCircleDistanceFromLongLat(second_circle_long, second_circle_lat, first_circle_long, first_circle_lat)
spherical_angle
min_separation
x <- min_separation * 2
x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
				x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2
spherical_angle
x <- min_separation *  2#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2
spherical_angle
x <- min_separation * 4#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2
spherical_angle
2 * pi * EarthRad
0.5 * pi * EarthRad
x <- 0.5 * pi * EarthRad
y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2
spherical_angle
x <- 0.0000000001#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2
spherical_angle
# Get the spherical angle for an equilateral triangle where its sides (as great circle distances) are known:#
	GetSphericalAngleForEquilateralTriangleFromGreatCircleSideLength <- function(side_length, EarthRad = 6367.4447) {#
# Check this works for triangles larger than equivalent of 90-degrees of latitude on each side!#
		# Get y (which will be double the opposite for the triangle we are trying to solve):#
		y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(side_length))#
		# Get z which will be double the hypotenuse for the triangle we are trying to solve):#
		z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(side_length * 2))#
		# Solve the traingle for theta (the spherical angle) and convert to degrees:#
		spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2#
		# Return the spherical angle:#
		return(spherical_angle)#
	}
GetSphericalAngleForEquilateralTriangleFromGreatCircleSideLength(min_separation)
spherical_angle
spherical_angle <- GetSphericalAngleForEquilateralTriangleFromGreatCircleSideLength(min_separation)
spherical_angle
new_bearing <- (GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat) - spherical_angle) %% 360
new_bearing
GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat)
spherical_angle <- GetSphericalAngleForEquilateralTriangleFromGreatCircleSideLength(min_separation)#
				new_bearing_1 <- (GetBearing(first_circle_long, first_circle_lat, second_circle_long, second_circle_lat) - spherical_angle) %% 360#
				new_bearing_2 <- (GetBearing(first_circle_long, first_circle_lat, second_circle_long, second_circle_lat) + spherical_angle) %% 360#
				new_continent_1 <- EndPoint(first_circle_long, first_circle_lat, new_bearing_1, min_separation)#
				new_continent_2 <- EndPoint(first_circle_long, first_circle_lat, new_bearing_2, min_separation)#
				GetGreatCircleDistanceFromLongLat(second_circle_long, second_circle_lat, first_circle_long, first_circle_lat)#
#
				GetGreatCircleDistanceFromLongLat(second_circle_long, second_circle_lat, new_continent_1$long, new_continent_1$lat)#
				GetGreatCircleDistanceFromLongLat(second_circle_long, second_circle_lat, new_continent_2$long, new_continent_2$lat)
sample(c(1, 2), 1)
new_continent_1
unlist(new_continent_1)
rbind(unlist(new_continent_1), unlist(new_continent_2))
rbind(unlist(new_continent_1), unlist(new_continent_2))[, 1:2]
rbind(unlist(new_continent_1), unlist(new_continent_2))[, c("long", "lat")]
rbind(unlist(new_continent_1), unlist(new_continent_2))[, c("long", "lat")][sample(c(1, 2), 1), ]
# Get spherical angle of equilateral (spherical) triangle with sides equal to minimum separation:#
				spherical_angle <- GetSphericalAngleForEquilateralTriangleFromGreatCircleSideLength(min_separation)#
#
				# Get first of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_1 <- (GetBearing(first_circle_long, first_circle_lat, second_circle_long, second_circle_lat) - spherical_angle) %% 360#
				# Get second of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_2 <- (GetBearing(first_circle_long, first_circle_lat, second_circle_long, second_circle_lat) + spherical_angle) %% 360#
				# Get lat-long coordinates of first possible site of third continent:#
				new_continent_1 <- EndPoint(first_circle_long, first_circle_lat, new_bearing_1, min_separation)#
				# Get lat-long coordinates of second possible site of third continent:#
				new_continent_2 <- EndPoint(first_circle_long, first_circle_lat, new_bearing_2, min_separation)#
				# Randomly pick site for third continent:#
				third_circle <- rbind(unlist(new_continent_1), unlist(new_continent_2))[, c("long", "lat")][sample(c(1, 2), 1), ]
third_circle
third_circle$long
third_circle["long"]
c(1, first_circle_long, first_circle_lat)
matrix(c(1, first_circle_long, first_circle_lat), ncol=3)
matrix(c(1, first_circle_long, first_circle_lat), ncol=3, dimnames=list(c(), c("Circle", "Longitude", "Latitude")))
circles
# Create matrix to store circles:#
		circles <- matrix(c(1, first_circle_long, first_circle_lat), ncol=3, dimnames=list(c(), c("Circle", "Longitude", "Latitude")))
c(2, second_circle$long, second_circle$lat)
rbind(circles, c(2, second_circle$long, second_circle$lat))
# Add second continent to circles matrix:#
			circles <- rbind(circles, c(2, second_circle$long, second_circle$lat))
c(3, third_circle["long"], third_circle["lat"])
rbind(circles, c(3, third_circle["long"], third_circle["lat"]))
N_continents
N_continents <- 7
N_continents > nrow(circles)
library(dispeRse)
N_continents = 7; radius = 2000; start_configuration = "supercontinent"; squishiness = 0.25
# If the start configuration is a supercontinnet (all continents attached togther):#
	if(start_configuration == "supercontinent") {#
		# Establish minimum distance between continent centres (:#
		min_separation <- (1 - squishiness) * radius * 2#
# If squishiness is zero and option == "supercontinet" then all continents begin with same centre!!!!!!!#
# Need conditional to reflect this.#
		# Randomly assign starting longitude:#
		first_circle_long <- runif(1, min = -180, max = 180)#
#
		# Randomly assign starting latitude:#
		first_circle_lat <- runif(1, min = -90, max = 90)#
		# Create matrix to store circles:#
		circles <- matrix(c(1, first_circle_long, first_circle_lat), ncol=3, dimnames=list(c(), c("Circle", "Longitude", "Latitude")))#
		# If there are two or more continents still to place:#
		if(N_continents > 1) {#
			# Find centre of second continnet by randomly drawing from the circle describing all points within minimum separation of the first continent:#
			second_circle <- EndPoint(slong = first_circle_long, slat = first_circle_lat, bearing = runif(1, min = 0, max = 360), distance = min_separation)#
#
			# Add second continent to circles matrix:#
			circles <- rbind(circles, c(2, second_circle$long, second_circle$lat))#
			# If there are more than two continents still to place:#
			if(N_continents > 2) {#
				# Get spherical angle of equilateral (spherical) triangle with sides equal to minimum separation:#
				spherical_angle <- SphericalAngleForEquilateralTriangleFromGreatCircleSideLength(min_separation)#
#
				# Get first of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_1 <- (BearingBetweenTwoLongLatPoints(circles[1, "Longitude"], circles[1, "Latitude"], circles[2, "Longitude"], circles[2, "Latitude"]) - spherical_angle) %% 360#
				# Get second of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_2 <- (BearingBetweenTwoLongLatPoints(circles[1, "Longitude"], circles[1, "Latitude"], circles[2, "Longitude"], circles[2, "Latitude"]) + spherical_angle) %% 360#
				# Get lat-long coordinates of first possible site of third continent:#
				new_continent_1 <- EndPoint(circles[1, "Longitude"], circles[1, "Latitude"], new_bearing_1, min_separation)[c("long", "lat")]#
				# Get lat-long coordinates of second possible site of third continent:#
				new_continent_2 <- EndPoint(circles[1, "Longitude"], circles[1, "Latitude"], new_bearing_2, min_separation)[c("long", "lat")]#
				# Randomly pick site for third continent:#
				third_continent_picked <- sample(c(1, 2), 1)#
				# Randomly pick site for third continent:#
				third_circle <- rbind(unlist(new_continent_1), unlist(new_continent_2))[third_continent_picked, ]#
				# Add third continent to circles matrix:#
				circles <- rbind(circles, c(3, third_circle))#
# Little plot to check things look like they are working OK!:#
#library(maps)#
#map()#
#points(circles[, "Longitude"], circles[, "Latitude"], pch=19, col="red")#
				# If there are more than three continents:#
				if(N_continents > 3) {#
					# Create new matrix for open spots (centres where new continents may reside) with unused spot from third continent choice:#
					open_spots <- matrix(rbind(unlist(new_continent_1), unlist(new_continent_2))[setdiff(c(1:2), third_continent_picked), ], ncol=2)#
					# Add column names:#
					colnames(open_spots) <- c("Longitude", "Latitude")#
					# Vector to store distances from centres:#
					distances_from_centres <- vector(mode="numeric")#
					# For each pre-existing continent:#
					for(i in 1:3) {#
						# Get distance from open spot to ith continent centre:#
						distances_from_centres[i] <- GreatCircleDistanceFromLongLat(open_spots[, "Longitude"], open_spots[, "Latitude"], circles[i, "Longitude"], circles[i, "Latitude"])#
					}#
					# Identify continent centre furthest from current single open spot:#
					furthest_point <- match(max(distances_from_centres), distances_from_centres)#
#
					# Get bearing from furthest point to first of the two other continent centres:#
					first_bearing <- BearingBetweenTwoLongLatPoints(circles[furthest_point, "Longitude"], circles[furthest_point, "Latitude"], circles[setdiff(c(1:3), furthest_point)[1], "Longitude"], circles[setdiff(c(1:3), furthest_point)[1], "Latitude"])#
#
					# Get bearing from furthest point to second of the two other continent centres:#
					second_bearing <- BearingBetweenTwoLongLatPoints(circles[furthest_point, "Longitude"], circles[furthest_point, "Latitude"], circles[setdiff(c(1:3), furthest_point)[2], "Longitude"], circles[setdiff(c(1:3), furthest_point)[2], "Latitude"])#
					# Get bearings from furthest point to the two new open spots:#
					new_bearings <- as.vector(sort(c(first_bearing - spherical_angle, first_bearing + spherical_angle, second_bearing - spherical_angle, second_bearing + spherical_angle))[c(1, 4)] %% 360)#
					# Add first new open spot to list:#
					open_spots <- rbind(open_spots, as.vector(unlist(EndPoint(circles[furthest_point, "Longitude"], circles[furthest_point, "Latitude"], new_bearings[1], min_separation)[c("long", "lat")])))#
					# Add second new open spot to list:#
					open_spots <- rbind(open_spots, as.vector(unlist(EndPoint(circles[furthest_point, "Longitude"], circles[furthest_point, "Latitude"], new_bearings[2], min_separation)[c("long", "lat")])))#
					# Keep adding continents unless they all have starting points:#
					while(N_continents > nrow(circles)) {#
# If no new open spots then stop#
# Make sure open spots is always a matrix too!#
						# Randomly pick an open spot to place a new continent:#
						new_continent_point <- sample(c(1:nrow(open_spots)))[1]#
						# Vector to store row numbers for adjacent continents:#
						adjacent_continents <- vector(mode="numeric")#
						# For each pre-existing continent:#
						for(i in 1:nrow(circles)) {#
							# Is the distance from the new continent to the ith pre-existing continent equal to the minimum continental separation?:#
							equal_check <- all.equal(as.vector(GreatCircleDistanceFromLongLat(open_spots[new_continent_point, "Longitude"], open_spots[new_continent_point, "Latitude"], circles[i, "Longitude"], circles[i, "Latitude"])), min_separation)#
#
							# If one of the nearest continents then add to the list:#
							if(equal_check == TRUE) adjacent_continents <- c(adjacent_continents, i)#
						}#
						# Vector to store bearings from new continent to adjacent continents:#
						bearings_to_adjacents <- vector(mode="numeric")#
						# For each continent adjacent to the new continent:#
						for(i in adjacent_continents) {#
							# Store bearing from new continent to ith adjacent continent:#
							bearings_to_adjacents <- as.vector(c(bearings_to_adjacents, BearingBetweenTwoLongLatPoints(open_spots[new_continent_point, "Longitude"], open_spots[new_continent_point, "Latitude"], circles[i, "Longitude"], circles[i, "Latitude"])))#
						}#
						# Vector to store bearings to potential new open spots:#
						new_bearings <- vector(mode="numeric")#
						# For each bearing to an adjacent continent:#
						for(i in 1:length(bearings_to_adjacents)) {#
							# Get new bearings from plus or minus the psherical angle from the current ebarings:#
							new_bearings <- c(new_bearings, c(bearings_to_adjacents[i] + spherical_angle, bearings_to_adjacents[i] - spherical_angle))#
						}#
						# Get bearings from new continent to two new potential open spots:#
						new_bearings <- sort(new_bearings)[c(1, length(new_bearings))] %% 360#
						# Store potential new open spots for further vetting:#
						potential_new_open_spots <- rbind(as.vector(unlist(EndPoint(open_spots[new_continent_point, "Longitude"], open_spots[new_continent_point, "Latitude"], new_bearings[1], min_separation)[c("long", "lat")])), as.vector(unlist(EndPoint(open_spots[new_continent_point, "Longitude"], open_spots[new_continent_point, "Latitude"], new_bearings[2], min_separation)[c("long", "lat")])))#
						# Add column names:#
						colnames(potential_new_open_spots) <- c("Longitude", "Latitude")#
						# Add new continent to circles matrix:#
						circles <- rbind(circles, c(nrow(circles) + 1, open_spots[new_continent_point, ]))#
						# Vector to store unsuitable new spots (those that are closer than minimum separation to existing continents):#
						unsuitable_spots <- vector(mode="numeric")#
						# For each potential new spot:#
						for(i in 1:2) {#
							# For each existing continent:#
							for(j in 1:nrow(circles)) {#
								# Get distance from ith potential new open spot to jth existing continent:#
								distance_between_centres <- as.vector(GreatCircleDistanceFromLongLat(potential_new_open_spots[i, "Longitude"], potential_new_open_spots[i, "Latitude"], circles[j, "Longitude"], circles[j, "Latitude"]))#
								# If ith potential new open spot is closer to a pre-existing continent than the minimum spearation allows add to unsuitable spots:#
								if(all.equal(distance_between_centres, min_separation) != TRUE && distance_between_centres < min_separation) unsuitable_spots <- as.vector(c(unsuitable_spots, i))#
							}#
						}#
						# If there are unsuitable spots:#
						if(length(unsuitable_spots) > 0) {#
							# Remove unsuitable spots from potential new spots:#
							potential_new_open_spots <- potential_new_open_spots[-unique(unsuitable_spots), ]#
							# If deletions has de-matrixed the data:#
							if(!is.matrix(potential_new_open_spots)) {#
								# Make back into matrix:#
								potential_new_open_spots <- matrix(potential_new_open_spots, ncol=2)#
							}#
							# Add column names:#
							colnames(potential_new_open_spots) <- c("Longitude", "Latitude")#
						}#
						# Add new potential open spots to open spots:#
						open_spots <- rbind(open_spots, potential_new_open_spots)#
#
						# Remove new continent from open spots:#
						open_spots <- open_spots[-new_continent_point, ]#
						# If deletions has de-matrixed the data:#
						if(!is.matrix(open_spots)) {#
							# Make back into matrix:#
							open_spots <- matrix(open_spots, ncol=2)#
						}#
						# Add column names:#
						colnames(open_spots) <- c("Longitude", "Latitude")#
#
					}#
				}#
			# If only two continents:#
			} else {#
# Output#
			}#
		# If only one continent:#
		} else {#
# Output#
		}#
	}#
	library(sphereplot)#
	rgl.sphgrid()#
	rgl.sphpoints(circles[, "Longitude"], circles[, "Latitude"], 1, deg=TRUE, col="red", cex=2)#
	rgl.sphpoints(open_spots[, "Longitude"], open_spots[, "Latitude"], 1, deg=TRUE, col="blue", cex=2)
setwd("~/Documents/Publications/in prep/dispeRse")
install()
libary(devtools)
library(devtools)
install()
library(dispeRse)
# If the start configuration is a supercontinnet (all continents attached togther):#
	if(start_configuration == "supercontinent") {#
		# Establish minimum distance between continent centres (:#
		min_separation <- (1 - squishiness) * radius * 2#
# If squishiness is zero and option == "supercontinet" then all continents begin with same centre!!!!!!!#
# Need conditional to reflect this.#
		# Randomly assign starting longitude:#
		first_circle_long <- runif(1, min = -180, max = 180)#
#
		# Randomly assign starting latitude:#
		first_circle_lat <- runif(1, min = -90, max = 90)#
		# Create matrix to store circles:#
		circles <- matrix(c(1, first_circle_long, first_circle_lat), ncol=3, dimnames=list(c(), c("Circle", "Longitude", "Latitude")))#
		# If there are two or more continents still to place:#
		if(N_continents > 1) {#
			# Find centre of second continnet by randomly drawing from the circle describing all points within minimum separation of the first continent:#
			second_circle <- EndPoint(slong = first_circle_long, slat = first_circle_lat, bearing = runif(1, min = 0, max = 360), distance = min_separation)#
#
			# Add second continent to circles matrix:#
			circles <- rbind(circles, c(2, second_circle$long, second_circle$lat))#
			# If there are more than two continents still to place:#
			if(N_continents > 2) {#
				# Get spherical angle of equilateral (spherical) triangle with sides equal to minimum separation:#
				spherical_angle <- SphericalAngleForEquilateralTriangleFromGreatCircleSideLength(min_separation)#
#
				# Get first of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_1 <- (BearingBetweenTwoLongLatPoints(circles[1, "Longitude"], circles[1, "Latitude"], circles[2, "Longitude"], circles[2, "Latitude"]) - spherical_angle) %% 360#
				# Get second of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_2 <- (BearingBetweenTwoLongLatPoints(circles[1, "Longitude"], circles[1, "Latitude"], circles[2, "Longitude"], circles[2, "Latitude"]) + spherical_angle) %% 360#
				# Get lat-long coordinates of first possible site of third continent:#
				new_continent_1 <- EndPoint(circles[1, "Longitude"], circles[1, "Latitude"], new_bearing_1, min_separation)[c("long", "lat")]#
				# Get lat-long coordinates of second possible site of third continent:#
				new_continent_2 <- EndPoint(circles[1, "Longitude"], circles[1, "Latitude"], new_bearing_2, min_separation)[c("long", "lat")]#
				# Randomly pick site for third continent:#
				third_continent_picked <- sample(c(1, 2), 1)#
				# Randomly pick site for third continent:#
				third_circle <- rbind(unlist(new_continent_1), unlist(new_continent_2))[third_continent_picked, ]#
				# Add third continent to circles matrix:#
				circles <- rbind(circles, c(3, third_circle))#
# Little plot to check things look like they are working OK!:#
#library(maps)#
#map()#
#points(circles[, "Longitude"], circles[, "Latitude"], pch=19, col="red")#
				# If there are more than three continents:#
				if(N_continents > 3) {#
					# Create new matrix for open spots (centres where new continents may reside) with unused spot from third continent choice:#
					open_spots <- matrix(rbind(unlist(new_continent_1), unlist(new_continent_2))[setdiff(c(1:2), third_continent_picked), ], ncol=2)#
					# Add column names:#
					colnames(open_spots) <- c("Longitude", "Latitude")#
					# Vector to store distances from centres:#
					distances_from_centres <- vector(mode="numeric")#
					# For each pre-existing continent:#
					for(i in 1:3) {#
						# Get distance from open spot to ith continent centre:#
						distances_from_centres[i] <- GreatCircleDistanceFromLongLat(open_spots[, "Longitude"], open_spots[, "Latitude"], circles[i, "Longitude"], circles[i, "Latitude"])#
					}#
					# Identify continent centre furthest from current single open spot:#
					furthest_point <- match(max(distances_from_centres), distances_from_centres)#
#
					# Get bearing from furthest point to first of the two other continent centres:#
					first_bearing <- BearingBetweenTwoLongLatPoints(circles[furthest_point, "Longitude"], circles[furthest_point, "Latitude"], circles[setdiff(c(1:3), furthest_point)[1], "Longitude"], circles[setdiff(c(1:3), furthest_point)[1], "Latitude"])#
#
					# Get bearing from furthest point to second of the two other continent centres:#
					second_bearing <- BearingBetweenTwoLongLatPoints(circles[furthest_point, "Longitude"], circles[furthest_point, "Latitude"], circles[setdiff(c(1:3), furthest_point)[2], "Longitude"], circles[setdiff(c(1:3), furthest_point)[2], "Latitude"])#
					# Get bearings from furthest point to the two new open spots:#
					new_bearings <- as.vector(sort(c(first_bearing - spherical_angle, first_bearing + spherical_angle, second_bearing - spherical_angle, second_bearing + spherical_angle))[c(1, 4)] %% 360)#
					# Add first new open spot to list:#
					open_spots <- rbind(open_spots, as.vector(unlist(EndPoint(circles[furthest_point, "Longitude"], circles[furthest_point, "Latitude"], new_bearings[1], min_separation)[c("long", "lat")])))#
					# Add second new open spot to list:#
					open_spots <- rbind(open_spots, as.vector(unlist(EndPoint(circles[furthest_point, "Longitude"], circles[furthest_point, "Latitude"], new_bearings[2], min_separation)[c("long", "lat")])))#
					# Keep adding continents unless they all have starting points:#
					while(N_continents > nrow(circles)) {#
# If no new open spots then stop#
# Make sure open spots is always a matrix too!#
						# Randomly pick an open spot to place a new continent:#
						new_continent_point <- sample(c(1:nrow(open_spots)))[1]#
						# Vector to store row numbers for adjacent continents:#
						adjacent_continents <- vector(mode="numeric")#
						# For each pre-existing continent:#
						for(i in 1:nrow(circles)) {#
							# Is the distance from the new continent to the ith pre-existing continent equal to the minimum continental separation?:#
							equal_check <- all.equal(as.vector(GreatCircleDistanceFromLongLat(open_spots[new_continent_point, "Longitude"], open_spots[new_continent_point, "Latitude"], circles[i, "Longitude"], circles[i, "Latitude"])), min_separation)#
#
							# If one of the nearest continents then add to the list:#
							if(equal_check == TRUE) adjacent_continents <- c(adjacent_continents, i)#
						}#
						# Vector to store bearings from new continent to adjacent continents:#
						bearings_to_adjacents <- vector(mode="numeric")#
						# For each continent adjacent to the new continent:#
						for(i in adjacent_continents) {#
							# Store bearing from new continent to ith adjacent continent:#
							bearings_to_adjacents <- as.vector(c(bearings_to_adjacents, BearingBetweenTwoLongLatPoints(open_spots[new_continent_point, "Longitude"], open_spots[new_continent_point, "Latitude"], circles[i, "Longitude"], circles[i, "Latitude"])))#
						}#
						# Vector to store bearings to potential new open spots:#
						new_bearings <- vector(mode="numeric")#
						# For each bearing to an adjacent continent:#
						for(i in 1:length(bearings_to_adjacents)) {#
							# Get new bearings from plus or minus the psherical angle from the current ebarings:#
							new_bearings <- c(new_bearings, c(bearings_to_adjacents[i] + spherical_angle, bearings_to_adjacents[i] - spherical_angle))#
						}#
						# Get bearings from new continent to two new potential open spots:#
						new_bearings <- sort(new_bearings)[c(1, length(new_bearings))] %% 360#
						# Store potential new open spots for further vetting:#
						potential_new_open_spots <- rbind(as.vector(unlist(EndPoint(open_spots[new_continent_point, "Longitude"], open_spots[new_continent_point, "Latitude"], new_bearings[1], min_separation)[c("long", "lat")])), as.vector(unlist(EndPoint(open_spots[new_continent_point, "Longitude"], open_spots[new_continent_point, "Latitude"], new_bearings[2], min_separation)[c("long", "lat")])))#
						# Add column names:#
						colnames(potential_new_open_spots) <- c("Longitude", "Latitude")#
						# Add new continent to circles matrix:#
						circles <- rbind(circles, c(nrow(circles) + 1, open_spots[new_continent_point, ]))#
						# Vector to store unsuitable new spots (those that are closer than minimum separation to existing continents):#
						unsuitable_spots <- vector(mode="numeric")#
						# For each potential new spot:#
						for(i in 1:2) {#
							# For each existing continent:#
							for(j in 1:nrow(circles)) {#
								# Get distance from ith potential new open spot to jth existing continent:#
								distance_between_centres <- as.vector(GreatCircleDistanceFromLongLat(potential_new_open_spots[i, "Longitude"], potential_new_open_spots[i, "Latitude"], circles[j, "Longitude"], circles[j, "Latitude"]))#
								# If ith potential new open spot is closer to a pre-existing continent than the minimum spearation allows add to unsuitable spots:#
								if(all.equal(distance_between_centres, min_separation) != TRUE && distance_between_centres < min_separation) unsuitable_spots <- as.vector(c(unsuitable_spots, i))#
							}#
						}#
						# If there are unsuitable spots:#
						if(length(unsuitable_spots) > 0) {#
							# Remove unsuitable spots from potential new spots:#
							potential_new_open_spots <- potential_new_open_spots[-unique(unsuitable_spots), ]#
							# If deletions has de-matrixed the data:#
							if(!is.matrix(potential_new_open_spots)) {#
								# Make back into matrix:#
								potential_new_open_spots <- matrix(potential_new_open_spots, ncol=2)#
							}#
							# Add column names:#
							colnames(potential_new_open_spots) <- c("Longitude", "Latitude")#
						}#
						# Add new potential open spots to open spots:#
						open_spots <- rbind(open_spots, potential_new_open_spots)#
#
						# Remove new continent from open spots:#
						open_spots <- open_spots[-new_continent_point, ]#
						# If deletions has de-matrixed the data:#
						if(!is.matrix(open_spots)) {#
							# Make back into matrix:#
							open_spots <- matrix(open_spots, ncol=2)#
						}#
						# Add column names:#
						colnames(open_spots) <- c("Longitude", "Latitude")#
#
					}#
				}#
			# If only two continents:#
			} else {#
# Output#
			}#
		# If only one continent:#
		} else {#
# Output#
		}#
	}#
	library(sphereplot)#
	rgl.sphgrid()#
	rgl.sphpoints(circles[, "Longitude"], circles[, "Latitude"], 1, deg=TRUE, col="red", cex=2)#
	rgl.sphpoints(open_spots[, "Longitude"], open_spots[, "Latitude"], 1, deg=TRUE, col="blue", cex=2)
circles
# Get the spherical angle for an equilateral triangle where its sides (as great circle distances) are known:#
SphericalAngleForEquilateralTriangleFromGreatCircleSideLength <- function(side_length, EarthRad = 6367.4447) {#
# Check this works for triangles larger than equivalent of 90-degrees of latitude on each side!#
	# Get y (which will be double the opposite for the triangle we are trying to solve):#
	y <- ChordLengthFromTheta(ThetaFromGreatCircleDistance(side_length))#
	# Get z which will be double the hypotenuse for the triangle we are trying to solve):#
	z <- ChordLengthFromTheta(ThetaFromGreatCircleDistance(side_length * 2))#
	# Solve the traingle for theta (the spherical angle) and convert to degrees:#
	spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2#
	# Return the spherical angle:#
	return(spherical_angle)#
}
# If the start configuration is a supercontinnet (all continents attached togther):#
	if(start_configuration == "supercontinent") {#
		# Establish minimum distance between continent centres (:#
		min_separation <- (1 - squishiness) * radius * 2#
# If squishiness is zero and option == "supercontinet" then all continents begin with same centre!!!!!!!#
# Need conditional to reflect this.#
		# Randomly assign starting longitude:#
		first_circle_long <- runif(1, min = -180, max = 180)#
#
		# Randomly assign starting latitude:#
		first_circle_lat <- runif(1, min = -90, max = 90)#
		# Create matrix to store circles:#
		circles <- matrix(c(1, first_circle_long, first_circle_lat), ncol=3, dimnames=list(c(), c("Circle", "Longitude", "Latitude")))#
		# If there are two or more continents still to place:#
		if(N_continents > 1) {#
			# Find centre of second continnet by randomly drawing from the circle describing all points within minimum separation of the first continent:#
			second_circle <- EndPoint(slong = first_circle_long, slat = first_circle_lat, bearing = runif(1, min = 0, max = 360), distance = min_separation)#
#
			# Add second continent to circles matrix:#
			circles <- rbind(circles, c(2, second_circle$long, second_circle$lat))#
			# If there are more than two continents still to place:#
			if(N_continents > 2) {#
				# Get spherical angle of equilateral (spherical) triangle with sides equal to minimum separation:#
				spherical_angle <- SphericalAngleForEquilateralTriangleFromGreatCircleSideLength(min_separation)#
#
				# Get first of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_1 <- (BearingBetweenTwoLongLatPoints(circles[1, "Longitude"], circles[1, "Latitude"], circles[2, "Longitude"], circles[2, "Latitude"]) - spherical_angle) %% 360#
				# Get second of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_2 <- (BearingBetweenTwoLongLatPoints(circles[1, "Longitude"], circles[1, "Latitude"], circles[2, "Longitude"], circles[2, "Latitude"]) + spherical_angle) %% 360#
				# Get lat-long coordinates of first possible site of third continent:#
				new_continent_1 <- EndPoint(circles[1, "Longitude"], circles[1, "Latitude"], new_bearing_1, min_separation)[c("long", "lat")]#
				# Get lat-long coordinates of second possible site of third continent:#
				new_continent_2 <- EndPoint(circles[1, "Longitude"], circles[1, "Latitude"], new_bearing_2, min_separation)[c("long", "lat")]#
				# Randomly pick site for third continent:#
				third_continent_picked <- sample(c(1, 2), 1)#
				# Randomly pick site for third continent:#
				third_circle <- rbind(unlist(new_continent_1), unlist(new_continent_2))[third_continent_picked, ]#
				# Add third continent to circles matrix:#
				circles <- rbind(circles, c(3, third_circle))#
# Little plot to check things look like they are working OK!:#
#library(maps)#
#map()#
#points(circles[, "Longitude"], circles[, "Latitude"], pch=19, col="red")#
				# If there are more than three continents:#
				if(N_continents > 3) {#
					# Create new matrix for open spots (centres where new continents may reside) with unused spot from third continent choice:#
					open_spots <- matrix(rbind(unlist(new_continent_1), unlist(new_continent_2))[setdiff(c(1:2), third_continent_picked), ], ncol=2)#
					# Add column names:#
					colnames(open_spots) <- c("Longitude", "Latitude")#
					# Vector to store distances from centres:#
					distances_from_centres <- vector(mode="numeric")#
					# For each pre-existing continent:#
					for(i in 1:3) {#
						# Get distance from open spot to ith continent centre:#
						distances_from_centres[i] <- GreatCircleDistanceFromLongLat(open_spots[, "Longitude"], open_spots[, "Latitude"], circles[i, "Longitude"], circles[i, "Latitude"])#
					}#
					# Identify continent centre furthest from current single open spot:#
					furthest_point <- match(max(distances_from_centres), distances_from_centres)#
#
					# Get bearing from furthest point to first of the two other continent centres:#
					first_bearing <- BearingBetweenTwoLongLatPoints(circles[furthest_point, "Longitude"], circles[furthest_point, "Latitude"], circles[setdiff(c(1:3), furthest_point)[1], "Longitude"], circles[setdiff(c(1:3), furthest_point)[1], "Latitude"])#
#
					# Get bearing from furthest point to second of the two other continent centres:#
					second_bearing <- BearingBetweenTwoLongLatPoints(circles[furthest_point, "Longitude"], circles[furthest_point, "Latitude"], circles[setdiff(c(1:3), furthest_point)[2], "Longitude"], circles[setdiff(c(1:3), furthest_point)[2], "Latitude"])#
					# Get bearings from furthest point to the two new open spots:#
					new_bearings <- as.vector(sort(c(first_bearing - spherical_angle, first_bearing + spherical_angle, second_bearing - spherical_angle, second_bearing + spherical_angle))[c(1, 4)] %% 360)#
					# Add first new open spot to list:#
					open_spots <- rbind(open_spots, as.vector(unlist(EndPoint(circles[furthest_point, "Longitude"], circles[furthest_point, "Latitude"], new_bearings[1], min_separation)[c("long", "lat")])))#
					# Add second new open spot to list:#
					open_spots <- rbind(open_spots, as.vector(unlist(EndPoint(circles[furthest_point, "Longitude"], circles[furthest_point, "Latitude"], new_bearings[2], min_separation)[c("long", "lat")])))#
					# Keep adding continents unless they all have starting points:#
					while(N_continents > nrow(circles)) {#
# If no new open spots then stop#
# Make sure open spots is always a matrix too!#
						# Randomly pick an open spot to place a new continent:#
						new_continent_point <- sample(c(1:nrow(open_spots)))[1]#
						# Vector to store row numbers for adjacent continents:#
						adjacent_continents <- vector(mode="numeric")#
						# For each pre-existing continent:#
						for(i in 1:nrow(circles)) {#
							# Is the distance from the new continent to the ith pre-existing continent equal to the minimum continental separation?:#
							equal_check <- all.equal(as.vector(GreatCircleDistanceFromLongLat(open_spots[new_continent_point, "Longitude"], open_spots[new_continent_point, "Latitude"], circles[i, "Longitude"], circles[i, "Latitude"])), min_separation)#
#
							# If one of the nearest continents then add to the list:#
							if(equal_check == TRUE) adjacent_continents <- c(adjacent_continents, i)#
						}#
						# Vector to store bearings from new continent to adjacent continents:#
						bearings_to_adjacents <- vector(mode="numeric")#
						# For each continent adjacent to the new continent:#
						for(i in adjacent_continents) {#
							# Store bearing from new continent to ith adjacent continent:#
							bearings_to_adjacents <- as.vector(c(bearings_to_adjacents, BearingBetweenTwoLongLatPoints(open_spots[new_continent_point, "Longitude"], open_spots[new_continent_point, "Latitude"], circles[i, "Longitude"], circles[i, "Latitude"])))#
						}#
						# Vector to store bearings to potential new open spots:#
						new_bearings <- vector(mode="numeric")#
						# For each bearing to an adjacent continent:#
						for(i in 1:length(bearings_to_adjacents)) {#
							# Get new bearings from plus or minus the psherical angle from the current ebarings:#
							new_bearings <- c(new_bearings, c(bearings_to_adjacents[i] + spherical_angle, bearings_to_adjacents[i] - spherical_angle))#
						}#
						# Get bearings from new continent to two new potential open spots:#
						new_bearings <- sort(new_bearings)[c(1, length(new_bearings))] %% 360#
						# Store potential new open spots for further vetting:#
						potential_new_open_spots <- rbind(as.vector(unlist(EndPoint(open_spots[new_continent_point, "Longitude"], open_spots[new_continent_point, "Latitude"], new_bearings[1], min_separation)[c("long", "lat")])), as.vector(unlist(EndPoint(open_spots[new_continent_point, "Longitude"], open_spots[new_continent_point, "Latitude"], new_bearings[2], min_separation)[c("long", "lat")])))#
						# Add column names:#
						colnames(potential_new_open_spots) <- c("Longitude", "Latitude")#
						# Add new continent to circles matrix:#
						circles <- rbind(circles, c(nrow(circles) + 1, open_spots[new_continent_point, ]))#
						# Vector to store unsuitable new spots (those that are closer than minimum separation to existing continents):#
						unsuitable_spots <- vector(mode="numeric")#
						# For each potential new spot:#
						for(i in 1:2) {#
							# For each existing continent:#
							for(j in 1:nrow(circles)) {#
								# Get distance from ith potential new open spot to jth existing continent:#
								distance_between_centres <- as.vector(GreatCircleDistanceFromLongLat(potential_new_open_spots[i, "Longitude"], potential_new_open_spots[i, "Latitude"], circles[j, "Longitude"], circles[j, "Latitude"]))#
								# If ith potential new open spot is closer to a pre-existing continent than the minimum spearation allows add to unsuitable spots:#
								if(all.equal(distance_between_centres, min_separation) != TRUE && distance_between_centres < min_separation) unsuitable_spots <- as.vector(c(unsuitable_spots, i))#
							}#
						}#
						# If there are unsuitable spots:#
						if(length(unsuitable_spots) > 0) {#
							# Remove unsuitable spots from potential new spots:#
							potential_new_open_spots <- potential_new_open_spots[-unique(unsuitable_spots), ]#
							# If deletions has de-matrixed the data:#
							if(!is.matrix(potential_new_open_spots)) {#
								# Make back into matrix:#
								potential_new_open_spots <- matrix(potential_new_open_spots, ncol=2)#
							}#
							# Add column names:#
							colnames(potential_new_open_spots) <- c("Longitude", "Latitude")#
						}#
						# Add new potential open spots to open spots:#
						open_spots <- rbind(open_spots, potential_new_open_spots)#
#
						# Remove new continent from open spots:#
						open_spots <- open_spots[-new_continent_point, ]#
						# If deletions has de-matrixed the data:#
						if(!is.matrix(open_spots)) {#
							# Make back into matrix:#
							open_spots <- matrix(open_spots, ncol=2)#
						}#
						# Add column names:#
						colnames(open_spots) <- c("Longitude", "Latitude")#
#
					}#
				}#
			# If only two continents:#
			} else {#
# Output#
			}#
		# If only one continent:#
		} else {#
# Output#
		}#
	}#
	library(sphereplot)#
	rgl.sphgrid()#
	rgl.sphpoints(circles[, "Longitude"], circles[, "Latitude"], 1, deg=TRUE, col="red", cex=2)#
	rgl.sphpoints(open_spots[, "Longitude"], open_spots[, "Latitude"], 1, deg=TRUE, col="blue", cex=2)
SphericalAngleForEquilateralTriangleFromGreatCircleSideLength
document()
document()
check()
check()
check()
check()
roxygenise()
library(roxygen2)
roxygenise()
document()
check()
check()
BearingBetweenTwoLongLatPoints
BearingBetweenTwoLongLatPoints(0, 0, 0, 1)
document()
check()
document()
document()
document()
check()
check()
library(ape)
rtree()
document()
check()
build()
install()
