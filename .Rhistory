p1 <- c(longitude_1, latitude_1)#
	p2 <- c(longitude_2, latitude_2)#
	p3 <- c(longitude_3, latitude_3)#
	p4 <- c(longitude_4, latitude_4)#
# geosphere functions:#
# Author: Robert J. Hijmans#
# April 2010#
# version 1#
# license GPL3#
	.normalizeLonDeg <- function(x) {#
		(x + 180) %% 360 - 180#
	}#
	.normalizeLonRad <- function(x) {#
		(x + pi) %% (2*pi) - pi #
	}#
	.isPolygon <- function(x, fix=FALSE) {#
		x <- na.omit(x)#
		if (nrow(x) < 4) {#
			stop('this is not a polygon (insufficent number of vertices)')#
		}#
		if (length(unique(x[,1]))==1) {#
			stop('All longitudes are the same (not a polygon)')#
		}#
		if (length(unique(x[,2]))==1) {#
			stop('All latitudes are the same (not a polygon)')#
		}#
		if (! all(!(is.na(x))) ) {#
			stop('polygon has NA values)')#
		}#
		if (! isTRUE(all.equal(x[1,], x[nrow(x),]))) {#
			stop('this is not a valid (closed) polygon. The first vertex is not equal to the last vertex')	#
		}#
		return(x)#
	}#
# Author: Robert J. Hijmans & Jacob van Etten#
# October 2009#
# version 1#
# license GPL3#
	.pointsToMatrix <- function(p, checkLonLat=TRUE, poly=FALSE) {#
		if (inherits(p, 'SpatialPoints')) {#
			test <- !is.projected(p)#
			if (! isTRUE (test) ) {#
				if (is.na(test)) {#
					warning('Coordinate reference system of SpatialPoints object is not set. Assuming it is degrees (longitude/latitude)!')  			#
				} else {#
					stop('Points are projected. They should be in degrees (longitude/latitude)')  #
				}#
# or rather transform them ....?#
			}#
			p <- coordinates(p)#
		} else if (is.data.frame(p)) {#
			p <- as.matrix(p)#
		} else #
		if (is.vector(p)){#
			if (length(p) != 2) {#
				stop('Wrong length for a vector, should be 2')#
			} else {#
				p <- matrix(p, ncol=2) #
			}#
		} else if (is.matrix(p)) {#
			if (length(p[1,]) != 2) {#
				stop( 'A points matrix should have 2 columns')#
			}#
			cn <- colnames(p)#
			if (length(cn) == 2) {#
				if (toupper(cn[1]) == 'Y' | toupper(cn[2]) == 'X')  {#
					warning('Suspect column names (x and y reversed?)')#
				}#
				if (toupper(substr(cn[1],1,3) == 'LAT' | toupper(substr(cn[2],1,3)) == 'LON'))  {#
					warning('Suspect column names (longitude and latitude reversed?)')#
				}#
			}		#
		} else {#
			stop('points should be vectors of length 2, matrices with 2 columns, or inheriting from a SpatialPoints* object')#
		}#
		if (! is.numeric(p) ) { p[] <- as.numeric(p) }#
		if (checkLonLat) {#
			if (length(na.omit(p[,1])) > 0) {#
				if (min(p[,1], na.rm=TRUE) < -360) { stop('longitude < -360') }#
				if (max(p[,1], na.rm=TRUE) > 360) {  stop('longitude > 360')  }#
				if (min(p[,1], na.rm=TRUE) < -180) { warning('longitude < -180') }#
				if (max(p[,1], na.rm=TRUE) > 180) {  warning('longitude > 180')  }#
			}#
			if (length(na.omit(p[,2])) > 0) {#
				if (min(p[,2], na.rm=TRUE) < -90) {  stop('latitude < -90')  }#
				if (max(p[,2], na.rm=TRUE) > 90) {  stop('latitude > 90')  }#
			}#
		}#
		if (poly) {#
			if (! isTRUE(all.equal(p[1,], p[nrow(p),]))) {#
				p <- rbind(p, p[1,])#
			} #
			i <- p[-nrow(p),1] == p[-1,1] &  p[-nrow(p),2] == p[-1,2]#
			i <- which(isTRUE(i))#
			if (length(i) > 0) {#
				p <- p[-i, ,drop=FALSE]#
			}#
			.isPolygon(p)#
		}#
		return(p)#
	}#
# author Robert Hijmans#
# October 2009#
# version 0.1#
# license GPL3#
# based on an alogrithm described by Ed Williams#
# http://williams.best.vwh.net/intersect.htm#
#intersection of two great circles defined by pt1 to pt2 and pt3 to pt4.#
	einv <- function(e) {#
		lat <- atan2(e[,3], sqrt(e[,1]^2 + e[,2]^2))#
		lon <- atan2(-e[,2], e[,1]) #
		return(cbind(lon, lat))#
	}#
	eXe5 <- function(lon1, lat1, lon2, lat2) {#
	    ex <- sin(lat1-lat2) *sin((lon1+lon2)/2) *cos((lon1-lon2)/2) - sin(lat1+lat2) *cos((lon1+lon2)/2) *sin((lon1-lon2)/2) #
		ey <- sin(lat1-lat2) *cos((lon1+lon2)/2) *cos((lon1-lon2)/2) + sin(lat1+lat2) *sin((lon1+lon2)/2) *sin((lon1-lon2)/2) #
		ez <- cos(lat1)*cos(lat2)*sin(lon1-lon2) #
		return( cbind(ex, ey, ez) )#
	}#
	eXe3 <- function(e1, e2) {#
		x <- e1[,2] * e2[,3] -e2[,2] *e1[,3]#
		y <- e1[,3] *e2[,1] -e2[,3] *e1[,1]#
		z <- e1[,1] *e2[,2] -e1[,2] *e2[,1]#
		return(cbind(x,y,z))#
	}#
	eSQRT <- function(e) {#
		return(sqrt(e[,1]^2 + e[,2]^2 + e[,3]^2))#
	}	#
	p1 <- .pointsToMatrix(p1)#
	p2 <- .pointsToMatrix(p2)#
	p3 <- .pointsToMatrix(p3)#
	p4 <- .pointsToMatrix(p4)#
	p1 <- cbind(p1[,1], p1[,2], p2[,1], p2[,2])#
	p3 <- cbind(p3[,1], p3[,2], p4[,1], p4[,2])#
	p  <- cbind(p1[,1], p1[,2], p1[,3], p1[,4], p3[,1], p3[,2], p3[,3], p3[,4])#
	p1 <- p[,1:2,drop=FALSE]#
	p2 <- p[,3:4,drop=FALSE]#
	p3 <- p[,5:6,drop=FALSE]#
	p4 <- p[,7:8,drop=FALSE]#
	res <- matrix(NA, nrow=nrow(p1), ncol=4)#
	colnames(res) <- c('lon1', 'lat1', 'lon2', 'lat2')#
	keep <- ! antipodal(p1, p2) | antipodal(p3, p4)#
	keep <- keep & ! apply(p1 == p2, 1, sum) == 2#
	if (sum(keep) == 0) { return(res) }#
	toRad <- pi / 180 #
	p1 <- p1[keep, , drop=FALSE] * toRad#
	p2 <- p2[keep, , drop=FALSE] * toRad#
	p3 <- p3[keep, , drop=FALSE] * toRad#
	p4 <- p4[keep, , drop=FALSE] * toRad#
	e1Xe2 <- eXe5(p1[,1], p1[,2], p2[,1], p2[,2])#
	e3Xe4 <- eXe5(p3[,1], p3[,2], p4[,1], p4[,2])#
	ea <- e1Xe2  / eSQRT(e1Xe2)#
	eb <- e3Xe4  / eSQRT(e3Xe4)#
	eaXeb <- eXe3(ea, eb)#
	ll <- einv(eaXeb)#
	ll2 <- cbind(ll[,1] + pi, -ll[,2])#
	pts <- cbind(ll, ll2)#
	pts[,1] <- .normalizeLonRad(pts[,1])#
	pts[,3] <- .normalizeLonRad(pts[,3])#
	res[keep,] <- pts / toRad#
#
# Done with geosphere functions:#
	distance_to_first_intersection_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, res[, "lon1"], res[, "lat1"])#
	distance_to_second_intersection_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, res[, "lon2"], res[, "lat2"])#
#
	distance_to_other_point_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, longitude_2, latitude_2)#
#
	distance_to_first_intersection_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, res[, "lon1"], res[, "lat1"])#
	distance_to_second_intersection_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, res[, "lon2"], res[, "lat2"])#
	distance_to_other_point_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, longitude_4, latitude_4)#
	delete.rows <- vector(mode="numeric")#
# Case if first point is an intersection:#
	if(!(distance_to_other_point_1 >= distance_to_first_intersection_1 && distance_to_other_point_2 >= distance_to_first_intersection_2)) delete.rows <- c(delete.rows, 1)#
#
# Case if second point is an intersection:#
	if(!(distance_to_other_point_1 >= distance_to_second_intersection_1 && distance_to_other_point_2 >= distance_to_second_intersection_2)) delete.rows <- c(delete.rows, 2)#
	res[-delete.rows, ]
distance_to_other_point_1
distance_to_other_point_2
res
matrix(res, ncol=2)
matrix(res, ncol=2, byrow=TRUE)
matrix(res, ncol=2, byrow=TRUE, dimnames=list(c(), c("Longitude", "Latitude")))
res <- matrix(res, ncol=2, byrow=TRUE, dimnames=list(c(), c("Longitude", "Latitude")))#
# Case if first point is an intersection:#
	if(!(distance_to_other_point_1 >= distance_to_first_intersection_1 && distance_to_other_point_2 >= distance_to_first_intersection_2)) delete.rows <- c(delete.rows, 1)#
#
# Case if second point is an intersection:#
	if(!(distance_to_other_point_1 >= distance_to_second_intersection_1 && distance_to_other_point_2 >= distance_to_second_intersection_2)) delete.rows <- c(delete.rows, 2)#
	res[-delete.rows, ]
delete.rows
delete.rows <- vector(mode="numeric")
# Case if first point is an intersection:#
	if(!(distance_to_other_point_1 >= distance_to_first_intersection_1 && distance_to_other_point_2 >= distance_to_first_intersection_2)) delete.rows <- c(delete.rows, 1)#
#
# Case if second point is an intersection:#
	if(!(distance_to_other_point_1 >= distance_to_second_intersection_1 && distance_to_other_point_2 >= distance_to_second_intersection_2)) delete.rows <- c(delete.rows, 2)#
	res[-delete.rows, ]
is.matrix(res[-delete.rows, ])
res <- res[-delete.rows, ]
res
matrix(res, ncol=2, byrow=TRUE, dimnames=list(c(), c("Longitude", "Latitude")))
longitude_1 <- runif(1, -180, 180)#
longitude_2 <- runif(1, -180, 180)#
longitude_3 <- runif(1, -180, 180)#
longitude_4 <- runif(1, -180, 180)#
latitude_1 <- runif(1, -90, 90)#
latitude_2 <- runif(1, -90, 90)#
latitude_3 <- runif(1, -90, 90)#
latitude_4 <- runif(1, -90, 90)
p1 <- c(longitude_1, latitude_1)#
	p2 <- c(longitude_2, latitude_2)#
	p3 <- c(longitude_3, latitude_3)#
	p4 <- c(longitude_4, latitude_4)#
# geosphere functions:#
# Author: Robert J. Hijmans#
# April 2010#
# version 1#
# license GPL3#
	.normalizeLonDeg <- function(x) {#
		(x + 180) %% 360 - 180#
	}#
	.normalizeLonRad <- function(x) {#
		(x + pi) %% (2*pi) - pi #
	}#
	.isPolygon <- function(x, fix=FALSE) {#
		x <- na.omit(x)#
		if (nrow(x) < 4) {#
			stop('this is not a polygon (insufficent number of vertices)')#
		}#
		if (length(unique(x[,1]))==1) {#
			stop('All longitudes are the same (not a polygon)')#
		}#
		if (length(unique(x[,2]))==1) {#
			stop('All latitudes are the same (not a polygon)')#
		}#
		if (! all(!(is.na(x))) ) {#
			stop('polygon has NA values)')#
		}#
		if (! isTRUE(all.equal(x[1,], x[nrow(x),]))) {#
			stop('this is not a valid (closed) polygon. The first vertex is not equal to the last vertex')	#
		}#
		return(x)#
	}#
# Author: Robert J. Hijmans & Jacob van Etten#
# October 2009#
# version 1#
# license GPL3#
	.pointsToMatrix <- function(p, checkLonLat=TRUE, poly=FALSE) {#
		if (inherits(p, 'SpatialPoints')) {#
			test <- !is.projected(p)#
			if (! isTRUE (test) ) {#
				if (is.na(test)) {#
					warning('Coordinate reference system of SpatialPoints object is not set. Assuming it is degrees (longitude/latitude)!')  			#
				} else {#
					stop('Points are projected. They should be in degrees (longitude/latitude)')  #
				}#
# or rather transform them ....?#
			}#
			p <- coordinates(p)#
		} else if (is.data.frame(p)) {#
			p <- as.matrix(p)#
		} else #
		if (is.vector(p)){#
			if (length(p) != 2) {#
				stop('Wrong length for a vector, should be 2')#
			} else {#
				p <- matrix(p, ncol=2) #
			}#
		} else if (is.matrix(p)) {#
			if (length(p[1,]) != 2) {#
				stop( 'A points matrix should have 2 columns')#
			}#
			cn <- colnames(p)#
			if (length(cn) == 2) {#
				if (toupper(cn[1]) == 'Y' | toupper(cn[2]) == 'X')  {#
					warning('Suspect column names (x and y reversed?)')#
				}#
				if (toupper(substr(cn[1],1,3) == 'LAT' | toupper(substr(cn[2],1,3)) == 'LON'))  {#
					warning('Suspect column names (longitude and latitude reversed?)')#
				}#
			}		#
		} else {#
			stop('points should be vectors of length 2, matrices with 2 columns, or inheriting from a SpatialPoints* object')#
		}#
		if (! is.numeric(p) ) { p[] <- as.numeric(p) }#
		if (checkLonLat) {#
			if (length(na.omit(p[,1])) > 0) {#
				if (min(p[,1], na.rm=TRUE) < -360) { stop('longitude < -360') }#
				if (max(p[,1], na.rm=TRUE) > 360) {  stop('longitude > 360')  }#
				if (min(p[,1], na.rm=TRUE) < -180) { warning('longitude < -180') }#
				if (max(p[,1], na.rm=TRUE) > 180) {  warning('longitude > 180')  }#
			}#
			if (length(na.omit(p[,2])) > 0) {#
				if (min(p[,2], na.rm=TRUE) < -90) {  stop('latitude < -90')  }#
				if (max(p[,2], na.rm=TRUE) > 90) {  stop('latitude > 90')  }#
			}#
		}#
		if (poly) {#
			if (! isTRUE(all.equal(p[1,], p[nrow(p),]))) {#
				p <- rbind(p, p[1,])#
			} #
			i <- p[-nrow(p),1] == p[-1,1] &  p[-nrow(p),2] == p[-1,2]#
			i <- which(isTRUE(i))#
			if (length(i) > 0) {#
				p <- p[-i, ,drop=FALSE]#
			}#
			.isPolygon(p)#
		}#
		return(p)#
	}#
# author Robert Hijmans#
# October 2009#
# version 0.1#
# license GPL3#
# based on an alogrithm described by Ed Williams#
# http://williams.best.vwh.net/intersect.htm#
#intersection of two great circles defined by pt1 to pt2 and pt3 to pt4.#
	einv <- function(e) {#
		lat <- atan2(e[,3], sqrt(e[,1]^2 + e[,2]^2))#
		lon <- atan2(-e[,2], e[,1]) #
		return(cbind(lon, lat))#
	}#
	eXe5 <- function(lon1, lat1, lon2, lat2) {#
	    ex <- sin(lat1-lat2) *sin((lon1+lon2)/2) *cos((lon1-lon2)/2) - sin(lat1+lat2) *cos((lon1+lon2)/2) *sin((lon1-lon2)/2) #
		ey <- sin(lat1-lat2) *cos((lon1+lon2)/2) *cos((lon1-lon2)/2) + sin(lat1+lat2) *sin((lon1+lon2)/2) *sin((lon1-lon2)/2) #
		ez <- cos(lat1)*cos(lat2)*sin(lon1-lon2) #
		return( cbind(ex, ey, ez) )#
	}#
	eXe3 <- function(e1, e2) {#
		x <- e1[,2] * e2[,3] -e2[,2] *e1[,3]#
		y <- e1[,3] *e2[,1] -e2[,3] *e1[,1]#
		z <- e1[,1] *e2[,2] -e1[,2] *e2[,1]#
		return(cbind(x,y,z))#
	}#
	eSQRT <- function(e) {#
		return(sqrt(e[,1]^2 + e[,2]^2 + e[,3]^2))#
	}	#
	p1 <- .pointsToMatrix(p1)#
	p2 <- .pointsToMatrix(p2)#
	p3 <- .pointsToMatrix(p3)#
	p4 <- .pointsToMatrix(p4)#
	p1 <- cbind(p1[,1], p1[,2], p2[,1], p2[,2])#
	p3 <- cbind(p3[,1], p3[,2], p4[,1], p4[,2])#
	p  <- cbind(p1[,1], p1[,2], p1[,3], p1[,4], p3[,1], p3[,2], p3[,3], p3[,4])#
	p1 <- p[,1:2,drop=FALSE]#
	p2 <- p[,3:4,drop=FALSE]#
	p3 <- p[,5:6,drop=FALSE]#
	p4 <- p[,7:8,drop=FALSE]#
	res <- matrix(NA, nrow=nrow(p1), ncol=4)#
	colnames(res) <- c('lon1', 'lat1', 'lon2', 'lat2')#
	keep <- ! antipodal(p1, p2) | antipodal(p3, p4)#
	keep <- keep & ! apply(p1 == p2, 1, sum) == 2#
	if (sum(keep) == 0) { return(res) }#
	toRad <- pi / 180 #
	p1 <- p1[keep, , drop=FALSE] * toRad#
	p2 <- p2[keep, , drop=FALSE] * toRad#
	p3 <- p3[keep, , drop=FALSE] * toRad#
	p4 <- p4[keep, , drop=FALSE] * toRad#
	e1Xe2 <- eXe5(p1[,1], p1[,2], p2[,1], p2[,2])#
	e3Xe4 <- eXe5(p3[,1], p3[,2], p4[,1], p4[,2])#
	ea <- e1Xe2  / eSQRT(e1Xe2)#
	eb <- e3Xe4  / eSQRT(e3Xe4)#
	eaXeb <- eXe3(ea, eb)#
	ll <- einv(eaXeb)#
	ll2 <- cbind(ll[,1] + pi, -ll[,2])#
	pts <- cbind(ll, ll2)#
	pts[,1] <- .normalizeLonRad(pts[,1])#
	pts[,3] <- .normalizeLonRad(pts[,3])#
	res[keep,] <- pts / toRad#
#
# Done with geosphere functions:#
	distance_to_first_intersection_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, res[, "lon1"], res[, "lat1"])#
	distance_to_second_intersection_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, res[, "lon2"], res[, "lat2"])#
#
	distance_to_other_point_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, longitude_2, latitude_2)#
#
	distance_to_first_intersection_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, res[, "lon1"], res[, "lat1"])#
	distance_to_second_intersection_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, res[, "lon2"], res[, "lat2"])#
	distance_to_other_point_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, longitude_4, latitude_4)#
	delete.rows <- vector(mode="numeric")#
	res <- matrix(res, ncol=2, byrow=TRUE, dimnames=list(c(), c("Longitude", "Latitude")))#
# Case if first point is an intersection:#
	if(!(distance_to_other_point_1 >= distance_to_first_intersection_1 && distance_to_other_point_2 >= distance_to_first_intersection_2)) delete.rows <- c(delete.rows, 1)#
#
# Case if second point is an intersection:#
	if(!(distance_to_other_point_1 >= distance_to_second_intersection_1 && distance_to_other_point_2 >= distance_to_second_intersection_2)) delete.rows <- c(delete.rows, 2)#
	res <- res[-delete.rows, ]#
#
	res <- matrix(res, ncol=2, byrow=TRUE, dimnames=list(c(), c("Longitude", "Latitude")))#
	res
longitude_1 <- runif(1, -180, 180)#
longitude_2 <- runif(1, -180, 180)#
longitude_3 <- runif(1, -180, 180)#
longitude_4 <- runif(1, -180, 180)#
latitude_1 <- runif(1, -90, 90)#
latitude_2 <- runif(1, -90, 90)#
latitude_3 <- runif(1, -90, 90)#
latitude_4 <- runif(1, -90, 90)
p1 <- c(longitude_1, latitude_1)#
	p2 <- c(longitude_2, latitude_2)#
	p3 <- c(longitude_3, latitude_3)#
	p4 <- c(longitude_4, latitude_4)#
# geosphere functions:#
# Author: Robert J. Hijmans#
# April 2010#
# version 1#
# license GPL3#
	.normalizeLonDeg <- function(x) {#
		(x + 180) %% 360 - 180#
	}#
	.normalizeLonRad <- function(x) {#
		(x + pi) %% (2*pi) - pi #
	}#
	.isPolygon <- function(x, fix=FALSE) {#
		x <- na.omit(x)#
		if (nrow(x) < 4) {#
			stop('this is not a polygon (insufficent number of vertices)')#
		}#
		if (length(unique(x[,1]))==1) {#
			stop('All longitudes are the same (not a polygon)')#
		}#
		if (length(unique(x[,2]))==1) {#
			stop('All latitudes are the same (not a polygon)')#
		}#
		if (! all(!(is.na(x))) ) {#
			stop('polygon has NA values)')#
		}#
		if (! isTRUE(all.equal(x[1,], x[nrow(x),]))) {#
			stop('this is not a valid (closed) polygon. The first vertex is not equal to the last vertex')	#
		}#
		return(x)#
	}#
# Author: Robert J. Hijmans & Jacob van Etten#
# October 2009#
# version 1#
# license GPL3#
	.pointsToMatrix <- function(p, checkLonLat=TRUE, poly=FALSE) {#
		if (inherits(p, 'SpatialPoints')) {#
			test <- !is.projected(p)#
			if (! isTRUE (test) ) {#
				if (is.na(test)) {#
					warning('Coordinate reference system of SpatialPoints object is not set. Assuming it is degrees (longitude/latitude)!')  			#
				} else {#
					stop('Points are projected. They should be in degrees (longitude/latitude)')  #
				}#
# or rather transform them ....?#
			}#
			p <- coordinates(p)#
		} else if (is.data.frame(p)) {#
			p <- as.matrix(p)#
		} else #
		if (is.vector(p)){#
			if (length(p) != 2) {#
				stop('Wrong length for a vector, should be 2')#
			} else {#
				p <- matrix(p, ncol=2) #
			}#
		} else if (is.matrix(p)) {#
			if (length(p[1,]) != 2) {#
				stop( 'A points matrix should have 2 columns')#
			}#
			cn <- colnames(p)#
			if (length(cn) == 2) {#
				if (toupper(cn[1]) == 'Y' | toupper(cn[2]) == 'X')  {#
					warning('Suspect column names (x and y reversed?)')#
				}#
				if (toupper(substr(cn[1],1,3) == 'LAT' | toupper(substr(cn[2],1,3)) == 'LON'))  {#
					warning('Suspect column names (longitude and latitude reversed?)')#
				}#
			}		#
		} else {#
			stop('points should be vectors of length 2, matrices with 2 columns, or inheriting from a SpatialPoints* object')#
		}#
		if (! is.numeric(p) ) { p[] <- as.numeric(p) }#
		if (checkLonLat) {#
			if (length(na.omit(p[,1])) > 0) {#
				if (min(p[,1], na.rm=TRUE) < -360) { stop('longitude < -360') }#
				if (max(p[,1], na.rm=TRUE) > 360) {  stop('longitude > 360')  }#
				if (min(p[,1], na.rm=TRUE) < -180) { warning('longitude < -180') }#
				if (max(p[,1], na.rm=TRUE) > 180) {  warning('longitude > 180')  }#
			}#
			if (length(na.omit(p[,2])) > 0) {#
				if (min(p[,2], na.rm=TRUE) < -90) {  stop('latitude < -90')  }#
				if (max(p[,2], na.rm=TRUE) > 90) {  stop('latitude > 90')  }#
			}#
		}#
		if (poly) {#
			if (! isTRUE(all.equal(p[1,], p[nrow(p),]))) {#
				p <- rbind(p, p[1,])#
			} #
			i <- p[-nrow(p),1] == p[-1,1] &  p[-nrow(p),2] == p[-1,2]#
			i <- which(isTRUE(i))#
			if (length(i) > 0) {#
				p <- p[-i, ,drop=FALSE]#
			}#
			.isPolygon(p)#
		}#
		return(p)#
	}#
# author Robert Hijmans#
# October 2009#
# version 0.1#
# license GPL3#
# based on an alogrithm described by Ed Williams#
# http://williams.best.vwh.net/intersect.htm#
#intersection of two great circles defined by pt1 to pt2 and pt3 to pt4.#
	einv <- function(e) {#
		lat <- atan2(e[,3], sqrt(e[,1]^2 + e[,2]^2))#
		lon <- atan2(-e[,2], e[,1]) #
		return(cbind(lon, lat))#
	}#
	eXe5 <- function(lon1, lat1, lon2, lat2) {#
	    ex <- sin(lat1-lat2) *sin((lon1+lon2)/2) *cos((lon1-lon2)/2) - sin(lat1+lat2) *cos((lon1+lon2)/2) *sin((lon1-lon2)/2) #
		ey <- sin(lat1-lat2) *cos((lon1+lon2)/2) *cos((lon1-lon2)/2) + sin(lat1+lat2) *sin((lon1+lon2)/2) *sin((lon1-lon2)/2) #
		ez <- cos(lat1)*cos(lat2)*sin(lon1-lon2) #
		return( cbind(ex, ey, ez) )#
	}#
	eXe3 <- function(e1, e2) {#
		x <- e1[,2] * e2[,3] -e2[,2] *e1[,3]#
		y <- e1[,3] *e2[,1] -e2[,3] *e1[,1]#
		z <- e1[,1] *e2[,2] -e1[,2] *e2[,1]#
		return(cbind(x,y,z))#
	}#
	eSQRT <- function(e) {#
		return(sqrt(e[,1]^2 + e[,2]^2 + e[,3]^2))#
	}	#
	p1 <- .pointsToMatrix(p1)#
	p2 <- .pointsToMatrix(p2)#
	p3 <- .pointsToMatrix(p3)#
	p4 <- .pointsToMatrix(p4)#
	p1 <- cbind(p1[,1], p1[,2], p2[,1], p2[,2])#
	p3 <- cbind(p3[,1], p3[,2], p4[,1], p4[,2])#
	p  <- cbind(p1[,1], p1[,2], p1[,3], p1[,4], p3[,1], p3[,2], p3[,3], p3[,4])#
	p1 <- p[,1:2,drop=FALSE]#
	p2 <- p[,3:4,drop=FALSE]#
	p3 <- p[,5:6,drop=FALSE]#
	p4 <- p[,7:8,drop=FALSE]#
	res <- matrix(NA, nrow=nrow(p1), ncol=4)#
	colnames(res) <- c('lon1', 'lat1', 'lon2', 'lat2')#
	keep <- ! antipodal(p1, p2) | antipodal(p3, p4)#
	keep <- keep & ! apply(p1 == p2, 1, sum) == 2#
	if (sum(keep) == 0) { return(res) }#
	toRad <- pi / 180 #
	p1 <- p1[keep, , drop=FALSE] * toRad#
	p2 <- p2[keep, , drop=FALSE] * toRad#
	p3 <- p3[keep, , drop=FALSE] * toRad#
	p4 <- p4[keep, , drop=FALSE] * toRad#
	e1Xe2 <- eXe5(p1[,1], p1[,2], p2[,1], p2[,2])#
	e3Xe4 <- eXe5(p3[,1], p3[,2], p4[,1], p4[,2])#
	ea <- e1Xe2  / eSQRT(e1Xe2)#
	eb <- e3Xe4  / eSQRT(e3Xe4)#
	eaXeb <- eXe3(ea, eb)#
	ll <- einv(eaXeb)#
	ll2 <- cbind(ll[,1] + pi, -ll[,2])#
	pts <- cbind(ll, ll2)#
	pts[,1] <- .normalizeLonRad(pts[,1])#
	pts[,3] <- .normalizeLonRad(pts[,3])#
	res[keep,] <- pts / toRad#
#
# Done with geosphere functions:#
	distance_to_first_intersection_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, res[, "lon1"], res[, "lat1"])#
	distance_to_second_intersection_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, res[, "lon2"], res[, "lat2"])#
#
	distance_to_other_point_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, longitude_2, latitude_2)#
#
	distance_to_first_intersection_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, res[, "lon1"], res[, "lat1"])#
	distance_to_second_intersection_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, res[, "lon2"], res[, "lat2"])#
	distance_to_other_point_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, longitude_4, latitude_4)#
	delete.rows <- vector(mode="numeric")#
	res <- matrix(res, ncol=2, byrow=TRUE, dimnames=list(c(), c("Longitude", "Latitude")))#
# Case if first point is an intersection:#
	if(!(distance_to_other_point_1 >= distance_to_first_intersection_1 && distance_to_other_point_2 >= distance_to_first_intersection_2)) delete.rows <- c(delete.rows, 1)#
#
# Case if second point is an intersection:#
	if(!(distance_to_other_point_1 >= distance_to_second_intersection_1 && distance_to_other_point_2 >= distance_to_second_intersection_2)) delete.rows <- c(delete.rows, 2)#
	res <- res[-delete.rows, ]#
#
	res <- matrix(res, ncol=2, byrow=TRUE, dimnames=list(c(), c("Longitude", "Latitude")))#
	res
longitude_1 <- runif(1, -180, 180)#
longitude_2 <- runif(1, -180, 180)#
longitude_3 <- runif(1, -180, 180)#
longitude_4 <- runif(1, -180, 180)#
latitude_1 <- runif(1, -90, 90)#
latitude_2 <- runif(1, -90, 90)#
latitude_3 <- runif(1, -90, 90)#
latitude_4 <- runif(1, -90, 90)
p1 <- c(longitude_1, latitude_1)#
	p2 <- c(longitude_2, latitude_2)#
	p3 <- c(longitude_3, latitude_3)#
	p4 <- c(longitude_4, latitude_4)#
# geosphere functions:#
# Author: Robert J. Hijmans#
# April 2010#
# version 1#
# license GPL3#
	.normalizeLonDeg <- function(x) {#
		(x + 180) %% 360 - 180#
	}#
	.normalizeLonRad <- function(x) {#
		(x + pi) %% (2*pi) - pi #
	}#
	.isPolygon <- function(x, fix=FALSE) {#
		x <- na.omit(x)#
		if (nrow(x) < 4) {#
			stop('this is not a polygon (insufficent number of vertices)')#
		}#
		if (length(unique(x[,1]))==1) {#
			stop('All longitudes are the same (not a polygon)')#
		}#
		if (length(unique(x[,2]))==1) {#
			stop('All latitudes are the same (not a polygon)')#
		}#
		if (! all(!(is.na(x))) ) {#
			stop('polygon has NA values)')#
		}#
		if (! isTRUE(all.equal(x[1,], x[nrow(x),]))) {#
			stop('this is not a valid (closed) polygon. The first vertex is not equal to the last vertex')	#
		}#
		return(x)#
	}#
# Author: Robert J. Hijmans & Jacob van Etten#
# October 2009#
# version 1#
# license GPL3#
	.pointsToMatrix <- function(p, checkLonLat=TRUE, poly=FALSE) {#
		if (inherits(p, 'SpatialPoints')) {#
			test <- !is.projected(p)#
			if (! isTRUE (test) ) {#
				if (is.na(test)) {#
					warning('Coordinate reference system of SpatialPoints object is not set. Assuming it is degrees (longitude/latitude)!')  			#
				} else {#
					stop('Points are projected. They should be in degrees (longitude/latitude)')  #
				}#
# or rather transform them ....?#
			}#
			p <- coordinates(p)#
		} else if (is.data.frame(p)) {#
			p <- as.matrix(p)#
		} else #
		if (is.vector(p)){#
			if (length(p) != 2) {#
				stop('Wrong length for a vector, should be 2')#
			} else {#
				p <- matrix(p, ncol=2) #
			}#
		} else if (is.matrix(p)) {#
			if (length(p[1,]) != 2) {#
				stop( 'A points matrix should have 2 columns')#
			}#
			cn <- colnames(p)#
			if (length(cn) == 2) {#
				if (toupper(cn[1]) == 'Y' | toupper(cn[2]) == 'X')  {#
					warning('Suspect column names (x and y reversed?)')#
				}#
				if (toupper(substr(cn[1],1,3) == 'LAT' | toupper(substr(cn[2],1,3)) == 'LON'))  {#
					warning('Suspect column names (longitude and latitude reversed?)')#
				}#
			}		#
		} else {#
			stop('points should be vectors of length 2, matrices with 2 columns, or inheriting from a SpatialPoints* object')#
		}#
		if (! is.numeric(p) ) { p[] <- as.numeric(p) }#
		if (checkLonLat) {#
			if (length(na.omit(p[,1])) > 0) {#
				if (min(p[,1], na.rm=TRUE) < -360) { stop('longitude < -360') }#
				if (max(p[,1], na.rm=TRUE) > 360) {  stop('longitude > 360')  }#
				if (min(p[,1], na.rm=TRUE) < -180) { warning('longitude < -180') }#
				if (max(p[,1], na.rm=TRUE) > 180) {  warning('longitude > 180')  }#
			}#
			if (length(na.omit(p[,2])) > 0) {#
				if (min(p[,2], na.rm=TRUE) < -90) {  stop('latitude < -90')  }#
				if (max(p[,2], na.rm=TRUE) > 90) {  stop('latitude > 90')  }#
			}#
		}#
		if (poly) {#
			if (! isTRUE(all.equal(p[1,], p[nrow(p),]))) {#
				p <- rbind(p, p[1,])#
			} #
			i <- p[-nrow(p),1] == p[-1,1] &  p[-nrow(p),2] == p[-1,2]#
			i <- which(isTRUE(i))#
			if (length(i) > 0) {#
				p <- p[-i, ,drop=FALSE]#
			}#
			.isPolygon(p)#
		}#
		return(p)#
	}#
# author Robert Hijmans#
# October 2009#
# version 0.1#
# license GPL3#
# based on an alogrithm described by Ed Williams#
# http://williams.best.vwh.net/intersect.htm#
#intersection of two great circles defined by pt1 to pt2 and pt3 to pt4.#
	einv <- function(e) {#
		lat <- atan2(e[,3], sqrt(e[,1]^2 + e[,2]^2))#
		lon <- atan2(-e[,2], e[,1]) #
		return(cbind(lon, lat))#
	}#
	eXe5 <- function(lon1, lat1, lon2, lat2) {#
	    ex <- sin(lat1-lat2) *sin((lon1+lon2)/2) *cos((lon1-lon2)/2) - sin(lat1+lat2) *cos((lon1+lon2)/2) *sin((lon1-lon2)/2) #
		ey <- sin(lat1-lat2) *cos((lon1+lon2)/2) *cos((lon1-lon2)/2) + sin(lat1+lat2) *sin((lon1+lon2)/2) *sin((lon1-lon2)/2) #
		ez <- cos(lat1)*cos(lat2)*sin(lon1-lon2) #
		return( cbind(ex, ey, ez) )#
	}#
	eXe3 <- function(e1, e2) {#
		x <- e1[,2] * e2[,3] -e2[,2] *e1[,3]#
		y <- e1[,3] *e2[,1] -e2[,3] *e1[,1]#
		z <- e1[,1] *e2[,2] -e1[,2] *e2[,1]#
		return(cbind(x,y,z))#
	}#
	eSQRT <- function(e) {#
		return(sqrt(e[,1]^2 + e[,2]^2 + e[,3]^2))#
	}	#
	p1 <- .pointsToMatrix(p1)#
	p2 <- .pointsToMatrix(p2)#
	p3 <- .pointsToMatrix(p3)#
	p4 <- .pointsToMatrix(p4)#
	p1 <- cbind(p1[,1], p1[,2], p2[,1], p2[,2])#
	p3 <- cbind(p3[,1], p3[,2], p4[,1], p4[,2])#
	p  <- cbind(p1[,1], p1[,2], p1[,3], p1[,4], p3[,1], p3[,2], p3[,3], p3[,4])#
	p1 <- p[,1:2,drop=FALSE]#
	p2 <- p[,3:4,drop=FALSE]#
	p3 <- p[,5:6,drop=FALSE]#
	p4 <- p[,7:8,drop=FALSE]#
	res <- matrix(NA, nrow=nrow(p1), ncol=4)#
	colnames(res) <- c('lon1', 'lat1', 'lon2', 'lat2')#
	keep <- ! antipodal(p1, p2) | antipodal(p3, p4)#
	keep <- keep & ! apply(p1 == p2, 1, sum) == 2#
	if (sum(keep) == 0) { return(res) }#
	toRad <- pi / 180 #
	p1 <- p1[keep, , drop=FALSE] * toRad#
	p2 <- p2[keep, , drop=FALSE] * toRad#
	p3 <- p3[keep, , drop=FALSE] * toRad#
	p4 <- p4[keep, , drop=FALSE] * toRad#
	e1Xe2 <- eXe5(p1[,1], p1[,2], p2[,1], p2[,2])#
	e3Xe4 <- eXe5(p3[,1], p3[,2], p4[,1], p4[,2])#
	ea <- e1Xe2  / eSQRT(e1Xe2)#
	eb <- e3Xe4  / eSQRT(e3Xe4)#
	eaXeb <- eXe3(ea, eb)#
	ll <- einv(eaXeb)#
	ll2 <- cbind(ll[,1] + pi, -ll[,2])#
	pts <- cbind(ll, ll2)#
	pts[,1] <- .normalizeLonRad(pts[,1])#
	pts[,3] <- .normalizeLonRad(pts[,3])#
	res[keep,] <- pts / toRad#
#
# Done with geosphere functions:#
	distance_to_first_intersection_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, res[, "lon1"], res[, "lat1"])#
	distance_to_second_intersection_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, res[, "lon2"], res[, "lat2"])#
#
	distance_to_other_point_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, longitude_2, latitude_2)#
#
	distance_to_first_intersection_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, res[, "lon1"], res[, "lat1"])#
	distance_to_second_intersection_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, res[, "lon2"], res[, "lat2"])#
	distance_to_other_point_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, longitude_4, latitude_4)#
	delete.rows <- vector(mode="numeric")#
	res <- matrix(res, ncol=2, byrow=TRUE, dimnames=list(c(), c("Longitude", "Latitude")))#
# Case if first point is an intersection:#
	if(!(distance_to_other_point_1 >= distance_to_first_intersection_1 && distance_to_other_point_2 >= distance_to_first_intersection_2)) delete.rows <- c(delete.rows, 1)#
#
# Case if second point is an intersection:#
	if(!(distance_to_other_point_1 >= distance_to_second_intersection_1 && distance_to_other_point_2 >= distance_to_second_intersection_2)) delete.rows <- c(delete.rows, 2)#
	res <- res[-delete.rows, ]#
#
	res <- matrix(res, ncol=2, byrow=TRUE, dimnames=list(c(), c("Longitude", "Latitude")))#
	res
is.matrix(res)
nrow(res)
document()
type=c("arc", "arc")
type
type
type ==
"arc"
type == "GC"
(type == "GC") + (type == "arc")
sum((type == "GC") + (type == "arc"))
match("arc", type)
sort(match("arc", type))
length(sort(match("arc", type)))
type[1]
type[1] == "arc"
res
is.matrix(res)
!is.matrix(res)
if(length(type) != 2) stop("ERROR: Type must be of length two.")#
	if(sum((type == "GC") + (type == "arc")) != 2) stop("ERROR: Elements of type must be either \"arc\" or \"GC\" only.")#
	res <- GreatCircleIntersection(longitude_1, latitude_1, longitude_2, latitude_2, longitude_3, latitude_3, longitude_4, latitude_4)#
#
	# Only proceed if at least one element is an arc (otherwise res already shows GC-GC intersection pointsand no changes needed):#
	if(length(sort(match("arc", type)))) {#
		distance_to_first_intersection_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, res[, "lon1"], res[, "lat1"])#
		distance_to_second_intersection_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, res[, "lon2"], res[, "lat2"])#
		distance_to_first_intersection_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, res[, "lon1"], res[, "lat1"])#
		distance_to_second_intersection_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, res[, "lon2"], res[, "lat2"])#
#
		# If first element is an arc:#
		if(type[1] == "arc") {#
			# Set distance as smallest Great Circle distance between the two points:#
			distance_to_other_point_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, longitude_2, latitude_2)#
		# If first element is a Great Circle:#
		} else {#
			# Set distance as full circumference of planet:#
			distance_to_other_point_1 <- 2 * pi * EarthRad#
		}#
#
		# If second element is an arc:#
		if(type[2] == "arc") {#
			# Set distance as smallest Great Circle distance between the two points:#
			distance_to_other_point_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, longitude_4, latitude_4)#
		# If second element is a Great Circle:#
		} else {#
			# Set distance as full circumference of planet:#
			distance_to_other_point_2 <- 2 * pi * EarthRad#
		}#
		# Create empty delete rows vector:#
		delete.rows <- vector(mode="numeric")#
		# Make result into matrix:#
		res <- matrix(res, ncol=2, byrow=TRUE, dimnames=list(c(), c("Longitude", "Latitude")))#
		# Case if first point is an intersection:#
		if(!(distance_to_other_point_1 >= distance_to_first_intersection_1 && distance_to_other_point_2 >= distance_to_first_intersection_2)) delete.rows <- c(delete.rows, 1)#
		# Case if second point is an intersection:#
		if(!(distance_to_other_point_1 >= distance_to_second_intersection_1 && distance_to_other_point_2 >= distance_to_second_intersection_2)) delete.rows <- c(delete.rows, 2)#
		# Remove intersections outside of arcs:#
		res <- res[-delete.rows, ]#
		# Ensure res is still a matrix:#
		if(!is.matrix(res)) res <- matrix(res, ncol=2, byrow=TRUE, dimnames=list(c(), c("Longitude", "Latitude")))#
	}
#' Point(s) at which two Great Circles intersect on a sphere#
#'#
#' Given two Great Circles returns point(s) at which they intersect on a sphere.#
#'#
#' @param longitude_1 Decimalised longitude of first point on first Great Circle.#
#' @param latitude_1 Decimalised latitude of first point on first Great Circle.#
#' @param longitude_2 Decimalised longitude of second point on first Great Circle.#
#' @param latitude_2 Decimalised latitude of second point on first Great Circle.#
#' @param longitude_3 Decimalised longitude of first point on second Great Circle.#
#' @param latitude_3 Decimalised latitude of first point on second Great Circle.#
#' @param longitude_4 Decimalised longitude of second point on second Great Circle.#
#' @param latitude_4 Decimalised latitude of second point on second Great Circle.#
#' @return Matrix of longitude-latitude points at which intersection(s) occur.#
#' @details Nothing yet.#
#' @examples#
#' longitude_1 <- runif(1, -180, 180)#
#' longitude_2 <- runif(1, -180, 180)#
#' longitude_3 <- runif(1, -180, 180)#
#' longitude_4 <- runif(1, -180, 180)#
#' latitude_1 <- runif(1, -90, 90)#
#' latitude_2 <- runif(1, -90, 90)#
#' latitude_3 <- runif(1, -90, 90)#
#' latitude_4 <- runif(1, -90, 90)#
#' GreatCircleIntersection(longitude_1, latitude_1, longitude_2, latitude_2, longitude_3, latitude_3, longitude_4, latitude_4)#
#
GreatCircleIntersection <- function(longitude_1, latitude_1, longitude_2, latitude_2, longitude_3, latitude_3, longitude_4, latitude_4) {#
#
# Set up input for passing to geosphere functions:#
	p1 <- c(longitude_1, latitude_1)#
	p2 <- c(longitude_2, latitude_2)#
	p3 <- c(longitude_3, latitude_3)#
	p4 <- c(longitude_4, latitude_4)#
# All geosphere functions below this point:#
# Author: Robert J. Hijmans#
# April 2010#
# version 1#
# license GPL3#
	.normalizeLonDeg <- function(x) {#
		(x + 180) %% 360 - 180#
	}#
	.normalizeLonRad <- function(x) {#
		(x + pi) %% (2*pi) - pi #
	}#
	.isPolygon <- function(x, fix=FALSE) {#
		x <- na.omit(x)#
		if (nrow(x) < 4) {#
			stop('this is not a polygon (insufficent number of vertices)')#
		}#
		if (length(unique(x[,1]))==1) {#
			stop('All longitudes are the same (not a polygon)')#
		}#
		if (length(unique(x[,2]))==1) {#
			stop('All latitudes are the same (not a polygon)')#
		}#
		if (! all(!(is.na(x))) ) {#
			stop('polygon has NA values)')#
		}#
		if (! isTRUE(all.equal(x[1,], x[nrow(x),]))) {#
			stop('this is not a valid (closed) polygon. The first vertex is not equal to the last vertex')	#
		}#
		return(x)#
	}#
# Author: Robert J. Hijmans & Jacob van Etten#
# October 2009#
# version 1#
# license GPL3#
	.pointsToMatrix <- function(p, checkLonLat=TRUE, poly=FALSE) {#
		if (inherits(p, 'SpatialPoints')) {#
			test <- !is.projected(p)#
			if (! isTRUE (test) ) {#
				if (is.na(test)) {#
					warning('Coordinate reference system of SpatialPoints object is not set. Assuming it is degrees (longitude/latitude)!')  			#
				} else {#
					stop('Points are projected. They should be in degrees (longitude/latitude)')  #
				}#
# or rather transform them ....?#
			}#
			p <- coordinates(p)#
		} else if (is.data.frame(p)) {#
			p <- as.matrix(p)#
		} else #
		if (is.vector(p)){#
			if (length(p) != 2) {#
				stop('Wrong length for a vector, should be 2')#
			} else {#
				p <- matrix(p, ncol=2) #
			}#
		} else if (is.matrix(p)) {#
			if (length(p[1,]) != 2) {#
				stop( 'A points matrix should have 2 columns')#
			}#
			cn <- colnames(p)#
			if (length(cn) == 2) {#
				if (toupper(cn[1]) == 'Y' | toupper(cn[2]) == 'X')  {#
					warning('Suspect column names (x and y reversed?)')#
				}#
				if (toupper(substr(cn[1],1,3) == 'LAT' | toupper(substr(cn[2],1,3)) == 'LON'))  {#
					warning('Suspect column names (longitude and latitude reversed?)')#
				}#
			}		#
		} else {#
			stop('points should be vectors of length 2, matrices with 2 columns, or inheriting from a SpatialPoints* object')#
		}#
		if (! is.numeric(p) ) { p[] <- as.numeric(p) }#
		if (checkLonLat) {#
			if (length(na.omit(p[,1])) > 0) {#
				if (min(p[,1], na.rm=TRUE) < -360) { stop('longitude < -360') }#
				if (max(p[,1], na.rm=TRUE) > 360) {  stop('longitude > 360')  }#
				if (min(p[,1], na.rm=TRUE) < -180) { warning('longitude < -180') }#
				if (max(p[,1], na.rm=TRUE) > 180) {  warning('longitude > 180')  }#
			}#
			if (length(na.omit(p[,2])) > 0) {#
				if (min(p[,2], na.rm=TRUE) < -90) {  stop('latitude < -90')  }#
				if (max(p[,2], na.rm=TRUE) > 90) {  stop('latitude > 90')  }#
			}#
		}#
		if (poly) {#
			if (! isTRUE(all.equal(p[1,], p[nrow(p),]))) {#
				p <- rbind(p, p[1,])#
			} #
			i <- p[-nrow(p),1] == p[-1,1] &  p[-nrow(p),2] == p[-1,2]#
			i <- which(isTRUE(i))#
			if (length(i) > 0) {#
				p <- p[-i, ,drop=FALSE]#
			}#
			.isPolygon(p)#
		}#
		return(p)#
	}#
# author Robert Hijmans#
# October 2009#
# version 0.1#
# license GPL3#
# based on an alogrithm described by Ed Williams#
# http://williams.best.vwh.net/intersect.htm#
#intersection of two great circles defined by pt1 to pt2 and pt3 to pt4.#
	einv <- function(e) {#
		lat <- atan2(e[,3], sqrt(e[,1]^2 + e[,2]^2))#
		lon <- atan2(-e[,2], e[,1]) #
		return(cbind(lon, lat))#
	}#
	eXe5 <- function(lon1, lat1, lon2, lat2) {#
	    ex <- sin(lat1-lat2) *sin((lon1+lon2)/2) *cos((lon1-lon2)/2) - sin(lat1+lat2) *cos((lon1+lon2)/2) *sin((lon1-lon2)/2) #
		ey <- sin(lat1-lat2) *cos((lon1+lon2)/2) *cos((lon1-lon2)/2) + sin(lat1+lat2) *sin((lon1+lon2)/2) *sin((lon1-lon2)/2) #
		ez <- cos(lat1)*cos(lat2)*sin(lon1-lon2) #
		return( cbind(ex, ey, ez) )#
	}#
	eXe3 <- function(e1, e2) {#
		x <- e1[,2] * e2[,3] -e2[,2] *e1[,3]#
		y <- e1[,3] *e2[,1] -e2[,3] *e1[,1]#
		z <- e1[,1] *e2[,2] -e1[,2] *e2[,1]#
		return(cbind(x,y,z))#
	}#
	eSQRT <- function(e) {#
		return(sqrt(e[,1]^2 + e[,2]^2 + e[,3]^2))#
	}	#
	p1 <- .pointsToMatrix(p1)#
	p2 <- .pointsToMatrix(p2)#
	p3 <- .pointsToMatrix(p3)#
	p4 <- .pointsToMatrix(p4)#
	p1 <- cbind(p1[,1], p1[,2], p2[,1], p2[,2])#
	p3 <- cbind(p3[,1], p3[,2], p4[,1], p4[,2])#
	p  <- cbind(p1[,1], p1[,2], p1[,3], p1[,4], p3[,1], p3[,2], p3[,3], p3[,4])#
	p1 <- p[,1:2,drop=FALSE]#
	p2 <- p[,3:4,drop=FALSE]#
	p3 <- p[,5:6,drop=FALSE]#
	p4 <- p[,7:8,drop=FALSE]#
	res <- matrix(NA, nrow=nrow(p1), ncol=4)#
	colnames(res) <- c('lon1', 'lat1', 'lon2', 'lat2')#
	keep <- ! antipodal(p1, p2) | antipodal(p3, p4)#
	keep <- keep & ! apply(p1 == p2, 1, sum) == 2#
	if (sum(keep) == 0) { return(res) }#
	toRad <- pi / 180 #
	p1 <- p1[keep, , drop=FALSE] * toRad#
	p2 <- p2[keep, , drop=FALSE] * toRad#
	p3 <- p3[keep, , drop=FALSE] * toRad#
	p4 <- p4[keep, , drop=FALSE] * toRad#
	e1Xe2 <- eXe5(p1[,1], p1[,2], p2[,1], p2[,2])#
	e3Xe4 <- eXe5(p3[,1], p3[,2], p4[,1], p4[,2])#
	ea <- e1Xe2  / eSQRT(e1Xe2)#
	eb <- e3Xe4  / eSQRT(e3Xe4)#
	eaXeb <- eXe3(ea, eb)#
	ll <- einv(eaXeb)#
	ll2 <- cbind(ll[,1] + pi, -ll[,2])#
	pts <- cbind(ll, ll2)#
	pts[,1] <- .normalizeLonRad(pts[,1])#
	pts[,3] <- .normalizeLonRad(pts[,3])#
	res[keep,] <- pts / toRad#
#
	return(res)#
}
if(length(type) != 2) stop("ERROR: Type must be of length two.")#
	if(sum((type == "GC") + (type == "arc")) != 2) stop("ERROR: Elements of type must be either \"arc\" or \"GC\" only.")#
	res <- GreatCircleIntersection(longitude_1, latitude_1, longitude_2, latitude_2, longitude_3, latitude_3, longitude_4, latitude_4)#
#
	# Only proceed if at least one element is an arc (otherwise res already shows GC-GC intersection pointsand no changes needed):#
	if(length(sort(match("arc", type)))) {#
		distance_to_first_intersection_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, res[, "lon1"], res[, "lat1"])#
		distance_to_second_intersection_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, res[, "lon2"], res[, "lat2"])#
		distance_to_first_intersection_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, res[, "lon1"], res[, "lat1"])#
		distance_to_second_intersection_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, res[, "lon2"], res[, "lat2"])#
#
		# If first element is an arc:#
		if(type[1] == "arc") {#
			# Set distance as smallest Great Circle distance between the two points:#
			distance_to_other_point_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, longitude_2, latitude_2)#
		# If first element is a Great Circle:#
		} else {#
			# Set distance as full circumference of planet:#
			distance_to_other_point_1 <- 2 * pi * EarthRad#
		}#
#
		# If second element is an arc:#
		if(type[2] == "arc") {#
			# Set distance as smallest Great Circle distance between the two points:#
			distance_to_other_point_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, longitude_4, latitude_4)#
		# If second element is a Great Circle:#
		} else {#
			# Set distance as full circumference of planet:#
			distance_to_other_point_2 <- 2 * pi * EarthRad#
		}#
		# Create empty delete rows vector:#
		delete.rows <- vector(mode="numeric")#
		# Make result into matrix:#
		res <- matrix(res, ncol=2, byrow=TRUE, dimnames=list(c(), c("Longitude", "Latitude")))#
		# Case if first point is an intersection:#
		if(!(distance_to_other_point_1 >= distance_to_first_intersection_1 && distance_to_other_point_2 >= distance_to_first_intersection_2)) delete.rows <- c(delete.rows, 1)#
		# Case if second point is an intersection:#
		if(!(distance_to_other_point_1 >= distance_to_second_intersection_1 && distance_to_other_point_2 >= distance_to_second_intersection_2)) delete.rows <- c(delete.rows, 2)#
		# Remove intersections outside of arcs:#
		res <- res[-delete.rows, ]#
		# Ensure res is still a matrix:#
		if(!is.matrix(res)) res <- matrix(res, ncol=2, byrow=TRUE, dimnames=list(c(), c("Longitude", "Latitude")))#
	}
res
type<-c("arc", "GC")
if(length(type) != 2) stop("ERROR: Type must be of length two.")#
	if(sum((type == "GC") + (type == "arc")) != 2) stop("ERROR: Elements of type must be either \"arc\" or \"GC\" only.")#
	res <- GreatCircleIntersection(longitude_1, latitude_1, longitude_2, latitude_2, longitude_3, latitude_3, longitude_4, latitude_4)#
#
	# Only proceed if at least one element is an arc (otherwise res already shows GC-GC intersection pointsand no changes needed):#
	if(length(sort(match("arc", type)))) {#
		distance_to_first_intersection_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, res[, "lon1"], res[, "lat1"])#
		distance_to_second_intersection_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, res[, "lon2"], res[, "lat2"])#
		distance_to_first_intersection_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, res[, "lon1"], res[, "lat1"])#
		distance_to_second_intersection_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, res[, "lon2"], res[, "lat2"])#
#
		# If first element is an arc:#
		if(type[1] == "arc") {#
			# Set distance as smallest Great Circle distance between the two points:#
			distance_to_other_point_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, longitude_2, latitude_2)#
		# If first element is a Great Circle:#
		} else {#
			# Set distance as full circumference of planet:#
			distance_to_other_point_1 <- 2 * pi * EarthRad#
		}#
#
		# If second element is an arc:#
		if(type[2] == "arc") {#
			# Set distance as smallest Great Circle distance between the two points:#
			distance_to_other_point_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, longitude_4, latitude_4)#
		# If second element is a Great Circle:#
		} else {#
			# Set distance as full circumference of planet:#
			distance_to_other_point_2 <- 2 * pi * EarthRad#
		}#
		# Create empty delete rows vector:#
		delete.rows <- vector(mode="numeric")#
		# Make result into matrix:#
		res <- matrix(res, ncol=2, byrow=TRUE, dimnames=list(c(), c("Longitude", "Latitude")))#
		# Case if first point is an intersection:#
		if(!(distance_to_other_point_1 >= distance_to_first_intersection_1 && distance_to_other_point_2 >= distance_to_first_intersection_2)) delete.rows <- c(delete.rows, 1)#
		# Case if second point is an intersection:#
		if(!(distance_to_other_point_1 >= distance_to_second_intersection_1 && distance_to_other_point_2 >= distance_to_second_intersection_2)) delete.rows <- c(delete.rows, 2)#
		# Remove intersections outside of arcs:#
		res <- res[-delete.rows, ]#
		# Ensure res is still a matrix:#
		if(!is.matrix(res)) res <- matrix(res, ncol=2, byrow=TRUE, dimnames=list(c(), c("Longitude", "Latitude")))#
	}
res
type<-c("GC", "arc")
if(length(type) != 2) stop("ERROR: Type must be of length two.")#
	if(sum((type == "GC") + (type == "arc")) != 2) stop("ERROR: Elements of type must be either \"arc\" or \"GC\" only.")#
	res <- GreatCircleIntersection(longitude_1, latitude_1, longitude_2, latitude_2, longitude_3, latitude_3, longitude_4, latitude_4)#
#
	# Only proceed if at least one element is an arc (otherwise res already shows GC-GC intersection pointsand no changes needed):#
	if(length(sort(match("arc", type)))) {#
		distance_to_first_intersection_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, res[, "lon1"], res[, "lat1"])#
		distance_to_second_intersection_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, res[, "lon2"], res[, "lat2"])#
		distance_to_first_intersection_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, res[, "lon1"], res[, "lat1"])#
		distance_to_second_intersection_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, res[, "lon2"], res[, "lat2"])#
#
		# If first element is an arc:#
		if(type[1] == "arc") {#
			# Set distance as smallest Great Circle distance between the two points:#
			distance_to_other_point_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, longitude_2, latitude_2)#
		# If first element is a Great Circle:#
		} else {#
			# Set distance as full circumference of planet:#
			distance_to_other_point_1 <- 2 * pi * EarthRad#
		}#
#
		# If second element is an arc:#
		if(type[2] == "arc") {#
			# Set distance as smallest Great Circle distance between the two points:#
			distance_to_other_point_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, longitude_4, latitude_4)#
		# If second element is a Great Circle:#
		} else {#
			# Set distance as full circumference of planet:#
			distance_to_other_point_2 <- 2 * pi * EarthRad#
		}#
		# Create empty delete rows vector:#
		delete.rows <- vector(mode="numeric")#
		# Make result into matrix:#
		res <- matrix(res, ncol=2, byrow=TRUE, dimnames=list(c(), c("Longitude", "Latitude")))#
		# Case if first point is an intersection:#
		if(!(distance_to_other_point_1 >= distance_to_first_intersection_1 && distance_to_other_point_2 >= distance_to_first_intersection_2)) delete.rows <- c(delete.rows, 1)#
		# Case if second point is an intersection:#
		if(!(distance_to_other_point_1 >= distance_to_second_intersection_1 && distance_to_other_point_2 >= distance_to_second_intersection_2)) delete.rows <- c(delete.rows, 2)#
		# Remove intersections outside of arcs:#
		res <- res[-delete.rows, ]#
		# Ensure res is still a matrix:#
		if(!is.matrix(res)) res <- matrix(res, ncol=2, byrow=TRUE, dimnames=list(c(), c("Longitude", "Latitude")))#
	}
res
distance_to_other_point_2
distance_to_other_point_1
distance_to_first_intersection_1
distance_to_second_intersection_1
min_separation
longitudes
latitudes
continent_numbers
continent_numbers <- c("1", "2", "3", "4", "5", "6", "7")
continent_numbers
EarthRad
protected_links
matrix(c(1,2), ncol=2)
protected_links <- matrix(c(1,2), ncol=2)
intercontinent_links <- IntercontinentalLinks(min_separation, longitudes, latitudes, EarthRad = EarthRad)
intercontinent_links
intercontinent_links == 1
which(intercontinent_links == 1)
sample(which(intercontinent_links == 1))
sample(which(intercontinent_links == 1))[1]
sample(which(intercontinent_links == 1))[1] %% nrow(intercontinent_links)
?%%
??modulo
sample(which(intercontinent_links == 1))[1] / nrow(intercontinent_links)
floor(sample(which(intercontinent_links == 1))[1] / nrow(intercontinent_links))
which(intercontinent_links == 1))[1]
which(intercontinent_links == 1))[1]
sample(which(intercontinent_links == 1))[1]
link_position <- sample(which(intercontinent_links == 1))[1]#
	link_position %% nrow(intercontinent_links)#
	floor(link_position / nrow(intercontinent_links))
intercontinent_links
link_position <- sample(which(intercontinent_links == 1))[1]#
	link_position %% nrow(intercontinent_links)#
	ceiling(link_position / nrow(intercontinent_links))
link_position <- sample(which(intercontinent_links == 1))[1]#
	link_position %% nrow(intercontinent_links)#
	ceiling(link_position / nrow(intercontinent_links))
link_position <- sample(which(intercontinent_links == 1))[1]#
	link_position %% nrow(intercontinent_links)#
	ceiling(link_position / nrow(intercontinent_links))
link_position <- sample(which(intercontinent_links == 1))[1]#
	link_position %% nrow(intercontinent_links)#
	ceiling(link_position / nrow(intercontinent_links))
link_position <- sample(which(intercontinent_links == 1))[1]#
	link_position %% nrow(intercontinent_links)#
	ceiling(link_position / nrow(intercontinent_links))
sort(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links)))
link_position <- sample(which(intercontinent_links == 1))[1]#
	sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))
protected_links
intercontinent_links
continent_numbers
document()
# Get all intercontinental links in cluster:#
	unprotected_links <- intercontinent_links <- IntercontinentalLinks(min_separation, longitudes, latitudes, EarthRad = EarthRad)
matrix(nrow=0, ncol=2)
protected_links
nrow(protected_links)
nrow(protected_links) > 0
protected_links
protected_links[i, ]
protected_links[i, 1]
# Get all intercontinental links in cluster:#
	unprotected_links <- intercontinent_links <- IntercontinentalLinks(min_separation, longitudes, latitudes, EarthRad = EarthRad)#
# Check that there are unprotected links:#
	if(nrow(protected_links) > 0) {#
		for(i in 1:nrow(protected_links)) {#
			unprotected_links[protected_links[i, 1], protected_links[i, 2]] <- unprotected_links[protected_links[i, 2], protected_links[i, 1]] <- 0#
		}#
	}
unprotected_links
intercontinent_links
sum(unprotected_links)
sum(unprotected_links[lower.tri])
sum(unprotected_links[lower.tri(unprotected_links)])
sum(unprotected_links[lower.tri(unprotected_links)]) > 0
# Pick a random link from the matrix:#
		link_position <- sample(which(intercontinent_links == 1))[1]#
		sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))
unprotected_links[start_link[1], start_link[2]]
start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))
satrt_link
start_link
unprotected_links[start_link[1], start_link[2]]
intercontinental_links[start_link[1], start_link[2]]
intercontinent_links[start_link[1], start_link[2]]
intercontinent_links[start_link[1], start_link[2]]
intercontinent_links[start_link[1], start_link[2]]
satrt_link
start_link
start_link[1]
continent_numbers
continent_numbers <- c("1", "2", "3", "5", "7", "8", "10")
# Get all intercontinental links in cluster:#
	unprotected_links <- intercontinent_links <- IntercontinentalLinks(min_separation, longitudes, latitudes, EarthRad = EarthRad)
unprotected_links
continent_numbers
as.character(continent_numbers)
# Make sure continent numbers are stored as character vector for matching:#
	continent_numbers <- as.character(continent_numbers)#
	# Get all intercontinental links in cluster:#
	unprotected_links <- intercontinent_links <- IntercontinentalLinks(min_separation, longitudes, latitudes, EarthRad = EarthRad)#
	# Add row and column names:#
	colnames(unprotected_links) <- colnames(intercontinent_links) <- rownames(unprotected_links) <- rownames(intercontinent_links) <- continent_numbers
unprotected_links
# If there are protected links:#
	if(nrow(protected_links) > 0) {#
		# For each protected link:#
		for(i in 1:nrow(protected_links)) {
}
}
protected_links[i, 1
]
protected_links[i, 1]
protected_links[i, 2]
# Make sure continent numbers are stored as character vector for matching:#
	continent_numbers <- as.character(continent_numbers)#
	# Get all intercontinental links in cluster:#
	unprotected_links <- intercontinent_links <- IntercontinentalLinks(min_separation, longitudes, latitudes, EarthRad = EarthRad)#
	# Add row and column names:#
	colnames(unprotected_links) <- colnames(intercontinent_links) <- rownames(unprotected_links) <- rownames(intercontinent_links) <- continent_numbers#
	# If there are protected links:#
	if(nrow(protected_links) > 0) {#
		# For each protected link:#
		for(i in 1:nrow(protected_links)) {#
			# Update unprotected links by setting protecetd link state to zero:#
			unprotected_links[as.character(protected_links[i, 1]), as.character(protected_links[i, 2])] <- unprotected_links[as.character(protected_links[i, 2]), as.character(protected_links[i, 1])] <- 0#
		}#
	}
unprotected_links
sum(unprotected_links[lower.tri(unprotected_links)])
unprotected_links[lower.tri(unprotected_links)]
# Pick a random link from the matrix:#
		link_position <- sample(which(intercontinent_links == 1))[1]#
		# Set starting link (from continent to continent):#
		start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))
start_link
# Pick a random link from the matrix:#
		link_position <- sample(which(intercontinent_links == 1))[1]#
		# Set starting link (from continent to continent):#
		start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))
start_link
# Pick a random link from the matrix:#
		link_position <- sample(which(intercontinent_links == 1))[1]#
		# Set starting link (from continent to continent):#
		start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))
start_link
intercontinent_links
start_link
as.character(start_link)
# Define start links by continent numbers:#
		start_link <- colnames(intercontinent_links)[start_link]
start_link
match(start_link[1], colnames(intercontinent_links))
intercontinent_links
longitudes[match(start_link[1], colnames(intercontinent_links))]
start_link_start_longitude <- longitudes[match(start_link[1], colnames(intercontinent_links))]#
		start_link_start_latitude <- latitudes[match(start_link[1], colnames(intercontinent_links))]
start_link_start_longitude
start_link_start_latitude
random_link_start_longitude <- longitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_start_latitude <- latitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_end_longitude <- longitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_end_latitude <- latitudes[match(start_link[2], colnames(intercontinent_links))]
random_link_start_longitude
random_link_start_latitude
random_link_end_longitude
random_link_end_latitude
random_link_start_longitude <- longitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_start_latitude <- latitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_end_longitude <- longitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_end_latitude <- latitudes[match(start_link[2], colnames(intercontinent_links))]#
		BearingBetweenTwoLongLatPoints(random_link_start_longitude, random_link_start_latitude, random_link_end_longitude, random_link_end_latitude)
random_link_start_longitude <- longitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_start_latitude <- latitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_end_longitude <- longitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_end_latitude <- latitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_start_bearing <- BearingBetweenTwoLongLatPoints(random_link_start_longitude, random_link_start_latitude, random_link_end_longitude, random_link_end_latitude)
random_link_start_bearing
runif(1, 0, min_separation)
EndPoint(random_link_start_longitude, random_link_start_latitude, random_link_start_bearing, random_distance)
random_link_start_longitude <- longitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_start_latitude <- latitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_end_longitude <- longitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_end_latitude <- latitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_start_bearing <- BearingBetweenTwoLongLatPoints(random_link_start_longitude, random_link_start_latitude, random_link_end_longitude, random_link_end_latitude)#
		random_distance <- runif(1, 0, min_separation)
EndPoint(random_link_start_longitude, random_link_start_latitude, random_link_start_bearing, random_distance)
cut_point <- EndPoint(random_link_start_longitude, random_link_start_latitude, random_link_start_bearing, random_distance)[c("long", "lat")]
cut_point
runif(1, 0, 360)
# Define point at which cut will begin:#
		cut_point_1 <- EndPoint(random_link_start_longitude, random_link_start_latitude, random_link_start_bearing, random_distance)[c("long", "lat")]#
		# Get cut bearing (will be used to describe Great Circle made by cut):#
		cut_bearing <- runif(1, 0, 360)#
		cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]
protected_links
protected_links[i, ]
as.character(protected_links[i, ])[1]
match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))
longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))]
ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)
#' Point(s) at which two arcs intersect on a sphere#
#'#
#' Given two arcs returns point(s) at which they intersect on a sphere.#
#'#
#' @param longitude_1 Decimalised longitude of first point on first arc.#
#' @param latitude_1 Decimalised latitude of first point on first arc.#
#' @param longitude_2 Decimalised longitude of second point on first arc.#
#' @param latitude_2 Decimalised latitude of second point on first arc.#
#' @param longitude_3 Decimalised longitude of first point on second arc.#
#' @param latitude_3 Decimalised latitude of first point on second arc.#
#' @param longitude_4 Decimalised longitude of second point on second arc.#
#' @param latitude_4 Decimalised latitude of second point on second arc.#
#' @param type Vector to indicate if elements are arcs or Great Circles.#
#' @param EarthRad Earth radius in kilometres.#
#' @return Matrix of longitude-latitude points at which intersection(s) occur.#
#' @details Assumes shortest distance between points describes arc. Can define Great Circle-arc intersection with \code{type} option. #
#' @examples#
#' longitude_1 <- runif(1, -180, 180)#
#' longitude_2 <- runif(1, -180, 180)#
#' longitude_3 <- runif(1, -180, 180)#
#' longitude_4 <- runif(1, -180, 180)#
#' latitude_1 <- runif(1, -90, 90)#
#' latitude_2 <- runif(1, -90, 90)#
#' latitude_3 <- runif(1, -90, 90)#
#' latitude_4 <- runif(1, -90, 90)#
#' ArcIntersection(longitude_1, latitude_1, longitude_2, latitude_2, longitude_3, latitude_3, longitude_4, latitude_4, EarthRad = 6367.4447)#
#
ArcIntersection <- function(longitude_1, latitude_1, longitude_2, latitude_2, longitude_3, latitude_3, longitude_4, latitude_4, type = c("arc", "arc"), EarthRad = 6367.4447) {#
#
	# Check type is of correct length:#
	if(length(type) != 2) stop("ERROR: Type must be of length two.")#
	# Check elements of type are of the correct type:#
	if(sum((type == "GC") + (type == "arc")) != 2) stop("ERROR: Elements of type must be either \"arc\" or \"GC\" only.")#
	# Get intersection points of the two Great Circles described by the arcs:#
	res <- GreatCircleIntersection(longitude_1, latitude_1, longitude_2, latitude_2, longitude_3, latitude_3, longitude_4, latitude_4, EarthRad = EarthRad)#
#
	# Only proceed if at least one element is an arc (otherwise res already shows GC-GC intersection pointsand no changes needed):#
	if(length(sort(match("arc", type)))) {#
		# Calculate distance from first point on first arc to first intersection point:#
		distance_to_first_intersection_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, res[, "lon1"], res[, "lat1"], EarthRad = EarthRad)#
		# Calculate distance from first point on first arc to second intersection point:#
		distance_to_second_intersection_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, res[, "lon2"], res[, "lat2"], EarthRad = EarthRad)#
		# Calculate distance from first point on second arc to first intersection point:#
		distance_to_first_intersection_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, res[, "lon1"], res[, "lat1"], EarthRad = EarthRad)#
		# Calculate distance from first point on second arc to second intersection point:#
		distance_to_second_intersection_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, res[, "lon2"], res[, "lat2"], EarthRad = EarthRad)#
#
		# If first element is an arc:#
		if(type[1] == "arc") {#
			# Set distance as smallest Great Circle distance between the two points:#
			distance_to_other_point_1 <- GreatCircleDistanceFromLongLat(longitude_1, latitude_1, longitude_2, latitude_2, EarthRad = EarthRad)#
		# If first element is a Great Circle:#
		} else {#
			# Set distance as full circumference of planet:#
			distance_to_other_point_1 <- 2 * pi * EarthRad#
		}#
#
		# If second element is an arc:#
		if(type[2] == "arc") {#
			# Set distance as smallest Great Circle distance between the two points:#
			distance_to_other_point_2 <- GreatCircleDistanceFromLongLat(longitude_3, latitude_3, longitude_4, latitude_4, EarthRad = EarthRad)#
		# If second element is a Great Circle:#
		} else {#
			# Set distance as full circumference of planet:#
			distance_to_other_point_2 <- 2 * pi * EarthRad#
		}#
		# Create empty delete rows vector (will store intersection points outside of arcs):#
		delete.rows <- vector(mode="numeric")#
		# Make result into matrix:#
		res <- matrix(res, ncol=2, byrow=TRUE, dimnames=list(c(), c("Longitude", "Latitude")))#
		# Case if first point is not an actual intersection:#
		if(!(distance_to_other_point_1 >= distance_to_first_intersection_1 && distance_to_other_point_2 >= distance_to_first_intersection_2)) delete.rows <- c(delete.rows, 1)#
		# Case if second point is not an actual intersection:#
		if(!(distance_to_other_point_1 >= distance_to_second_intersection_1 && distance_to_other_point_2 >= distance_to_second_intersection_2)) delete.rows <- c(delete.rows, 2)#
		# Remove intersections outside of arcs:#
		res <- res[-delete.rows, ]#
		# Ensure res is still a matrix:#
		if(!is.matrix(res)) res <- matrix(res, ncol=2, byrow=TRUE, dimnames=list(c(), c("Longitude", "Latitude")))#
	# Case if a Great Circle-Great Circle intersection:#
	} else {#
		# Make result into matrix:#
		res <- matrix(res, ncol=2, byrow=TRUE, dimnames=list(c(), c("Longitude", "Latitude")))#
	}#
	# Return matrix of zero, one, or two rows (depending on number of intersection points):#
	return(res)#
}
ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)
#' Point(s) at which two Great Circles intersect on a sphere#
#'#
#' Given two Great Circles returns point(s) at which they intersect on a sphere.#
#'#
#' @param longitude_1 Decimalised longitude of first point on first Great Circle.#
#' @param latitude_1 Decimalised latitude of first point on first Great Circle.#
#' @param longitude_2 Decimalised longitude of second point on first Great Circle.#
#' @param latitude_2 Decimalised latitude of second point on first Great Circle.#
#' @param longitude_3 Decimalised longitude of first point on second Great Circle.#
#' @param latitude_3 Decimalised latitude of first point on second Great Circle.#
#' @param longitude_4 Decimalised longitude of second point on second Great Circle.#
#' @param latitude_4 Decimalised latitude of second point on second Great Circle.#
#' @return Matrix of longitude-latitude points at which intersection(s) occur.#
#' @details Nothing yet.#
#' @examples#
#' longitude_1 <- runif(1, -180, 180)#
#' longitude_2 <- runif(1, -180, 180)#
#' longitude_3 <- runif(1, -180, 180)#
#' longitude_4 <- runif(1, -180, 180)#
#' latitude_1 <- runif(1, -90, 90)#
#' latitude_2 <- runif(1, -90, 90)#
#' latitude_3 <- runif(1, -90, 90)#
#' latitude_4 <- runif(1, -90, 90)#
#' GreatCircleIntersection(longitude_1, latitude_1, longitude_2, latitude_2, longitude_3, latitude_3, longitude_4, latitude_4)#
#
GreatCircleIntersection <- function(longitude_1, latitude_1, longitude_2, latitude_2, longitude_3, latitude_3, longitude_4, latitude_4) {#
#
# Set up input for passing to geosphere functions:#
	p1 <- c(longitude_1, latitude_1)#
	p2 <- c(longitude_2, latitude_2)#
	p3 <- c(longitude_3, latitude_3)#
	p4 <- c(longitude_4, latitude_4)#
# All geosphere functions below this point:#
# Author: Robert J. Hijmans#
# April 2010#
# version 1#
# license GPL3#
	.normalizeLonDeg <- function(x) {#
		(x + 180) %% 360 - 180#
	}#
	.normalizeLonRad <- function(x) {#
		(x + pi) %% (2*pi) - pi #
	}#
	.isPolygon <- function(x, fix=FALSE) {#
		x <- na.omit(x)#
		if (nrow(x) < 4) {#
			stop('this is not a polygon (insufficent number of vertices)')#
		}#
		if (length(unique(x[,1]))==1) {#
			stop('All longitudes are the same (not a polygon)')#
		}#
		if (length(unique(x[,2]))==1) {#
			stop('All latitudes are the same (not a polygon)')#
		}#
		if (! all(!(is.na(x))) ) {#
			stop('polygon has NA values)')#
		}#
		if (! isTRUE(all.equal(x[1,], x[nrow(x),]))) {#
			stop('this is not a valid (closed) polygon. The first vertex is not equal to the last vertex')	#
		}#
		return(x)#
	}#
# Author: Robert J. Hijmans & Jacob van Etten#
# October 2009#
# version 1#
# license GPL3#
	.pointsToMatrix <- function(p, checkLonLat=TRUE, poly=FALSE) {#
		if (inherits(p, 'SpatialPoints')) {#
			test <- !is.projected(p)#
			if (! isTRUE (test) ) {#
				if (is.na(test)) {#
					warning('Coordinate reference system of SpatialPoints object is not set. Assuming it is degrees (longitude/latitude)!')  			#
				} else {#
					stop('Points are projected. They should be in degrees (longitude/latitude)')  #
				}#
# or rather transform them ....?#
			}#
			p <- coordinates(p)#
		} else if (is.data.frame(p)) {#
			p <- as.matrix(p)#
		} else #
		if (is.vector(p)){#
			if (length(p) != 2) {#
				stop('Wrong length for a vector, should be 2')#
			} else {#
				p <- matrix(p, ncol=2) #
			}#
		} else if (is.matrix(p)) {#
			if (length(p[1,]) != 2) {#
				stop( 'A points matrix should have 2 columns')#
			}#
			cn <- colnames(p)#
			if (length(cn) == 2) {#
				if (toupper(cn[1]) == 'Y' | toupper(cn[2]) == 'X')  {#
					warning('Suspect column names (x and y reversed?)')#
				}#
				if (toupper(substr(cn[1],1,3) == 'LAT' | toupper(substr(cn[2],1,3)) == 'LON'))  {#
					warning('Suspect column names (longitude and latitude reversed?)')#
				}#
			}		#
		} else {#
			stop('points should be vectors of length 2, matrices with 2 columns, or inheriting from a SpatialPoints* object')#
		}#
		if (! is.numeric(p) ) { p[] <- as.numeric(p) }#
		if (checkLonLat) {#
			if (length(na.omit(p[,1])) > 0) {#
				if (min(p[,1], na.rm=TRUE) < -360) { stop('longitude < -360') }#
				if (max(p[,1], na.rm=TRUE) > 360) {  stop('longitude > 360')  }#
				if (min(p[,1], na.rm=TRUE) < -180) { warning('longitude < -180') }#
				if (max(p[,1], na.rm=TRUE) > 180) {  warning('longitude > 180')  }#
			}#
			if (length(na.omit(p[,2])) > 0) {#
				if (min(p[,2], na.rm=TRUE) < -90) {  stop('latitude < -90')  }#
				if (max(p[,2], na.rm=TRUE) > 90) {  stop('latitude > 90')  }#
			}#
		}#
		if (poly) {#
			if (! isTRUE(all.equal(p[1,], p[nrow(p),]))) {#
				p <- rbind(p, p[1,])#
			} #
			i <- p[-nrow(p),1] == p[-1,1] &  p[-nrow(p),2] == p[-1,2]#
			i <- which(isTRUE(i))#
			if (length(i) > 0) {#
				p <- p[-i, ,drop=FALSE]#
			}#
			.isPolygon(p)#
		}#
		return(p)#
	}#
# author Robert Hijmans#
# October 2009#
# version 0.1#
# license GPL3#
# based on an alogrithm described by Ed Williams#
# http://williams.best.vwh.net/intersect.htm#
#intersection of two great circles defined by pt1 to pt2 and pt3 to pt4.#
	einv <- function(e) {#
		lat <- atan2(e[,3], sqrt(e[,1]^2 + e[,2]^2))#
		lon <- atan2(-e[,2], e[,1]) #
		return(cbind(lon, lat))#
	}#
	eXe5 <- function(lon1, lat1, lon2, lat2) {#
	    ex <- sin(lat1-lat2) *sin((lon1+lon2)/2) *cos((lon1-lon2)/2) - sin(lat1+lat2) *cos((lon1+lon2)/2) *sin((lon1-lon2)/2) #
		ey <- sin(lat1-lat2) *cos((lon1+lon2)/2) *cos((lon1-lon2)/2) + sin(lat1+lat2) *sin((lon1+lon2)/2) *sin((lon1-lon2)/2) #
		ez <- cos(lat1)*cos(lat2)*sin(lon1-lon2) #
		return( cbind(ex, ey, ez) )#
	}#
	eXe3 <- function(e1, e2) {#
		x <- e1[,2] * e2[,3] -e2[,2] *e1[,3]#
		y <- e1[,3] *e2[,1] -e2[,3] *e1[,1]#
		z <- e1[,1] *e2[,2] -e1[,2] *e2[,1]#
		return(cbind(x,y,z))#
	}#
	eSQRT <- function(e) {#
		return(sqrt(e[,1]^2 + e[,2]^2 + e[,3]^2))#
	}	#
	p1 <- .pointsToMatrix(p1)#
	p2 <- .pointsToMatrix(p2)#
	p3 <- .pointsToMatrix(p3)#
	p4 <- .pointsToMatrix(p4)#
	p1 <- cbind(p1[,1], p1[,2], p2[,1], p2[,2])#
	p3 <- cbind(p3[,1], p3[,2], p4[,1], p4[,2])#
	p  <- cbind(p1[,1], p1[,2], p1[,3], p1[,4], p3[,1], p3[,2], p3[,3], p3[,4])#
	p1 <- p[,1:2,drop=FALSE]#
	p2 <- p[,3:4,drop=FALSE]#
	p3 <- p[,5:6,drop=FALSE]#
	p4 <- p[,7:8,drop=FALSE]#
	res <- matrix(NA, nrow=nrow(p1), ncol=4)#
	colnames(res) <- c('lon1', 'lat1', 'lon2', 'lat2')#
	keep <- ! antipodal(p1, p2) | antipodal(p3, p4)#
	keep <- keep & ! apply(p1 == p2, 1, sum) == 2#
	if (sum(keep) == 0) { return(res) }#
	toRad <- pi / 180 #
	p1 <- p1[keep, , drop=FALSE] * toRad#
	p2 <- p2[keep, , drop=FALSE] * toRad#
	p3 <- p3[keep, , drop=FALSE] * toRad#
	p4 <- p4[keep, , drop=FALSE] * toRad#
	e1Xe2 <- eXe5(p1[,1], p1[,2], p2[,1], p2[,2])#
	e3Xe4 <- eXe5(p3[,1], p3[,2], p4[,1], p4[,2])#
	ea <- e1Xe2  / eSQRT(e1Xe2)#
	eb <- e3Xe4  / eSQRT(e3Xe4)#
	eaXeb <- eXe3(ea, eb)#
	ll <- einv(eaXeb)#
	ll2 <- cbind(ll[,1] + pi, -ll[,2])#
	pts <- cbind(ll, ll2)#
	pts[,1] <- .normalizeLonRad(pts[,1])#
	pts[,3] <- .normalizeLonRad(pts[,3])#
	res[keep,] <- pts / toRad#
#
	return(res)#
}
ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)
EarthRad
#' Point(s) at which two Great Circles intersect on a sphere#
#'#
#' Given two Great Circles returns point(s) at which they intersect on a sphere.#
#'#
#' @param longitude_1 Decimalised longitude of first point on first Great Circle.#
#' @param latitude_1 Decimalised latitude of first point on first Great Circle.#
#' @param longitude_2 Decimalised longitude of second point on first Great Circle.#
#' @param latitude_2 Decimalised latitude of second point on first Great Circle.#
#' @param longitude_3 Decimalised longitude of first point on second Great Circle.#
#' @param latitude_3 Decimalised latitude of first point on second Great Circle.#
#' @param longitude_4 Decimalised longitude of second point on second Great Circle.#
#' @param latitude_4 Decimalised latitude of second point on second Great Circle.#
#' @param EarthRad Earth radius in kilometres.#
#' @return Matrix of longitude-latitude points at which intersection(s) occur.#
#' @details Nothing yet.#
#'#
#' @examples#
#' longitude_1 <- runif(1, -180, 180)#
#' longitude_2 <- runif(1, -180, 180)#
#' longitude_3 <- runif(1, -180, 180)#
#' longitude_4 <- runif(1, -180, 180)#
#' latitude_1 <- runif(1, -90, 90)#
#' latitude_2 <- runif(1, -90, 90)#
#' latitude_3 <- runif(1, -90, 90)#
#' latitude_4 <- runif(1, -90, 90)#
#' GreatCircleIntersection(longitude_1, latitude_1, longitude_2, latitude_2, longitude_3, latitude_3, longitude_4, latitude_4)#
#
GreatCircleIntersection <- function(longitude_1, latitude_1, longitude_2, latitude_2, longitude_3, latitude_3, longitude_4, latitude_4, EarthRad = 6367.4447) {#
#
# Set up input for passing to geosphere functions:#
	p1 <- c(longitude_1, latitude_1)#
	p2 <- c(longitude_2, latitude_2)#
	p3 <- c(longitude_3, latitude_3)#
	p4 <- c(longitude_4, latitude_4)#
# All geosphere functions below this point:#
# Author: Robert J. Hijmans#
# April 2010#
# version 1#
# license GPL3#
	.normalizeLonDeg <- function(x) {#
		(x + 180) %% 360 - 180#
	}#
	.normalizeLonRad <- function(x) {#
		(x + pi) %% (2*pi) - pi #
	}#
	.isPolygon <- function(x, fix=FALSE) {#
		x <- na.omit(x)#
		if (nrow(x) < 4) {#
			stop('this is not a polygon (insufficent number of vertices)')#
		}#
		if (length(unique(x[,1]))==1) {#
			stop('All longitudes are the same (not a polygon)')#
		}#
		if (length(unique(x[,2]))==1) {#
			stop('All latitudes are the same (not a polygon)')#
		}#
		if (! all(!(is.na(x))) ) {#
			stop('polygon has NA values)')#
		}#
		if (! isTRUE(all.equal(x[1,], x[nrow(x),]))) {#
			stop('this is not a valid (closed) polygon. The first vertex is not equal to the last vertex')	#
		}#
		return(x)#
	}#
# Author: Robert J. Hijmans & Jacob van Etten#
# October 2009#
# version 1#
# license GPL3#
	.pointsToMatrix <- function(p, checkLonLat=TRUE, poly=FALSE) {#
		if (inherits(p, 'SpatialPoints')) {#
			test <- !is.projected(p)#
			if (! isTRUE (test) ) {#
				if (is.na(test)) {#
					warning('Coordinate reference system of SpatialPoints object is not set. Assuming it is degrees (longitude/latitude)!')  			#
				} else {#
					stop('Points are projected. They should be in degrees (longitude/latitude)')  #
				}#
# or rather transform them ....?#
			}#
			p <- coordinates(p)#
		} else if (is.data.frame(p)) {#
			p <- as.matrix(p)#
		} else #
		if (is.vector(p)){#
			if (length(p) != 2) {#
				stop('Wrong length for a vector, should be 2')#
			} else {#
				p <- matrix(p, ncol=2) #
			}#
		} else if (is.matrix(p)) {#
			if (length(p[1,]) != 2) {#
				stop( 'A points matrix should have 2 columns')#
			}#
			cn <- colnames(p)#
			if (length(cn) == 2) {#
				if (toupper(cn[1]) == 'Y' | toupper(cn[2]) == 'X')  {#
					warning('Suspect column names (x and y reversed?)')#
				}#
				if (toupper(substr(cn[1],1,3) == 'LAT' | toupper(substr(cn[2],1,3)) == 'LON'))  {#
					warning('Suspect column names (longitude and latitude reversed?)')#
				}#
			}		#
		} else {#
			stop('points should be vectors of length 2, matrices with 2 columns, or inheriting from a SpatialPoints* object')#
		}#
		if (! is.numeric(p) ) { p[] <- as.numeric(p) }#
		if (checkLonLat) {#
			if (length(na.omit(p[,1])) > 0) {#
				if (min(p[,1], na.rm=TRUE) < -360) { stop('longitude < -360') }#
				if (max(p[,1], na.rm=TRUE) > 360) {  stop('longitude > 360')  }#
				if (min(p[,1], na.rm=TRUE) < -180) { warning('longitude < -180') }#
				if (max(p[,1], na.rm=TRUE) > 180) {  warning('longitude > 180')  }#
			}#
			if (length(na.omit(p[,2])) > 0) {#
				if (min(p[,2], na.rm=TRUE) < -90) {  stop('latitude < -90')  }#
				if (max(p[,2], na.rm=TRUE) > 90) {  stop('latitude > 90')  }#
			}#
		}#
		if (poly) {#
			if (! isTRUE(all.equal(p[1,], p[nrow(p),]))) {#
				p <- rbind(p, p[1,])#
			} #
			i <- p[-nrow(p),1] == p[-1,1] &  p[-nrow(p),2] == p[-1,2]#
			i <- which(isTRUE(i))#
			if (length(i) > 0) {#
				p <- p[-i, ,drop=FALSE]#
			}#
			.isPolygon(p)#
		}#
		return(p)#
	}#
# author Robert Hijmans#
# October 2009#
# version 0.1#
# license GPL3#
# based on an alogrithm described by Ed Williams#
# http://williams.best.vwh.net/intersect.htm#
#intersection of two great circles defined by pt1 to pt2 and pt3 to pt4.#
	einv <- function(e) {#
		lat <- atan2(e[,3], sqrt(e[,1]^2 + e[,2]^2))#
		lon <- atan2(-e[,2], e[,1]) #
		return(cbind(lon, lat))#
	}#
	eXe5 <- function(lon1, lat1, lon2, lat2) {#
	    ex <- sin(lat1-lat2) *sin((lon1+lon2)/2) *cos((lon1-lon2)/2) - sin(lat1+lat2) *cos((lon1+lon2)/2) *sin((lon1-lon2)/2) #
		ey <- sin(lat1-lat2) *cos((lon1+lon2)/2) *cos((lon1-lon2)/2) + sin(lat1+lat2) *sin((lon1+lon2)/2) *sin((lon1-lon2)/2) #
		ez <- cos(lat1)*cos(lat2)*sin(lon1-lon2) #
		return( cbind(ex, ey, ez) )#
	}#
	eXe3 <- function(e1, e2) {#
		x <- e1[,2] * e2[,3] -e2[,2] *e1[,3]#
		y <- e1[,3] *e2[,1] -e2[,3] *e1[,1]#
		z <- e1[,1] *e2[,2] -e1[,2] *e2[,1]#
		return(cbind(x,y,z))#
	}#
	eSQRT <- function(e) {#
		return(sqrt(e[,1]^2 + e[,2]^2 + e[,3]^2))#
	}	#
	p1 <- .pointsToMatrix(p1)#
	p2 <- .pointsToMatrix(p2)#
	p3 <- .pointsToMatrix(p3)#
	p4 <- .pointsToMatrix(p4)#
	p1 <- cbind(p1[,1], p1[,2], p2[,1], p2[,2])#
	p3 <- cbind(p3[,1], p3[,2], p4[,1], p4[,2])#
	p  <- cbind(p1[,1], p1[,2], p1[,3], p1[,4], p3[,1], p3[,2], p3[,3], p3[,4])#
	p1 <- p[,1:2,drop=FALSE]#
	p2 <- p[,3:4,drop=FALSE]#
	p3 <- p[,5:6,drop=FALSE]#
	p4 <- p[,7:8,drop=FALSE]#
	res <- matrix(NA, nrow=nrow(p1), ncol=4)#
	colnames(res) <- c('lon1', 'lat1', 'lon2', 'lat2')#
	keep <- ! antipodal(p1, p2) | antipodal(p3, p4)#
	keep <- keep & ! apply(p1 == p2, 1, sum) == 2#
	if (sum(keep) == 0) { return(res) }#
	toRad <- pi / 180 #
	p1 <- p1[keep, , drop=FALSE] * toRad#
	p2 <- p2[keep, , drop=FALSE] * toRad#
	p3 <- p3[keep, , drop=FALSE] * toRad#
	p4 <- p4[keep, , drop=FALSE] * toRad#
	e1Xe2 <- eXe5(p1[,1], p1[,2], p2[,1], p2[,2])#
	e3Xe4 <- eXe5(p3[,1], p3[,2], p4[,1], p4[,2])#
	ea <- e1Xe2  / eSQRT(e1Xe2)#
	eb <- e3Xe4  / eSQRT(e3Xe4)#
	eaXeb <- eXe3(ea, eb)#
	ll <- einv(eaXeb)#
	ll2 <- cbind(ll[,1] + pi, -ll[,2])#
	pts <- cbind(ll, ll2)#
	pts[,1] <- .normalizeLonRad(pts[,1])#
	pts[,3] <- .normalizeLonRad(pts[,3])#
	res[keep,] <- pts / toRad#
#
	return(res)#
}
ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)
intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)
intersections
nrow(intersections)
nrow(intersections) > 0
intersection_occurs
# Variable to switch to true if intersection is found:#
			intersection_occurs <- FALSE#
			# For each protected link:#
			for(i in 1:nrow(protected_links)) {#
				# Find if there are any intersections:#
				intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
				# If there are intersectiosn update intersection_occurs:#
				if(nrow(intersections) > 0) intersection_occurs <- TRUE#
			}
intersection_occurs
while(intersection_occurs) {}
# Variable to switch to true if intersection is found:#
			intersection_occurs <- FALSE#
			# For each protected link:#
			for(i in 1:nrow(protected_links)) {#
				# Find if there are any intersections:#
				intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
				# If there are intersectiosn update intersection_occurs:#
				if(nrow(intersections) > 0) intersection_occurs <- TRUE#
			}#
			# Set up counter (to be used rto warn user if loop gets stuck):#
			counter <- 1#
			# Whilst there is an intersection between the cut line and a protected link:#
			while(intersection_occurs) {#
				# Get new cut bearing (will be used to describe Great Circle made by cut):#
				cut_bearing <- runif(1, 0, 360)#
				# Pick new second point on Great Circle to use to describe it:#
				cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
				# Overwrite intersection occurs:#
				intersection_occurs <- FALSE#
				# For each protected link:#
				for(i in 1:nrow(protected_links)) {#
					# Find if there are any intersections:#
					intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
					# If there are intersectiosn update intersection_occurs:#
					if(nrow(intersections) > 0) intersection_occurs <- TRUE#
				}#
				# Update counter:#
				counter <- counter + 1#
				# Add stop in case this loop never closes:#
				if(counter == 10000) stop("ERROR: Model failed as cannot find clean separation cut line.")#
			}
intersection_occurs
cutPoint_1
cut_point_1
cut_point_1
cut_bearing
cut_bearing + 90
(cut_bearing + 90) %% 360
0.5 * pi * EarthRad
EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing + 90) %% 360, 0.5 * pi * EarthRad)#
		EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing - 90) %% 360, 0.5 * pi * EarthRad)
# Get first pole to the cut line equator:#
		cut_line_pole_1 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing + 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		# Get second pole to the cut line equator:#
		cut_line_pole_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing - 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]
cut_line_pole_1
cut_line_pole_2
EndPoint
One2ManyGreatCircleDistance()
One2ManyGreatCircleDistance(cut_line_pole_1$long, cut_line_pole_1$lat, longitudes, latitudes, EarthRad = EarthRad)
GC_distances_to_pole_1 <- One2ManyGreatCircleDistance(cut_line_pole_1$long, cut_line_pole_1$lat, longitudes, latitudes, EarthRad = EarthRad)#
		GC_distances_to_pole_2 <- One2ManyGreatCircleDistance(cut_line_pole_2$long, cut_line_pole_2$lat, longitudes, latitudes, EarthRad = EarthRad)
GC_distances_to_pole_1
GC_distances_to_pole_2
GC_distances_to_pole_1 < (0.5 * pi * EarthRad)
which(GC_distances_to_pole_1 < (0.5 * pi * EarthRad))
continent_numbers[which(GC_distances_to_pole_1 < (0.5 * pi * EarthRad))]
first_clump <- continent_numbers[which(GC_distances_to_pole_1 < (0.5 * pi * EarthRad))]#
		second_clump <- continent_numbers[which(GC_distances_to_pole_1 < (0.5 * pi * EarthRad))]
first_clump
second_clump
second_clump <- continent_numbers[which(GC_distances_to_pole_2 < (0.5 * pi * EarthRad))]
second_clump
paste(continent_numbers[which(GC_distances_to_pole_1 < (0.5 * pi * EarthRad))], sep="&")
paste(continent_numbers[which(GC_distances_to_pole_1 < (0.5 * pi * EarthRad))], collapse="&")
first_clump <- paste(continent_numbers[which(GC_distances_to_pole_1 < (0.5 * pi * EarthRad))], collapse="&")#
		second_clump <- paste(continent_numbers[which(GC_distances_to_pole_2 < (0.5 * pi * EarthRad))], collapse="&")
first_clump
second_clump
# Check min separation is not greater than 1/2 circumference of planet:#
	# Make sure continent numbers are stored as character vector for matching:#
	continent_numbers <- as.character(continent_numbers)#
	# Get all intercontinental links in cluster:#
	unprotected_links <- intercontinent_links <- IntercontinentalLinks(min_separation, longitudes, latitudes, EarthRad = EarthRad)#
	# Add row and column names:#
	colnames(unprotected_links) <- colnames(intercontinent_links) <- rownames(unprotected_links) <- rownames(intercontinent_links) <- continent_numbers#
	# If there are protected links:#
	if(nrow(protected_links) > 0) {#
		# For each protected link:#
		for(i in 1:nrow(protected_links)) {#
			# Update unprotected links by setting protected link state to zero:#
			unprotected_links[as.character(protected_links[i, 1]), as.character(protected_links[i, 2])] <- unprotected_links[as.character(protected_links[i, 2]), as.character(protected_links[i, 1])] <- 0#
		}#
	}#
	# If there are unprotected links (and can continue with separation):#
	if(sum(unprotected_links[lower.tri(unprotected_links)]) > 0) {#
		# Pick a random link from the matrix:#
		link_position <- sample(which(intercontinent_links == 1))[1]#
		# Set starting link (from continent to continent):#
		start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))#
		# Whilst randomly chosen link is a protected link:#
		while(unprotected_links[start_link[1], start_link[2]] == 0) {#
			# Pick a new random link from the matrix:#
			link_position <- sample(which(intercontinent_links == 1))[1]#
			# Update start link:#
			start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))#
		}#
		# Define start links by continent numbers:#
		start_link <- colnames(intercontinent_links)[start_link]#
		random_link_start_longitude <- longitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_start_latitude <- latitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_end_longitude <- longitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_end_latitude <- latitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_start_bearing <- BearingBetweenTwoLongLatPoints(random_link_start_longitude, random_link_start_latitude, random_link_end_longitude, random_link_end_latitude)#
		random_distance <- runif(1, 0, min_separation)#
		# Define point at which cut will begin:#
		cut_point_1 <- EndPoint(random_link_start_longitude, random_link_start_latitude, random_link_start_bearing, random_distance)[c("long", "lat")]#
		# Get cut bearing (will be used to describe Great Circle made by cut):#
		cut_bearing <- runif(1, 0, 360)#
		# Pick second point on Great Circle to use to describe it:#
		cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
		# If there are protected links (need to check if cut line intersects them and if so redraw):#
		if(nrow(protected_links) > 0) {#
			# Variable to switch to true if intersection is found:#
			intersection_occurs <- FALSE#
			# For each protected link:#
			for(i in 1:nrow(protected_links)) {#
				# Find if there are any intersections:#
				intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
				# If there are intersectiosn update intersection_occurs:#
				if(nrow(intersections) > 0) intersection_occurs <- TRUE#
			}#
			# Set up counter (to be used rto warn user if loop gets stuck):#
			counter <- 1#
			# Whilst there is an intersection between the cut line and a protected link:#
			while(intersection_occurs) {#
				# Get new cut bearing (will be used to describe Great Circle made by cut):#
				cut_bearing <- runif(1, 0, 360)#
				# Pick new second point on Great Circle to use to describe it:#
				cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
				# Overwrite intersection occurs:#
				intersection_occurs <- FALSE#
				# For each protected link:#
				for(i in 1:nrow(protected_links)) {#
					# Find if there are any intersections:#
					intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
					# If there are intersectiosn update intersection_occurs:#
					if(nrow(intersections) > 0) intersection_occurs <- TRUE#
				}#
				# Update counter:#
				counter <- counter + 1#
				# Add stop in case this loop never closes:#
				if(counter == 10000) stop("ERROR: Model failed as cannot find clean separation cut line.")#
			}#
		}#
		# Get first pole to the cut line equator:#
		cut_line_pole_1 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing + 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		# Get second pole to the cut line equator:#
		cut_line_pole_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing - 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		GC_distances_to_pole_1 <- One2ManyGreatCircleDistance(cut_line_pole_1$long, cut_line_pole_1$lat, longitudes, latitudes, EarthRad = EarthRad)#
#
		GC_distances_to_pole_2 <- One2ManyGreatCircleDistance(cut_line_pole_2$long, cut_line_pole_2$lat, longitudes, latitudes, EarthRad = EarthRad)#
		first_clump <- paste(continent_numbers[which(GC_distances_to_pole_1 < (0.5 * pi * EarthRad))], collapse="&")#
		second_clump <- paste(continent_numbers[which(GC_distances_to_pole_2 < (0.5 * pi * EarthRad))], collapse="&")#
	# Case if no unprotected links:#
	} else {#
# Need to warn but have output of no separation!#
	}#
first_clump#
second_clump
# Check min separation is not greater than 1/2 circumference of planet:#
	# Make sure continent numbers are stored as character vector for matching:#
	continent_numbers <- as.character(continent_numbers)#
	# Get all intercontinental links in cluster:#
	unprotected_links <- intercontinent_links <- IntercontinentalLinks(min_separation, longitudes, latitudes, EarthRad = EarthRad)#
	# Add row and column names:#
	colnames(unprotected_links) <- colnames(intercontinent_links) <- rownames(unprotected_links) <- rownames(intercontinent_links) <- continent_numbers#
	# If there are protected links:#
	if(nrow(protected_links) > 0) {#
		# For each protected link:#
		for(i in 1:nrow(protected_links)) {#
			# Update unprotected links by setting protected link state to zero:#
			unprotected_links[as.character(protected_links[i, 1]), as.character(protected_links[i, 2])] <- unprotected_links[as.character(protected_links[i, 2]), as.character(protected_links[i, 1])] <- 0#
		}#
	}#
	# If there are unprotected links (and can continue with separation):#
	if(sum(unprotected_links[lower.tri(unprotected_links)]) > 0) {#
		# Pick a random link from the matrix:#
		link_position <- sample(which(intercontinent_links == 1))[1]#
		# Set starting link (from continent to continent):#
		start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))#
		# Whilst randomly chosen link is a protected link:#
		while(unprotected_links[start_link[1], start_link[2]] == 0) {#
			# Pick a new random link from the matrix:#
			link_position <- sample(which(intercontinent_links == 1))[1]#
			# Update start link:#
			start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))#
		}#
		# Define start links by continent numbers:#
		start_link <- colnames(intercontinent_links)[start_link]#
		random_link_start_longitude <- longitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_start_latitude <- latitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_end_longitude <- longitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_end_latitude <- latitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_start_bearing <- BearingBetweenTwoLongLatPoints(random_link_start_longitude, random_link_start_latitude, random_link_end_longitude, random_link_end_latitude)#
		random_distance <- runif(1, 0, min_separation)#
		# Define point at which cut will begin:#
		cut_point_1 <- EndPoint(random_link_start_longitude, random_link_start_latitude, random_link_start_bearing, random_distance)[c("long", "lat")]#
		# Get cut bearing (will be used to describe Great Circle made by cut):#
		cut_bearing <- runif(1, 0, 360)#
		# Pick second point on Great Circle to use to describe it:#
		cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
		# If there are protected links (need to check if cut line intersects them and if so redraw):#
		if(nrow(protected_links) > 0) {#
			# Variable to switch to true if intersection is found:#
			intersection_occurs <- FALSE#
			# For each protected link:#
			for(i in 1:nrow(protected_links)) {#
				# Find if there are any intersections:#
				intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
				# If there are intersectiosn update intersection_occurs:#
				if(nrow(intersections) > 0) intersection_occurs <- TRUE#
			}#
			# Set up counter (to be used rto warn user if loop gets stuck):#
			counter <- 1#
			# Whilst there is an intersection between the cut line and a protected link:#
			while(intersection_occurs) {#
				# Get new cut bearing (will be used to describe Great Circle made by cut):#
				cut_bearing <- runif(1, 0, 360)#
				# Pick new second point on Great Circle to use to describe it:#
				cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
				# Overwrite intersection occurs:#
				intersection_occurs <- FALSE#
				# For each protected link:#
				for(i in 1:nrow(protected_links)) {#
					# Find if there are any intersections:#
					intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
					# If there are intersectiosn update intersection_occurs:#
					if(nrow(intersections) > 0) intersection_occurs <- TRUE#
				}#
				# Update counter:#
				counter <- counter + 1#
				# Add stop in case this loop never closes:#
				if(counter == 10000) stop("ERROR: Model failed as cannot find clean separation cut line.")#
			}#
		}#
		# Get first pole to the cut line equator:#
		cut_line_pole_1 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing + 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		# Get second pole to the cut line equator:#
		cut_line_pole_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing - 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		GC_distances_to_pole_1 <- One2ManyGreatCircleDistance(cut_line_pole_1$long, cut_line_pole_1$lat, longitudes, latitudes, EarthRad = EarthRad)#
#
		GC_distances_to_pole_2 <- One2ManyGreatCircleDistance(cut_line_pole_2$long, cut_line_pole_2$lat, longitudes, latitudes, EarthRad = EarthRad)#
		first_clump <- paste(continent_numbers[which(GC_distances_to_pole_1 < (0.5 * pi * EarthRad))], collapse="&")#
		second_clump <- paste(continent_numbers[which(GC_distances_to_pole_2 < (0.5 * pi * EarthRad))], collapse="&")#
	# Case if no unprotected links:#
	} else {#
# Need to warn but have output of no separation!#
	}#
first_clump#
second_clump
# Check min separation is not greater than 1/2 circumference of planet:#
	# Make sure continent numbers are stored as character vector for matching:#
	continent_numbers <- as.character(continent_numbers)#
	# Get all intercontinental links in cluster:#
	unprotected_links <- intercontinent_links <- IntercontinentalLinks(min_separation, longitudes, latitudes, EarthRad = EarthRad)#
	# Add row and column names:#
	colnames(unprotected_links) <- colnames(intercontinent_links) <- rownames(unprotected_links) <- rownames(intercontinent_links) <- continent_numbers#
	# If there are protected links:#
	if(nrow(protected_links) > 0) {#
		# For each protected link:#
		for(i in 1:nrow(protected_links)) {#
			# Update unprotected links by setting protected link state to zero:#
			unprotected_links[as.character(protected_links[i, 1]), as.character(protected_links[i, 2])] <- unprotected_links[as.character(protected_links[i, 2]), as.character(protected_links[i, 1])] <- 0#
		}#
	}#
	# If there are unprotected links (and can continue with separation):#
	if(sum(unprotected_links[lower.tri(unprotected_links)]) > 0) {#
		# Pick a random link from the matrix:#
		link_position <- sample(which(intercontinent_links == 1))[1]#
		# Set starting link (from continent to continent):#
		start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))#
		# Whilst randomly chosen link is a protected link:#
		while(unprotected_links[start_link[1], start_link[2]] == 0) {#
			# Pick a new random link from the matrix:#
			link_position <- sample(which(intercontinent_links == 1))[1]#
			# Update start link:#
			start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))#
		}#
		# Define start links by continent numbers:#
		start_link <- colnames(intercontinent_links)[start_link]#
		random_link_start_longitude <- longitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_start_latitude <- latitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_end_longitude <- longitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_end_latitude <- latitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_start_bearing <- BearingBetweenTwoLongLatPoints(random_link_start_longitude, random_link_start_latitude, random_link_end_longitude, random_link_end_latitude)#
		random_distance <- runif(1, 0, min_separation)#
		# Define point at which cut will begin:#
		cut_point_1 <- EndPoint(random_link_start_longitude, random_link_start_latitude, random_link_start_bearing, random_distance)[c("long", "lat")]#
		# Get cut bearing (will be used to describe Great Circle made by cut):#
		cut_bearing <- runif(1, 0, 360)#
		# Pick second point on Great Circle to use to describe it:#
		cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
		# If there are protected links (need to check if cut line intersects them and if so redraw):#
		if(nrow(protected_links) > 0) {#
			# Variable to switch to true if intersection is found:#
			intersection_occurs <- FALSE#
			# For each protected link:#
			for(i in 1:nrow(protected_links)) {#
				# Find if there are any intersections:#
				intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
				# If there are intersectiosn update intersection_occurs:#
				if(nrow(intersections) > 0) intersection_occurs <- TRUE#
			}#
			# Set up counter (to be used rto warn user if loop gets stuck):#
			counter <- 1#
			# Whilst there is an intersection between the cut line and a protected link:#
			while(intersection_occurs) {#
				# Get new cut bearing (will be used to describe Great Circle made by cut):#
				cut_bearing <- runif(1, 0, 360)#
				# Pick new second point on Great Circle to use to describe it:#
				cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
				# Overwrite intersection occurs:#
				intersection_occurs <- FALSE#
				# For each protected link:#
				for(i in 1:nrow(protected_links)) {#
					# Find if there are any intersections:#
					intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
					# If there are intersectiosn update intersection_occurs:#
					if(nrow(intersections) > 0) intersection_occurs <- TRUE#
				}#
				# Update counter:#
				counter <- counter + 1#
				# Add stop in case this loop never closes:#
				if(counter == 10000) stop("ERROR: Model failed as cannot find clean separation cut line.")#
			}#
		}#
		# Get first pole to the cut line equator:#
		cut_line_pole_1 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing + 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		# Get second pole to the cut line equator:#
		cut_line_pole_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing - 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		GC_distances_to_pole_1 <- One2ManyGreatCircleDistance(cut_line_pole_1$long, cut_line_pole_1$lat, longitudes, latitudes, EarthRad = EarthRad)#
#
		GC_distances_to_pole_2 <- One2ManyGreatCircleDistance(cut_line_pole_2$long, cut_line_pole_2$lat, longitudes, latitudes, EarthRad = EarthRad)#
		first_clump <- paste(continent_numbers[which(GC_distances_to_pole_1 < (0.5 * pi * EarthRad))], collapse="&")#
		second_clump <- paste(continent_numbers[which(GC_distances_to_pole_2 < (0.5 * pi * EarthRad))], collapse="&")#
	# Case if no unprotected links:#
	} else {#
# Need to warn but have output of no separation!#
	}#
first_clump#
second_clump
# Check min separation is not greater than 1/2 circumference of planet:#
	# Make sure continent numbers are stored as character vector for matching:#
	continent_numbers <- as.character(continent_numbers)#
	# Get all intercontinental links in cluster:#
	unprotected_links <- intercontinent_links <- IntercontinentalLinks(min_separation, longitudes, latitudes, EarthRad = EarthRad)#
	# Add row and column names:#
	colnames(unprotected_links) <- colnames(intercontinent_links) <- rownames(unprotected_links) <- rownames(intercontinent_links) <- continent_numbers#
	# If there are protected links:#
	if(nrow(protected_links) > 0) {#
		# For each protected link:#
		for(i in 1:nrow(protected_links)) {#
			# Update unprotected links by setting protected link state to zero:#
			unprotected_links[as.character(protected_links[i, 1]), as.character(protected_links[i, 2])] <- unprotected_links[as.character(protected_links[i, 2]), as.character(protected_links[i, 1])] <- 0#
		}#
	}#
	# If there are unprotected links (and can continue with separation):#
	if(sum(unprotected_links[lower.tri(unprotected_links)]) > 0) {#
		# Pick a random link from the matrix:#
		link_position <- sample(which(intercontinent_links == 1))[1]#
		# Set starting link (from continent to continent):#
		start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))#
		# Whilst randomly chosen link is a protected link:#
		while(unprotected_links[start_link[1], start_link[2]] == 0) {#
			# Pick a new random link from the matrix:#
			link_position <- sample(which(intercontinent_links == 1))[1]#
			# Update start link:#
			start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))#
		}#
		# Define start links by continent numbers:#
		start_link <- colnames(intercontinent_links)[start_link]#
		random_link_start_longitude <- longitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_start_latitude <- latitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_end_longitude <- longitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_end_latitude <- latitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_start_bearing <- BearingBetweenTwoLongLatPoints(random_link_start_longitude, random_link_start_latitude, random_link_end_longitude, random_link_end_latitude)#
		random_distance <- runif(1, 0, min_separation)#
		# Define point at which cut will begin:#
		cut_point_1 <- EndPoint(random_link_start_longitude, random_link_start_latitude, random_link_start_bearing, random_distance)[c("long", "lat")]#
		# Get cut bearing (will be used to describe Great Circle made by cut):#
		cut_bearing <- runif(1, 0, 360)#
		# Pick second point on Great Circle to use to describe it:#
		cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
		# If there are protected links (need to check if cut line intersects them and if so redraw):#
		if(nrow(protected_links) > 0) {#
			# Variable to switch to true if intersection is found:#
			intersection_occurs <- FALSE#
			# For each protected link:#
			for(i in 1:nrow(protected_links)) {#
				# Find if there are any intersections:#
				intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
				# If there are intersectiosn update intersection_occurs:#
				if(nrow(intersections) > 0) intersection_occurs <- TRUE#
			}#
			# Set up counter (to be used rto warn user if loop gets stuck):#
			counter <- 1#
			# Whilst there is an intersection between the cut line and a protected link:#
			while(intersection_occurs) {#
				# Get new cut bearing (will be used to describe Great Circle made by cut):#
				cut_bearing <- runif(1, 0, 360)#
				# Pick new second point on Great Circle to use to describe it:#
				cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
				# Overwrite intersection occurs:#
				intersection_occurs <- FALSE#
				# For each protected link:#
				for(i in 1:nrow(protected_links)) {#
					# Find if there are any intersections:#
					intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
					# If there are intersectiosn update intersection_occurs:#
					if(nrow(intersections) > 0) intersection_occurs <- TRUE#
				}#
				# Update counter:#
				counter <- counter + 1#
				# Add stop in case this loop never closes:#
				if(counter == 10000) stop("ERROR: Model failed as cannot find clean separation cut line.")#
			}#
		}#
		# Get first pole to the cut line equator:#
		cut_line_pole_1 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing + 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		# Get second pole to the cut line equator:#
		cut_line_pole_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing - 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		GC_distances_to_pole_1 <- One2ManyGreatCircleDistance(cut_line_pole_1$long, cut_line_pole_1$lat, longitudes, latitudes, EarthRad = EarthRad)#
#
		GC_distances_to_pole_2 <- One2ManyGreatCircleDistance(cut_line_pole_2$long, cut_line_pole_2$lat, longitudes, latitudes, EarthRad = EarthRad)#
		first_clump <- paste(continent_numbers[which(GC_distances_to_pole_1 < (0.5 * pi * EarthRad))], collapse="&")#
		second_clump <- paste(continent_numbers[which(GC_distances_to_pole_2 < (0.5 * pi * EarthRad))], collapse="&")#
	# Case if no unprotected links:#
	} else {#
# Need to warn but have output of no separation!#
	}#
first_clump#
second_clump
# Check min separation is not greater than 1/2 circumference of planet:#
	# Make sure continent numbers are stored as character vector for matching:#
	continent_numbers <- as.character(continent_numbers)#
	# Get all intercontinental links in cluster:#
	unprotected_links <- intercontinent_links <- IntercontinentalLinks(min_separation, longitudes, latitudes, EarthRad = EarthRad)#
	# Add row and column names:#
	colnames(unprotected_links) <- colnames(intercontinent_links) <- rownames(unprotected_links) <- rownames(intercontinent_links) <- continent_numbers#
	# If there are protected links:#
	if(nrow(protected_links) > 0) {#
		# For each protected link:#
		for(i in 1:nrow(protected_links)) {#
			# Update unprotected links by setting protected link state to zero:#
			unprotected_links[as.character(protected_links[i, 1]), as.character(protected_links[i, 2])] <- unprotected_links[as.character(protected_links[i, 2]), as.character(protected_links[i, 1])] <- 0#
		}#
	}#
	# If there are unprotected links (and can continue with separation):#
	if(sum(unprotected_links[lower.tri(unprotected_links)]) > 0) {#
		# Pick a random link from the matrix:#
		link_position <- sample(which(intercontinent_links == 1))[1]#
		# Set starting link (from continent to continent):#
		start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))#
		# Whilst randomly chosen link is a protected link:#
		while(unprotected_links[start_link[1], start_link[2]] == 0) {#
			# Pick a new random link from the matrix:#
			link_position <- sample(which(intercontinent_links == 1))[1]#
			# Update start link:#
			start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))#
		}#
		# Define start links by continent numbers:#
		start_link <- colnames(intercontinent_links)[start_link]#
		random_link_start_longitude <- longitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_start_latitude <- latitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_end_longitude <- longitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_end_latitude <- latitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_start_bearing <- BearingBetweenTwoLongLatPoints(random_link_start_longitude, random_link_start_latitude, random_link_end_longitude, random_link_end_latitude)#
		random_distance <- runif(1, 0, min_separation)#
		# Define point at which cut will begin:#
		cut_point_1 <- EndPoint(random_link_start_longitude, random_link_start_latitude, random_link_start_bearing, random_distance)[c("long", "lat")]#
		# Get cut bearing (will be used to describe Great Circle made by cut):#
		cut_bearing <- runif(1, 0, 360)#
		# Pick second point on Great Circle to use to describe it:#
		cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
		# If there are protected links (need to check if cut line intersects them and if so redraw):#
		if(nrow(protected_links) > 0) {#
			# Variable to switch to true if intersection is found:#
			intersection_occurs <- FALSE#
			# For each protected link:#
			for(i in 1:nrow(protected_links)) {#
				# Find if there are any intersections:#
				intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
				# If there are intersectiosn update intersection_occurs:#
				if(nrow(intersections) > 0) intersection_occurs <- TRUE#
			}#
			# Set up counter (to be used rto warn user if loop gets stuck):#
			counter <- 1#
			# Whilst there is an intersection between the cut line and a protected link:#
			while(intersection_occurs) {#
				# Get new cut bearing (will be used to describe Great Circle made by cut):#
				cut_bearing <- runif(1, 0, 360)#
				# Pick new second point on Great Circle to use to describe it:#
				cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
				# Overwrite intersection occurs:#
				intersection_occurs <- FALSE#
				# For each protected link:#
				for(i in 1:nrow(protected_links)) {#
					# Find if there are any intersections:#
					intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
					# If there are intersectiosn update intersection_occurs:#
					if(nrow(intersections) > 0) intersection_occurs <- TRUE#
				}#
				# Update counter:#
				counter <- counter + 1#
				# Add stop in case this loop never closes:#
				if(counter == 10000) stop("ERROR: Model failed as cannot find clean separation cut line.")#
			}#
		}#
		# Get first pole to the cut line equator:#
		cut_line_pole_1 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing + 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		# Get second pole to the cut line equator:#
		cut_line_pole_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing - 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		GC_distances_to_pole_1 <- One2ManyGreatCircleDistance(cut_line_pole_1$long, cut_line_pole_1$lat, longitudes, latitudes, EarthRad = EarthRad)#
#
		GC_distances_to_pole_2 <- One2ManyGreatCircleDistance(cut_line_pole_2$long, cut_line_pole_2$lat, longitudes, latitudes, EarthRad = EarthRad)#
		first_clump <- paste(continent_numbers[which(GC_distances_to_pole_1 < (0.5 * pi * EarthRad))], collapse="&")#
		second_clump <- paste(continent_numbers[which(GC_distances_to_pole_2 < (0.5 * pi * EarthRad))], collapse="&")#
	# Case if no unprotected links:#
	} else {#
# Need to warn but have output of no separation!#
	}#
first_clump#
second_clump
# Check min separation is not greater than 1/2 circumference of planet:#
	# Make sure continent numbers are stored as character vector for matching:#
	continent_numbers <- as.character(continent_numbers)#
	# Get all intercontinental links in cluster:#
	unprotected_links <- intercontinent_links <- IntercontinentalLinks(min_separation, longitudes, latitudes, EarthRad = EarthRad)#
	# Add row and column names:#
	colnames(unprotected_links) <- colnames(intercontinent_links) <- rownames(unprotected_links) <- rownames(intercontinent_links) <- continent_numbers#
	# If there are protected links:#
	if(nrow(protected_links) > 0) {#
		# For each protected link:#
		for(i in 1:nrow(protected_links)) {#
			# Update unprotected links by setting protected link state to zero:#
			unprotected_links[as.character(protected_links[i, 1]), as.character(protected_links[i, 2])] <- unprotected_links[as.character(protected_links[i, 2]), as.character(protected_links[i, 1])] <- 0#
		}#
	}#
	# If there are unprotected links (and can continue with separation):#
	if(sum(unprotected_links[lower.tri(unprotected_links)]) > 0) {#
		# Pick a random link from the matrix:#
		link_position <- sample(which(intercontinent_links == 1))[1]#
		# Set starting link (from continent to continent):#
		start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))#
		# Whilst randomly chosen link is a protected link:#
		while(unprotected_links[start_link[1], start_link[2]] == 0) {#
			# Pick a new random link from the matrix:#
			link_position <- sample(which(intercontinent_links == 1))[1]#
			# Update start link:#
			start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))#
		}#
		# Define start links by continent numbers:#
		start_link <- colnames(intercontinent_links)[start_link]#
		random_link_start_longitude <- longitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_start_latitude <- latitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_end_longitude <- longitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_end_latitude <- latitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_start_bearing <- BearingBetweenTwoLongLatPoints(random_link_start_longitude, random_link_start_latitude, random_link_end_longitude, random_link_end_latitude)#
		random_distance <- runif(1, 0, min_separation)#
		# Define point at which cut will begin:#
		cut_point_1 <- EndPoint(random_link_start_longitude, random_link_start_latitude, random_link_start_bearing, random_distance)[c("long", "lat")]#
		# Get cut bearing (will be used to describe Great Circle made by cut):#
		cut_bearing <- runif(1, 0, 360)#
		# Pick second point on Great Circle to use to describe it:#
		cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
		# If there are protected links (need to check if cut line intersects them and if so redraw):#
		if(nrow(protected_links) > 0) {#
			# Variable to switch to true if intersection is found:#
			intersection_occurs <- FALSE#
			# For each protected link:#
			for(i in 1:nrow(protected_links)) {#
				# Find if there are any intersections:#
				intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
				# If there are intersectiosn update intersection_occurs:#
				if(nrow(intersections) > 0) intersection_occurs <- TRUE#
			}#
			# Set up counter (to be used rto warn user if loop gets stuck):#
			counter <- 1#
			# Whilst there is an intersection between the cut line and a protected link:#
			while(intersection_occurs) {#
				# Get new cut bearing (will be used to describe Great Circle made by cut):#
				cut_bearing <- runif(1, 0, 360)#
				# Pick new second point on Great Circle to use to describe it:#
				cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
				# Overwrite intersection occurs:#
				intersection_occurs <- FALSE#
				# For each protected link:#
				for(i in 1:nrow(protected_links)) {#
					# Find if there are any intersections:#
					intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
					# If there are intersectiosn update intersection_occurs:#
					if(nrow(intersections) > 0) intersection_occurs <- TRUE#
				}#
				# Update counter:#
				counter <- counter + 1#
				# Add stop in case this loop never closes:#
				if(counter == 10000) stop("ERROR: Model failed as cannot find clean separation cut line.")#
			}#
		}#
		# Get first pole to the cut line equator:#
		cut_line_pole_1 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing + 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		# Get second pole to the cut line equator:#
		cut_line_pole_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing - 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		GC_distances_to_pole_1 <- One2ManyGreatCircleDistance(cut_line_pole_1$long, cut_line_pole_1$lat, longitudes, latitudes, EarthRad = EarthRad)#
#
		GC_distances_to_pole_2 <- One2ManyGreatCircleDistance(cut_line_pole_2$long, cut_line_pole_2$lat, longitudes, latitudes, EarthRad = EarthRad)#
		first_clump <- paste(continent_numbers[which(GC_distances_to_pole_1 < (0.5 * pi * EarthRad))], collapse="&")#
		second_clump <- paste(continent_numbers[which(GC_distances_to_pole_2 < (0.5 * pi * EarthRad))], collapse="&")#
	# Case if no unprotected links:#
	} else {#
# Need to warn but have output of no separation!#
	}#
first_clump#
second_clump
# Check min separation is not greater than 1/2 circumference of planet:#
	# Make sure continent numbers are stored as character vector for matching:#
	continent_numbers <- as.character(continent_numbers)#
	# Get all intercontinental links in cluster:#
	unprotected_links <- intercontinent_links <- IntercontinentalLinks(min_separation, longitudes, latitudes, EarthRad = EarthRad)#
	# Add row and column names:#
	colnames(unprotected_links) <- colnames(intercontinent_links) <- rownames(unprotected_links) <- rownames(intercontinent_links) <- continent_numbers#
	# If there are protected links:#
	if(nrow(protected_links) > 0) {#
		# For each protected link:#
		for(i in 1:nrow(protected_links)) {#
			# Update unprotected links by setting protected link state to zero:#
			unprotected_links[as.character(protected_links[i, 1]), as.character(protected_links[i, 2])] <- unprotected_links[as.character(protected_links[i, 2]), as.character(protected_links[i, 1])] <- 0#
		}#
	}#
	# If there are unprotected links (and can continue with separation):#
	if(sum(unprotected_links[lower.tri(unprotected_links)]) > 0) {#
		# Pick a random link from the matrix:#
		link_position <- sample(which(intercontinent_links == 1))[1]#
		# Set starting link (from continent to continent):#
		start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))#
		# Whilst randomly chosen link is a protected link:#
		while(unprotected_links[start_link[1], start_link[2]] == 0) {#
			# Pick a new random link from the matrix:#
			link_position <- sample(which(intercontinent_links == 1))[1]#
			# Update start link:#
			start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))#
		}#
		# Define start links by continent numbers:#
		start_link <- colnames(intercontinent_links)[start_link]#
		random_link_start_longitude <- longitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_start_latitude <- latitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_end_longitude <- longitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_end_latitude <- latitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_start_bearing <- BearingBetweenTwoLongLatPoints(random_link_start_longitude, random_link_start_latitude, random_link_end_longitude, random_link_end_latitude)#
		random_distance <- runif(1, 0, min_separation)#
		# Define point at which cut will begin:#
		cut_point_1 <- EndPoint(random_link_start_longitude, random_link_start_latitude, random_link_start_bearing, random_distance)[c("long", "lat")]#
		# Get cut bearing (will be used to describe Great Circle made by cut):#
		cut_bearing <- runif(1, 0, 360)#
		# Pick second point on Great Circle to use to describe it:#
		cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
		# If there are protected links (need to check if cut line intersects them and if so redraw):#
		if(nrow(protected_links) > 0) {#
			# Variable to switch to true if intersection is found:#
			intersection_occurs <- FALSE#
			# For each protected link:#
			for(i in 1:nrow(protected_links)) {#
				# Find if there are any intersections:#
				intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
				# If there are intersectiosn update intersection_occurs:#
				if(nrow(intersections) > 0) intersection_occurs <- TRUE#
			}#
			# Set up counter (to be used rto warn user if loop gets stuck):#
			counter <- 1#
			# Whilst there is an intersection between the cut line and a protected link:#
			while(intersection_occurs) {#
				# Get new cut bearing (will be used to describe Great Circle made by cut):#
				cut_bearing <- runif(1, 0, 360)#
				# Pick new second point on Great Circle to use to describe it:#
				cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
				# Overwrite intersection occurs:#
				intersection_occurs <- FALSE#
				# For each protected link:#
				for(i in 1:nrow(protected_links)) {#
					# Find if there are any intersections:#
					intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
					# If there are intersectiosn update intersection_occurs:#
					if(nrow(intersections) > 0) intersection_occurs <- TRUE#
				}#
				# Update counter:#
				counter <- counter + 1#
				# Add stop in case this loop never closes:#
				if(counter == 10000) stop("ERROR: Model failed as cannot find clean separation cut line.")#
			}#
		}#
		# Get first pole to the cut line equator:#
		cut_line_pole_1 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing + 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		# Get second pole to the cut line equator:#
		cut_line_pole_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing - 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		GC_distances_to_pole_1 <- One2ManyGreatCircleDistance(cut_line_pole_1$long, cut_line_pole_1$lat, longitudes, latitudes, EarthRad = EarthRad)#
#
		GC_distances_to_pole_2 <- One2ManyGreatCircleDistance(cut_line_pole_2$long, cut_line_pole_2$lat, longitudes, latitudes, EarthRad = EarthRad)#
		first_clump <- paste(continent_numbers[which(GC_distances_to_pole_1 < (0.5 * pi * EarthRad))], collapse="&")#
		second_clump <- paste(continent_numbers[which(GC_distances_to_pole_2 < (0.5 * pi * EarthRad))], collapse="&")#
	# Case if no unprotected links:#
	} else {#
# Need to warn but have output of no separation!#
	}#
first_clump#
second_clump
# Check min separation is not greater than 1/2 circumference of planet:#
	# Make sure continent numbers are stored as character vector for matching:#
	continent_numbers <- as.character(continent_numbers)#
	# Get all intercontinental links in cluster:#
	unprotected_links <- intercontinent_links <- IntercontinentalLinks(min_separation, longitudes, latitudes, EarthRad = EarthRad)#
	# Add row and column names:#
	colnames(unprotected_links) <- colnames(intercontinent_links) <- rownames(unprotected_links) <- rownames(intercontinent_links) <- continent_numbers#
	# If there are protected links:#
	if(nrow(protected_links) > 0) {#
		# For each protected link:#
		for(i in 1:nrow(protected_links)) {#
			# Update unprotected links by setting protected link state to zero:#
			unprotected_links[as.character(protected_links[i, 1]), as.character(protected_links[i, 2])] <- unprotected_links[as.character(protected_links[i, 2]), as.character(protected_links[i, 1])] <- 0#
		}#
	}#
	# If there are unprotected links (and can continue with separation):#
	if(sum(unprotected_links[lower.tri(unprotected_links)]) > 0) {#
		# Pick a random link from the matrix:#
		link_position <- sample(which(intercontinent_links == 1))[1]#
		# Set starting link (from continent to continent):#
		start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))#
		# Whilst randomly chosen link is a protected link:#
		while(unprotected_links[start_link[1], start_link[2]] == 0) {#
			# Pick a new random link from the matrix:#
			link_position <- sample(which(intercontinent_links == 1))[1]#
			# Update start link:#
			start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))#
		}#
		# Define start links by continent numbers:#
		start_link <- colnames(intercontinent_links)[start_link]#
		random_link_start_longitude <- longitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_start_latitude <- latitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_end_longitude <- longitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_end_latitude <- latitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_start_bearing <- BearingBetweenTwoLongLatPoints(random_link_start_longitude, random_link_start_latitude, random_link_end_longitude, random_link_end_latitude)#
		random_distance <- runif(1, 0, min_separation)#
		# Define point at which cut will begin:#
		cut_point_1 <- EndPoint(random_link_start_longitude, random_link_start_latitude, random_link_start_bearing, random_distance)[c("long", "lat")]#
		# Get cut bearing (will be used to describe Great Circle made by cut):#
		cut_bearing <- runif(1, 0, 360)#
		# Pick second point on Great Circle to use to describe it:#
		cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
		# If there are protected links (need to check if cut line intersects them and if so redraw):#
		if(nrow(protected_links) > 0) {#
			# Variable to switch to true if intersection is found:#
			intersection_occurs <- FALSE#
			# For each protected link:#
			for(i in 1:nrow(protected_links)) {#
				# Find if there are any intersections:#
				intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
				# If there are intersectiosn update intersection_occurs:#
				if(nrow(intersections) > 0) intersection_occurs <- TRUE#
			}#
			# Set up counter (to be used rto warn user if loop gets stuck):#
			counter <- 1#
			# Whilst there is an intersection between the cut line and a protected link:#
			while(intersection_occurs) {#
				# Get new cut bearing (will be used to describe Great Circle made by cut):#
				cut_bearing <- runif(1, 0, 360)#
				# Pick new second point on Great Circle to use to describe it:#
				cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
				# Overwrite intersection occurs:#
				intersection_occurs <- FALSE#
				# For each protected link:#
				for(i in 1:nrow(protected_links)) {#
					# Find if there are any intersections:#
					intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
					# If there are intersectiosn update intersection_occurs:#
					if(nrow(intersections) > 0) intersection_occurs <- TRUE#
				}#
				# Update counter:#
				counter <- counter + 1#
				# Add stop in case this loop never closes:#
				if(counter == 10000) stop("ERROR: Model failed as cannot find clean separation cut line.")#
			}#
		}#
		# Get first pole to the cut line equator:#
		cut_line_pole_1 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing + 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		# Get second pole to the cut line equator:#
		cut_line_pole_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing - 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		GC_distances_to_pole_1 <- One2ManyGreatCircleDistance(cut_line_pole_1$long, cut_line_pole_1$lat, longitudes, latitudes, EarthRad = EarthRad)#
#
		GC_distances_to_pole_2 <- One2ManyGreatCircleDistance(cut_line_pole_2$long, cut_line_pole_2$lat, longitudes, latitudes, EarthRad = EarthRad)#
		first_clump <- paste(continent_numbers[which(GC_distances_to_pole_1 < (0.5 * pi * EarthRad))], collapse="&")#
		second_clump <- paste(continent_numbers[which(GC_distances_to_pole_2 < (0.5 * pi * EarthRad))], collapse="&")#
	# Case if no unprotected links:#
	} else {#
# Need to warn but have output of no separation!#
	}#
first_clump#
second_clump
# Check min separation is not greater than 1/2 circumference of planet:#
	# Make sure continent numbers are stored as character vector for matching:#
	continent_numbers <- as.character(continent_numbers)#
	# Get all intercontinental links in cluster:#
	unprotected_links <- intercontinent_links <- IntercontinentalLinks(min_separation, longitudes, latitudes, EarthRad = EarthRad)#
	# Add row and column names:#
	colnames(unprotected_links) <- colnames(intercontinent_links) <- rownames(unprotected_links) <- rownames(intercontinent_links) <- continent_numbers#
	# If there are protected links:#
	if(nrow(protected_links) > 0) {#
		# For each protected link:#
		for(i in 1:nrow(protected_links)) {#
			# Update unprotected links by setting protected link state to zero:#
			unprotected_links[as.character(protected_links[i, 1]), as.character(protected_links[i, 2])] <- unprotected_links[as.character(protected_links[i, 2]), as.character(protected_links[i, 1])] <- 0#
		}#
	}#
	# If there are unprotected links (and can continue with separation):#
	if(sum(unprotected_links[lower.tri(unprotected_links)]) > 0) {#
		# Pick a random link from the matrix:#
		link_position <- sample(which(intercontinent_links == 1))[1]#
		# Set starting link (from continent to continent):#
		start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))#
		# Whilst randomly chosen link is a protected link:#
		while(unprotected_links[start_link[1], start_link[2]] == 0) {#
			# Pick a new random link from the matrix:#
			link_position <- sample(which(intercontinent_links == 1))[1]#
			# Update start link:#
			start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))#
		}#
		# Define start links by continent numbers:#
		start_link <- colnames(intercontinent_links)[start_link]#
		random_link_start_longitude <- longitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_start_latitude <- latitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_end_longitude <- longitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_end_latitude <- latitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_start_bearing <- BearingBetweenTwoLongLatPoints(random_link_start_longitude, random_link_start_latitude, random_link_end_longitude, random_link_end_latitude)#
		random_distance <- runif(1, 0, min_separation)#
		# Define point at which cut will begin:#
		cut_point_1 <- EndPoint(random_link_start_longitude, random_link_start_latitude, random_link_start_bearing, random_distance)[c("long", "lat")]#
		# Get cut bearing (will be used to describe Great Circle made by cut):#
		cut_bearing <- runif(1, 0, 360)#
		# Pick second point on Great Circle to use to describe it:#
		cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
		# If there are protected links (need to check if cut line intersects them and if so redraw):#
		if(nrow(protected_links) > 0) {#
			# Variable to switch to true if intersection is found:#
			intersection_occurs <- FALSE#
			# For each protected link:#
			for(i in 1:nrow(protected_links)) {#
				# Find if there are any intersections:#
				intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
				# If there are intersectiosn update intersection_occurs:#
				if(nrow(intersections) > 0) intersection_occurs <- TRUE#
			}#
			# Set up counter (to be used rto warn user if loop gets stuck):#
			counter <- 1#
			# Whilst there is an intersection between the cut line and a protected link:#
			while(intersection_occurs) {#
				# Get new cut bearing (will be used to describe Great Circle made by cut):#
				cut_bearing <- runif(1, 0, 360)#
				# Pick new second point on Great Circle to use to describe it:#
				cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
				# Overwrite intersection occurs:#
				intersection_occurs <- FALSE#
				# For each protected link:#
				for(i in 1:nrow(protected_links)) {#
					# Find if there are any intersections:#
					intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
					# If there are intersectiosn update intersection_occurs:#
					if(nrow(intersections) > 0) intersection_occurs <- TRUE#
				}#
				# Update counter:#
				counter <- counter + 1#
				# Add stop in case this loop never closes:#
				if(counter == 10000) stop("ERROR: Model failed as cannot find clean separation cut line.")#
			}#
		}#
		# Get first pole to the cut line equator:#
		cut_line_pole_1 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing + 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		# Get second pole to the cut line equator:#
		cut_line_pole_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing - 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		GC_distances_to_pole_1 <- One2ManyGreatCircleDistance(cut_line_pole_1$long, cut_line_pole_1$lat, longitudes, latitudes, EarthRad = EarthRad)#
#
		GC_distances_to_pole_2 <- One2ManyGreatCircleDistance(cut_line_pole_2$long, cut_line_pole_2$lat, longitudes, latitudes, EarthRad = EarthRad)#
		first_clump <- paste(continent_numbers[which(GC_distances_to_pole_1 < (0.5 * pi * EarthRad))], collapse="&")#
		second_clump <- paste(continent_numbers[which(GC_distances_to_pole_2 < (0.5 * pi * EarthRad))], collapse="&")#
	# Case if no unprotected links:#
	} else {#
# Need to warn but have output of no separation!#
	}#
first_clump#
second_clump
# Check min separation is not greater than 1/2 circumference of planet:#
	# Make sure continent numbers are stored as character vector for matching:#
	continent_numbers <- as.character(continent_numbers)#
	# Get all intercontinental links in cluster:#
	unprotected_links <- intercontinent_links <- IntercontinentalLinks(min_separation, longitudes, latitudes, EarthRad = EarthRad)#
	# Add row and column names:#
	colnames(unprotected_links) <- colnames(intercontinent_links) <- rownames(unprotected_links) <- rownames(intercontinent_links) <- continent_numbers#
	# If there are protected links:#
	if(nrow(protected_links) > 0) {#
		# For each protected link:#
		for(i in 1:nrow(protected_links)) {#
			# Update unprotected links by setting protected link state to zero:#
			unprotected_links[as.character(protected_links[i, 1]), as.character(protected_links[i, 2])] <- unprotected_links[as.character(protected_links[i, 2]), as.character(protected_links[i, 1])] <- 0#
		}#
	}#
	# If there are unprotected links (and can continue with separation):#
	if(sum(unprotected_links[lower.tri(unprotected_links)]) > 0) {#
		# Pick a random link from the matrix:#
		link_position <- sample(which(intercontinent_links == 1))[1]#
		# Set starting link (from continent to continent):#
		start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))#
		# Whilst randomly chosen link is a protected link:#
		while(unprotected_links[start_link[1], start_link[2]] == 0) {#
			# Pick a new random link from the matrix:#
			link_position <- sample(which(intercontinent_links == 1))[1]#
			# Update start link:#
			start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))#
		}#
		# Define start links by continent numbers:#
		start_link <- colnames(intercontinent_links)[start_link]#
		random_link_start_longitude <- longitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_start_latitude <- latitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_end_longitude <- longitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_end_latitude <- latitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_start_bearing <- BearingBetweenTwoLongLatPoints(random_link_start_longitude, random_link_start_latitude, random_link_end_longitude, random_link_end_latitude)#
		random_distance <- runif(1, 0, min_separation)#
		# Define point at which cut will begin:#
		cut_point_1 <- EndPoint(random_link_start_longitude, random_link_start_latitude, random_link_start_bearing, random_distance)[c("long", "lat")]#
		# Get cut bearing (will be used to describe Great Circle made by cut):#
		cut_bearing <- runif(1, 0, 360)#
		# Pick second point on Great Circle to use to describe it:#
		cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
		# If there are protected links (need to check if cut line intersects them and if so redraw):#
		if(nrow(protected_links) > 0) {#
			# Variable to switch to true if intersection is found:#
			intersection_occurs <- FALSE#
			# For each protected link:#
			for(i in 1:nrow(protected_links)) {#
				# Find if there are any intersections:#
				intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
				# If there are intersectiosn update intersection_occurs:#
				if(nrow(intersections) > 0) intersection_occurs <- TRUE#
			}#
			# Set up counter (to be used rto warn user if loop gets stuck):#
			counter <- 1#
			# Whilst there is an intersection between the cut line and a protected link:#
			while(intersection_occurs) {#
				# Get new cut bearing (will be used to describe Great Circle made by cut):#
				cut_bearing <- runif(1, 0, 360)#
				# Pick new second point on Great Circle to use to describe it:#
				cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
				# Overwrite intersection occurs:#
				intersection_occurs <- FALSE#
				# For each protected link:#
				for(i in 1:nrow(protected_links)) {#
					# Find if there are any intersections:#
					intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
					# If there are intersectiosn update intersection_occurs:#
					if(nrow(intersections) > 0) intersection_occurs <- TRUE#
				}#
				# Update counter:#
				counter <- counter + 1#
				# Add stop in case this loop never closes:#
				if(counter == 10000) stop("ERROR: Model failed as cannot find clean separation cut line.")#
			}#
		}#
		# Get first pole to the cut line equator:#
		cut_line_pole_1 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing + 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		# Get second pole to the cut line equator:#
		cut_line_pole_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing - 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		GC_distances_to_pole_1 <- One2ManyGreatCircleDistance(cut_line_pole_1$long, cut_line_pole_1$lat, longitudes, latitudes, EarthRad = EarthRad)#
#
		GC_distances_to_pole_2 <- One2ManyGreatCircleDistance(cut_line_pole_2$long, cut_line_pole_2$lat, longitudes, latitudes, EarthRad = EarthRad)#
		first_clump <- paste(continent_numbers[which(GC_distances_to_pole_1 < (0.5 * pi * EarthRad))], collapse="&")#
		second_clump <- paste(continent_numbers[which(GC_distances_to_pole_2 < (0.5 * pi * EarthRad))], collapse="&")#
	# Case if no unprotected links:#
	} else {#
# Need to warn but have output of no separation!#
	}#
first_clump#
second_clump
# Check min separation is not greater than 1/2 circumference of planet:#
	# Make sure continent numbers are stored as character vector for matching:#
	continent_numbers <- as.character(continent_numbers)#
	# Get all intercontinental links in cluster:#
	unprotected_links <- intercontinent_links <- IntercontinentalLinks(min_separation, longitudes, latitudes, EarthRad = EarthRad)#
	# Add row and column names:#
	colnames(unprotected_links) <- colnames(intercontinent_links) <- rownames(unprotected_links) <- rownames(intercontinent_links) <- continent_numbers#
	# If there are protected links:#
	if(nrow(protected_links) > 0) {#
		# For each protected link:#
		for(i in 1:nrow(protected_links)) {#
			# Update unprotected links by setting protected link state to zero:#
			unprotected_links[as.character(protected_links[i, 1]), as.character(protected_links[i, 2])] <- unprotected_links[as.character(protected_links[i, 2]), as.character(protected_links[i, 1])] <- 0#
		}#
	}#
	# If there are unprotected links (and can continue with separation):#
	if(sum(unprotected_links[lower.tri(unprotected_links)]) > 0) {#
		# Pick a random link from the matrix:#
		link_position <- sample(which(intercontinent_links == 1))[1]#
		# Set starting link (from continent to continent):#
		start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))#
		# Whilst randomly chosen link is a protected link:#
		while(unprotected_links[start_link[1], start_link[2]] == 0) {#
			# Pick a new random link from the matrix:#
			link_position <- sample(which(intercontinent_links == 1))[1]#
			# Update start link:#
			start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))#
		}#
		# Define start links by continent numbers:#
		start_link <- colnames(intercontinent_links)[start_link]#
		random_link_start_longitude <- longitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_start_latitude <- latitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_end_longitude <- longitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_end_latitude <- latitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_start_bearing <- BearingBetweenTwoLongLatPoints(random_link_start_longitude, random_link_start_latitude, random_link_end_longitude, random_link_end_latitude)#
		random_distance <- runif(1, 0, min_separation)#
		# Define point at which cut will begin:#
		cut_point_1 <- EndPoint(random_link_start_longitude, random_link_start_latitude, random_link_start_bearing, random_distance)[c("long", "lat")]#
		# Get cut bearing (will be used to describe Great Circle made by cut):#
		cut_bearing <- runif(1, 0, 360)#
		# Pick second point on Great Circle to use to describe it:#
		cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
		# If there are protected links (need to check if cut line intersects them and if so redraw):#
		if(nrow(protected_links) > 0) {#
			# Variable to switch to true if intersection is found:#
			intersection_occurs <- FALSE#
			# For each protected link:#
			for(i in 1:nrow(protected_links)) {#
				# Find if there are any intersections:#
				intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
				# If there are intersectiosn update intersection_occurs:#
				if(nrow(intersections) > 0) intersection_occurs <- TRUE#
			}#
			# Set up counter (to be used rto warn user if loop gets stuck):#
			counter <- 1#
			# Whilst there is an intersection between the cut line and a protected link:#
			while(intersection_occurs) {#
				# Get new cut bearing (will be used to describe Great Circle made by cut):#
				cut_bearing <- runif(1, 0, 360)#
				# Pick new second point on Great Circle to use to describe it:#
				cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
				# Overwrite intersection occurs:#
				intersection_occurs <- FALSE#
				# For each protected link:#
				for(i in 1:nrow(protected_links)) {#
					# Find if there are any intersections:#
					intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
					# If there are intersectiosn update intersection_occurs:#
					if(nrow(intersections) > 0) intersection_occurs <- TRUE#
				}#
				# Update counter:#
				counter <- counter + 1#
				# Add stop in case this loop never closes:#
				if(counter == 10000) stop("ERROR: Model failed as cannot find clean separation cut line.")#
			}#
		}#
		# Get first pole to the cut line equator:#
		cut_line_pole_1 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing + 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		# Get second pole to the cut line equator:#
		cut_line_pole_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing - 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		GC_distances_to_pole_1 <- One2ManyGreatCircleDistance(cut_line_pole_1$long, cut_line_pole_1$lat, longitudes, latitudes, EarthRad = EarthRad)#
#
		GC_distances_to_pole_2 <- One2ManyGreatCircleDistance(cut_line_pole_2$long, cut_line_pole_2$lat, longitudes, latitudes, EarthRad = EarthRad)#
		first_clump <- paste(continent_numbers[which(GC_distances_to_pole_1 < (0.5 * pi * EarthRad))], collapse="&")#
		second_clump <- paste(continent_numbers[which(GC_distances_to_pole_2 < (0.5 * pi * EarthRad))], collapse="&")#
	# Case if no unprotected links:#
	} else {#
# Need to warn but have output of no separation!#
	}#
first_clump#
second_clump
# Check min separation is not greater than 1/2 circumference of planet:#
	# Make sure continent numbers are stored as character vector for matching:#
	continent_numbers <- as.character(continent_numbers)#
	# Get all intercontinental links in cluster:#
	unprotected_links <- intercontinent_links <- IntercontinentalLinks(min_separation, longitudes, latitudes, EarthRad = EarthRad)#
	# Add row and column names:#
	colnames(unprotected_links) <- colnames(intercontinent_links) <- rownames(unprotected_links) <- rownames(intercontinent_links) <- continent_numbers#
	# If there are protected links:#
	if(nrow(protected_links) > 0) {#
		# For each protected link:#
		for(i in 1:nrow(protected_links)) {#
			# Update unprotected links by setting protected link state to zero:#
			unprotected_links[as.character(protected_links[i, 1]), as.character(protected_links[i, 2])] <- unprotected_links[as.character(protected_links[i, 2]), as.character(protected_links[i, 1])] <- 0#
		}#
	}#
	# If there are unprotected links (and can continue with separation):#
	if(sum(unprotected_links[lower.tri(unprotected_links)]) > 0) {#
		# Pick a random link from the matrix:#
		link_position <- sample(which(intercontinent_links == 1))[1]#
		# Set starting link (from continent to continent):#
		start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))#
		# Whilst randomly chosen link is a protected link:#
		while(unprotected_links[start_link[1], start_link[2]] == 0) {#
			# Pick a new random link from the matrix:#
			link_position <- sample(which(intercontinent_links == 1))[1]#
			# Update start link:#
			start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))#
		}#
		# Define start links by continent numbers:#
		start_link <- colnames(intercontinent_links)[start_link]#
		random_link_start_longitude <- longitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_start_latitude <- latitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_end_longitude <- longitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_end_latitude <- latitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_start_bearing <- BearingBetweenTwoLongLatPoints(random_link_start_longitude, random_link_start_latitude, random_link_end_longitude, random_link_end_latitude)#
		random_distance <- runif(1, 0, min_separation)#
		# Define point at which cut will begin:#
		cut_point_1 <- EndPoint(random_link_start_longitude, random_link_start_latitude, random_link_start_bearing, random_distance)[c("long", "lat")]#
		# Get cut bearing (will be used to describe Great Circle made by cut):#
		cut_bearing <- runif(1, 0, 360)#
		# Pick second point on Great Circle to use to describe it:#
		cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
		# If there are protected links (need to check if cut line intersects them and if so redraw):#
		if(nrow(protected_links) > 0) {#
			# Variable to switch to true if intersection is found:#
			intersection_occurs <- FALSE#
			# For each protected link:#
			for(i in 1:nrow(protected_links)) {#
				# Find if there are any intersections:#
				intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
				# If there are intersectiosn update intersection_occurs:#
				if(nrow(intersections) > 0) intersection_occurs <- TRUE#
			}#
			# Set up counter (to be used rto warn user if loop gets stuck):#
			counter <- 1#
			# Whilst there is an intersection between the cut line and a protected link:#
			while(intersection_occurs) {#
				# Get new cut bearing (will be used to describe Great Circle made by cut):#
				cut_bearing <- runif(1, 0, 360)#
				# Pick new second point on Great Circle to use to describe it:#
				cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
				# Overwrite intersection occurs:#
				intersection_occurs <- FALSE#
				# For each protected link:#
				for(i in 1:nrow(protected_links)) {#
					# Find if there are any intersections:#
					intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
					# If there are intersectiosn update intersection_occurs:#
					if(nrow(intersections) > 0) intersection_occurs <- TRUE#
				}#
				# Update counter:#
				counter <- counter + 1#
				# Add stop in case this loop never closes:#
				if(counter == 10000) stop("ERROR: Model failed as cannot find clean separation cut line.")#
			}#
		}#
		# Get first pole to the cut line equator:#
		cut_line_pole_1 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing + 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		# Get second pole to the cut line equator:#
		cut_line_pole_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing - 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		GC_distances_to_pole_1 <- One2ManyGreatCircleDistance(cut_line_pole_1$long, cut_line_pole_1$lat, longitudes, latitudes, EarthRad = EarthRad)#
#
		GC_distances_to_pole_2 <- One2ManyGreatCircleDistance(cut_line_pole_2$long, cut_line_pole_2$lat, longitudes, latitudes, EarthRad = EarthRad)#
		first_clump <- paste(continent_numbers[which(GC_distances_to_pole_1 < (0.5 * pi * EarthRad))], collapse="&")#
		second_clump <- paste(continent_numbers[which(GC_distances_to_pole_2 < (0.5 * pi * EarthRad))], collapse="&")#
	# Case if no unprotected links:#
	} else {#
# Need to warn but have output of no separation!#
	}#
first_clump#
second_clump
# Check min separation is not greater than 1/2 circumference of planet:#
	# Make sure continent numbers are stored as character vector for matching:#
	continent_numbers <- as.character(continent_numbers)#
	# Get all intercontinental links in cluster:#
	unprotected_links <- intercontinent_links <- IntercontinentalLinks(min_separation, longitudes, latitudes, EarthRad = EarthRad)#
	# Add row and column names:#
	colnames(unprotected_links) <- colnames(intercontinent_links) <- rownames(unprotected_links) <- rownames(intercontinent_links) <- continent_numbers#
	# If there are protected links:#
	if(nrow(protected_links) > 0) {#
		# For each protected link:#
		for(i in 1:nrow(protected_links)) {#
			# Update unprotected links by setting protected link state to zero:#
			unprotected_links[as.character(protected_links[i, 1]), as.character(protected_links[i, 2])] <- unprotected_links[as.character(protected_links[i, 2]), as.character(protected_links[i, 1])] <- 0#
		}#
	}#
	# If there are unprotected links (and can continue with separation):#
	if(sum(unprotected_links[lower.tri(unprotected_links)]) > 0) {#
		# Pick a random link from the matrix:#
		link_position <- sample(which(intercontinent_links == 1))[1]#
		# Set starting link (from continent to continent):#
		start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))#
		# Whilst randomly chosen link is a protected link:#
		while(unprotected_links[start_link[1], start_link[2]] == 0) {#
			# Pick a new random link from the matrix:#
			link_position <- sample(which(intercontinent_links == 1))[1]#
			# Update start link:#
			start_link <- sort(c(link_position %% nrow(intercontinent_links), ceiling(link_position / nrow(intercontinent_links))))#
		}#
		# Define start links by continent numbers:#
		start_link <- colnames(intercontinent_links)[start_link]#
		random_link_start_longitude <- longitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_start_latitude <- latitudes[match(start_link[1], colnames(intercontinent_links))]#
		random_link_end_longitude <- longitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_end_latitude <- latitudes[match(start_link[2], colnames(intercontinent_links))]#
		random_link_start_bearing <- BearingBetweenTwoLongLatPoints(random_link_start_longitude, random_link_start_latitude, random_link_end_longitude, random_link_end_latitude)#
		random_distance <- runif(1, 0, min_separation)#
		# Define point at which cut will begin:#
		cut_point_1 <- EndPoint(random_link_start_longitude, random_link_start_latitude, random_link_start_bearing, random_distance)[c("long", "lat")]#
		# Get cut bearing (will be used to describe Great Circle made by cut):#
		cut_bearing <- runif(1, 0, 360)#
		# Pick second point on Great Circle to use to describe it:#
		cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
		# If there are protected links (need to check if cut line intersects them and if so redraw):#
		if(nrow(protected_links) > 0) {#
			# Variable to switch to true if intersection is found:#
			intersection_occurs <- FALSE#
			# For each protected link:#
			for(i in 1:nrow(protected_links)) {#
				# Find if there are any intersections:#
				intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
				# If there are intersectiosn update intersection_occurs:#
				if(nrow(intersections) > 0) intersection_occurs <- TRUE#
			}#
			# Set up counter (to be used rto warn user if loop gets stuck):#
			counter <- 1#
			# Whilst there is an intersection between the cut line and a protected link:#
			while(intersection_occurs) {#
				# Get new cut bearing (will be used to describe Great Circle made by cut):#
				cut_bearing <- runif(1, 0, 360)#
				# Pick new second point on Great Circle to use to describe it:#
				cut_point_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, cut_bearing, min_separation)[c("long", "lat")]#
				# Overwrite intersection occurs:#
				intersection_occurs <- FALSE#
				# For each protected link:#
				for(i in 1:nrow(protected_links)) {#
					# Find if there are any intersections:#
					intersections <- ArcIntersection(longitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[1], colnames(intercontinent_links))], longitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], latitudes[match(as.character(protected_links[i, ])[2], colnames(intercontinent_links))], cut_point_1$long, cut_point_1$lat, cut_point_2$long, cut_point_2$lat, type = c("arc", "GC"), EarthRad = EarthRad)#
					# If there are intersectiosn update intersection_occurs:#
					if(nrow(intersections) > 0) intersection_occurs <- TRUE#
				}#
				# Update counter:#
				counter <- counter + 1#
				# Add stop in case this loop never closes:#
				if(counter == 10000) stop("ERROR: Model failed as cannot find clean separation cut line.")#
			}#
		}#
		# Get first pole to the cut line equator:#
		cut_line_pole_1 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing + 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		# Get second pole to the cut line equator:#
		cut_line_pole_2 <- EndPoint(cut_point_1$long, cut_point_1$lat, (cut_bearing - 90) %% 360, 0.5 * pi * EarthRad)[c("long", "lat")]#
		GC_distances_to_pole_1 <- One2ManyGreatCircleDistance(cut_line_pole_1$long, cut_line_pole_1$lat, longitudes, latitudes, EarthRad = EarthRad)#
#
		GC_distances_to_pole_2 <- One2ManyGreatCircleDistance(cut_line_pole_2$long, cut_line_pole_2$lat, longitudes, latitudes, EarthRad = EarthRad)#
		first_clump <- paste(continent_numbers[which(GC_distances_to_pole_1 < (0.5 * pi * EarthRad))], collapse="&")#
		second_clump <- paste(continent_numbers[which(GC_distances_to_pole_2 < (0.5 * pi * EarthRad))], collapse="&")#
	# Case if no unprotected links:#
	} else {#
# Need to warn but have output of no separation!#
	}#
first_clump#
second_clump
continent(numbers)
continent_numbers
paste(continent_numbers, collapse="&")
min_separation
min_separation > (pi * EarthRad)
pi * EarthRad
document()
document()
document()
document()
document()
document()
install()
