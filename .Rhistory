start_step <- min(which(edge_start_time >= step_times))#
		end_step <- max(which(edge_end_time <= step_times))#
		# Case if branch starts at step value:#
		if((edge_start_time - step_times[start_step]) == 0) {#
			start_lon <- slon#
			start_lat <- slat#
		# Case if branch starts before a step value:#
		} else {#
		}#
		step_matrix <- matrix(nrow = 3, ncol = end_step - start_step + 1, dimnames=list(c("step_time", "step_long", "step_lat"), start_step:end_step))#
		step_matrix[1, ] <- step_times[start_step:end_step]#
		for(i in start_step:end_step) {#
			step_matrix[]#
			out <- EndPoint(slon = start_lon, slat = start_lat, bearing = runif(1, 0, 360), distance = abs(rnorm(1, steplengthmean, steplengthsd)))	#
			start_lon <- out$long#
			start_lat <- out$lat#
		}
i
match(i, colnames(step_matrix))
step_matrix
start_step <- min(which(edge_start_time >= step_times))#
		end_step <- max(which(edge_end_time <= step_times))#
		# Case if branch starts at step value:#
		if((edge_start_time - step_times[start_step]) == 0) {#
			start_lon <- slon#
			start_lat <- slat#
		# Case if branch starts before a step value:#
		} else {#
		}#
		step_matrix <- matrix(nrow = 3, ncol = end_step - start_step + 1, dimnames=list(c("step_time", "step_long", "step_lat"), start_step:end_step))#
		step_matrix[1, ] <- step_times[start_step:end_step]#
		for(i in start_step:end_step) {#
			step_matrix[2, match(i, colnames(step_matrix))] <- start_lon#
			step_matrix[3, match(i, colnames(step_matrix))] <- start_lat#
			out <- EndPoint(slon = start_lon, slat = start_lat, bearing = runif(1, 0, 360), distance = abs(rnorm(1, steplengthmean, steplengthsd)))#
			start_lon <- out$long#
			start_lat <- out$lat#
		}
step_matrix
step_times[end_step] - edge_end_time
step_times
diff(step_times)
diff(step_times)[1]
abs(diff(step_times)[1])
# Get step size:#
	step_size <- abs(diff(step_times)[1])
edge_start_time - step_times[start_step]
step_times[end_step] - edge_end_time
(step_times[end_step] - edge_end_time) / step_size
step_matrix
step_matrix[, end_step]
step_matrix[2, end_step]
EndPoint(slon = start_lon, slat = start_lat, bearing = runif(1, 0, 360), distance = abs(rnorm(1, steplengthmean, steplengthsd)))
step_fraction <- (step_times[end_step] - edge_end_time) / step_size#
			last_step <- EndPoint(slon = start_lon, slat = start_lat, bearing = runif(1, 0, 360), distance = step_fraction* abs(rnorm(1, steplengthmean, steplengthsd)))
step_fraction
step_fraction <- (step_times[end_step] - edge_end_time) / step_size#
			last_step <- EndPoint(slon = step_matrix[2, end_step], slat = step_matrix[3, end_step], bearing = runif(1, 0, 360), distance = step_fraction* abs(rnorm(1, steplengthmean, steplengthsd)))
last_step
edge_start_time - step_times[start_step]
step_fraction <- edge_start_time - step_times[start_step]
step_matrix
# Get first step present on branch:#
		start_step <- min(which(edge_start_time >= step_times))#
		# Get last step present on branch:#
		end_step <- max(which(edge_end_time <= step_times))#
		# Case if branch starts at step value:#
		if((edge_start_time - step_times[start_step]) == 0) {#
			# Set starting longitude as input longitude:#
			start_lon <- slon#
			# Set starting longitude as input latitude:#
			start_lat <- slat#
		# Case if branch starts before a step value:#
		} else {#
			step_fraction <- edge_start_time - step_times[start_step]#
			first_step <- EndPoint(slon = slon, slat = slat, bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			start_lon <- first_step$long#
			start_lat <- first_step$lat			#
		}#
		step_matrix <- matrix(nrow = 3, ncol = end_step - start_step + 1, dimnames=list(c("step_time", "step_long", "step_lat"), start_step:end_step))#
		step_matrix[1, ] <- step_times[start_step:end_step]#
		for(i in start_step:end_step) {#
			step_matrix[2, match(i, colnames(step_matrix))] <- start_lon#
			step_matrix[3, match(i, colnames(step_matrix))] <- start_lat#
			out <- EndPoint(slon = start_lon, slat = start_lat, bearing = runif(1, 0, 360), distance = abs(rnorm(1, steplengthmean, steplengthsd)))#
			start_lon <- out$long#
			start_lat <- out$lat#
		}#
		# Case if branch ends at step value:#
		if((step_times[end_step] - edge_end_time) == 0) {#
			elon <- step_matrix[2, end_step]#
			elat <- step_matrix[3, end_step]#
		# Case if branch ends after a step value:#
		} else {#
			step_fraction <- (step_times[end_step] - edge_end_time) / step_size#
			last_step <- EndPoint(slon = step_matrix[2, end_step], slat = step_matrix[3, end_step], bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			elon <- last_step$long#
			elat <- last_step$lat			#
		}
step_matrix
cbind(c(edge_start_time, slon, slat), step_matrix, c(edge_end_time, elon, elat))
# Get first step present on branch:#
		start_step <- min(which(edge_start_time >= step_times))#
		# Get last step present on branch:#
		end_step <- max(which(edge_end_time <= step_times))#
		# Case if branch starts at step value:#
		if((edge_start_time - step_times[start_step]) == 0) {#
			# Set starting longitude as input longitude:#
			start_lon <- slon#
			# Set starting longitude as input latitude:#
			start_lat <- slat#
		# Case if branch starts before a step value:#
		} else {#
			# Calculate fraction of a step being performed:#
			step_fraction <- edge_start_time - step_times[start_step]#
			# Make first step to join branch beginning to first step:#
			first_step <- EndPoint(slon = slon, slat = slat, bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record starting longitude:#
			start_lon <- first_step$long#
			# Record starting latitude:#
			start_lat <- first_step$lat			#
		}#
		# Create step matrix to store results:#
		step_matrix <- matrix(nrow = 3, ncol = end_step - start_step + 1, dimnames=list(c("step_time", "step_long", "step_lat"), start_step:end_step))#
		# Fill in step times:#
		step_matrix[1, ] <- step_times[start_step:end_step]#
		# For each step:#
		for(i in start_step:end_step) {#
			# Record starting longitude:#
			step_matrix[2, match(i, colnames(step_matrix))] <- start_lon#
			# Record starting latitude:#
			step_matrix[3, match(i, colnames(step_matrix))] <- start_lat#
			# Make next step:#
			next_step <- EndPoint(slon = start_lon, slat = start_lat, bearing = runif(1, 0, 360), distance = abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Update starting longitude:#
			start_lon <- next_step$long#
			# Update starting latitude:#
			start_lat <- next_step$lat#
		}#
		# Case if branch ends at step value:#
		if((step_times[end_step] - edge_end_time) == 0) {#
			# Set ending longitude as last value in step matrix:#
			elon <- step_matrix[2, end_step]#
			# Set ending latitude as last value in step matrix:#
			elat <- step_matrix[3, end_step]#
		# Case if branch ends after a step value:#
		} else {#
			# Calculate fraction of a step rom last step to end of branch:#
			step_fraction <- (step_times[end_step] - edge_end_time) / step_size#
			# Make actual last step to end of branch:#
			last_step <- EndPoint(slon = step_matrix[2, end_step], slat = step_matrix[3, end_step], bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record ending longitude:#
			elon <- last_step$long#
			# Record ending latitude:#
			elat <- last_step$lat			#
		}#
		# Compile output:#
		output <- cbind(c(edge_start_time, slon, slat), step_matrix, c(edge_end_time, elon, elat))
output
# Get first step present on branch:#
		start_step <- min(which(edge_start_time >= step_times))#
		# Get last step present on branch:#
		end_step <- max(which(edge_end_time <= step_times))#
		# Case if branch starts at step value:#
		if((edge_start_time - step_times[start_step]) == 0) {#
			# Set starting longitude as input longitude:#
			start_lon <- slon#
			# Set starting longitude as input latitude:#
			start_lat <- slat#
		# Case if branch starts before a step value:#
		} else {#
			# Calculate fraction of a step being performed:#
			step_fraction <- edge_start_time - step_times[start_step]#
			# Make first step to join branch beginning to first step:#
			first_step <- EndPoint(slon = slon, slat = slat, bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record starting longitude:#
			start_lon <- first_step$long#
			# Record starting latitude:#
			start_lat <- first_step$lat			#
		}#
		# Create step matrix to store results:#
		step_matrix <- matrix(nrow = 3, ncol = end_step - start_step + 1, dimnames=list(c("step_time", "step_long", "step_lat"), start_step:end_step))#
		# Fill in step times:#
		step_matrix[1, ] <- step_times[start_step:end_step]#
		# For each step:#
		for(i in start_step:end_step) {#
			# Record starting longitude:#
			step_matrix[2, match(i, colnames(step_matrix))] <- start_lon#
			# Record starting latitude:#
			step_matrix[3, match(i, colnames(step_matrix))] <- start_lat#
			# Make next step:#
			next_step <- EndPoint(slon = start_lon, slat = start_lat, bearing = runif(1, 0, 360), distance = abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Update starting longitude:#
			start_lon <- next_step$long#
			# Update starting latitude:#
			start_lat <- next_step$lat#
		}#
		# Case if branch ends at step value:#
		if((step_times[end_step] - edge_end_time) == 0) {#
			# Set ending longitude as last value in step matrix:#
			elon <- step_matrix[2, end_step]#
			# Set ending latitude as last value in step matrix:#
			elat <- step_matrix[3, end_step]#
		# Case if branch ends after a step value:#
		} else {#
			# Calculate fraction of a step rom last step to end of branch:#
			step_fraction <- (step_times[end_step] - edge_end_time) / step_size#
			# Make actual last step to end of branch:#
			last_step <- EndPoint(slon = step_matrix[2, end_step], slat = step_matrix[3, end_step], bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record ending longitude:#
			elon <- last_step$long#
			# Record ending latitude:#
			elat <- last_step$lat			#
		}#
		# Compile output:#
		output <- cbind(c(edge_start_time, slon, slat), step_matrix, c(edge_end_time, elon, elat))#
		rownames(output) <- c("step_time", "step_long", "step_lat")#
		colnames(output)[1] <- "begin"#
		colnames(output)[ncol(output)] <- "end"
output
# Get first step present on branch:#
		start_step <- min(which(edge_start_time >= step_times))#
		# Get last step present on branch:#
		end_step <- max(which(edge_end_time <= step_times))#
		# Case if branch starts at step value:#
		if((edge_start_time - step_times[start_step]) == 0) {#
			# Set starting longitude as input longitude:#
			start_lon <- slon#
			# Set starting longitude as input latitude:#
			start_lat <- slat#
		# Case if branch starts before a step value:#
		} else {#
			# Calculate fraction of a step being performed:#
			step_fraction <- edge_start_time - step_times[start_step]#
			# Make first step to join branch beginning to first step:#
			first_step <- EndPoint(slon = slon, slat = slat, bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record starting longitude:#
			start_lon <- first_step$long#
			# Record starting latitude:#
			start_lat <- first_step$lat			#
		}#
		# Create step matrix to store results:#
		step_matrix <- matrix(nrow = 3, ncol = end_step - start_step + 1, dimnames=list(c("step_time", "step_long", "step_lat"), start_step:end_step))#
		# Fill in step times:#
		step_matrix[1, ] <- step_times[start_step:end_step]#
		# For each step:#
		for(i in start_step:end_step) {#
			# Record starting longitude:#
			step_matrix[2, match(i, colnames(step_matrix))] <- start_lon#
			# Record starting latitude:#
			step_matrix[3, match(i, colnames(step_matrix))] <- start_lat#
			# Make next step:#
			next_step <- EndPoint(slon = start_lon, slat = start_lat, bearing = runif(1, 0, 360), distance = abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Update starting longitude:#
			start_lon <- next_step$long#
			# Update starting latitude:#
			start_lat <- next_step$lat#
		}#
		# Case if branch ends at step value:#
		if((step_times[end_step] - edge_end_time) == 0) {#
			# Set ending longitude as last value in step matrix:#
			elon <- step_matrix[2, end_step]#
			# Set ending latitude as last value in step matrix:#
			elat <- step_matrix[3, end_step]#
		# Case if branch ends after a step value:#
		} else {#
			# Calculate fraction of a step rom last step to end of branch:#
			step_fraction <- (step_times[end_step] - edge_end_time) / step_size#
			# Make actual last step to end of branch:#
			last_step <- EndPoint(slon = step_matrix[2, end_step], slat = step_matrix[3, end_step], bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record ending longitude:#
			elon <- last_step$long#
			# Record ending latitude:#
			elat <- last_step$lat			#
		}#
		# Compile output:#
		output <- cbind(c(edge_start_time, slon, slat), step_matrix, c(edge_end_time, elon, elat))#
		rownames(output) <- c("step_time", "step_long", "step_lat")#
		colnames(output)[1] <- "begin"#
		colnames(output)[ncol(output)] <- "end"
output
start_edges
i
edge_ages
edge_ages[i, ]
for(i in start_edges) {}#
	BranchWalker(slat, slon, step_times, step_size, edge_ages[i, 1], edge_ages[i, 2], steplengthmean, steplengthsd)
# Sub-function to random walk along a single branch:#
	BranchWalker <- function(slat = 0, slon = 0, step_times, step_size, edge_start_time, edge_end_time, steplengthmean = 0, steplengthsd = 1) {#
		# Get first step present on branch:#
		start_step <- min(which(edge_start_time >= step_times))#
		# Get last step present on branch:#
		end_step <- max(which(edge_end_time <= step_times))#
		# Case if branch starts at step value:#
		if((edge_start_time - step_times[start_step]) == 0) {#
			# Set starting longitude as input longitude:#
			start_lon <- slon#
			# Set starting longitude as input latitude:#
			start_lat <- slat#
		# Case if branch starts before a step value:#
		} else {#
			# Calculate fraction of a step being performed:#
			step_fraction <- edge_start_time - step_times[start_step]#
			# Make first step to join branch beginning to first step:#
			first_step <- EndPoint(slon = slon, slat = slat, bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record starting longitude:#
			start_lon <- first_step$long#
			# Record starting latitude:#
			start_lat <- first_step$lat			#
		}#
		# Create step matrix to store results:#
		step_matrix <- matrix(nrow = 3, ncol = end_step - start_step + 1, dimnames=list(c("step_time", "step_long", "step_lat"), start_step:end_step))#
		# Fill in step times:#
		step_matrix[1, ] <- step_times[start_step:end_step]#
		# For each step:#
		for(i in start_step:end_step) {#
			# Record starting longitude:#
			step_matrix[2, match(i, colnames(step_matrix))] <- start_lon#
			# Record starting latitude:#
			step_matrix[3, match(i, colnames(step_matrix))] <- start_lat#
			# Make next step:#
			next_step <- EndPoint(slon = start_lon, slat = start_lat, bearing = runif(1, 0, 360), distance = abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Update starting longitude:#
			start_lon <- next_step$long#
			# Update starting latitude:#
			start_lat <- next_step$lat#
		}#
		# Case if branch ends at step value:#
		if((step_times[end_step] - edge_end_time) == 0) {#
			# Set ending longitude as last value in step matrix:#
			elon <- step_matrix[2, end_step]#
			# Set ending latitude as last value in step matrix:#
			elat <- step_matrix[3, end_step]#
		# Case if branch ends after a step value:#
		} else {#
			# Calculate fraction of a step rom last step to end of branch:#
			step_fraction <- (step_times[end_step] - edge_end_time) / step_size#
			# Make actual last step to end of branch:#
			last_step <- EndPoint(slon = step_matrix[2, end_step], slat = step_matrix[3, end_step], bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record ending longitude:#
			elon <- last_step$long#
			# Record ending latitude:#
			elat <- last_step$lat			#
		}#
		# Compile output:#
		output <- cbind(c(edge_start_time, slon, slat), step_matrix, c(edge_end_time, elon, elat))#
		# Update row names:#
		rownames(output) <- c("step_time", "step_long", "step_lat")#
		# Update column names:#
		colnames(output)[1] <- "begin"#
		# Update column names:#
		colnames(output)[ncol(output)] <- "end"#
		# Return output:#
		return(output)#
	}#
	for(i in start_edges) {}#
	BranchWalker(slat, slon, step_times, step_size, edge_ages[i, 1], edge_ages[i, 2], steplengthmean, steplengthsd)
out <- BranchWalker(slat, slon, step_times, step_size, edge_ages[i, 1], edge_ages[i, 2], steplengthmean, steplengthsd)
out
out[2, ]
out[3, ]
map()
lines(out[2, ], out[3, ], col="red")
map(xlim=c(-10, 10), ylim=c(-10, 10))
lines(out[2, ], out[3, ], col="red")
map(xlim=c(-10, 10), ylim=c(-10, 10))
lines(out[2, ], out[3, ], col=rainbow(26))
?lines
edges_list
edges_list[[i]]
end_points_matrix
step_matrix[, "Begin"]
step_matrix
step_matrix <- BranchWalker(slat, slon, step_times, step_size, edge_ages[i, 1], edge_ages[i, 2], steplengthmean, steplengthsd)
step_matrix
step_matrix[, "begin"]
step_matrix[2:3, "begin"]
step_matrix[2:3, "begin"], step_matrix[2:3, "end"]
c(step_matrix[2:3, "begin"], step_matrix[2:3, "end"])
end_points_matrix[i, ]
require(Claddis)#
# Conditional if next step is to new branch#
	# Establish root node number:#
	root_node <- Ntip(tree) + 1#
	# Get maximum path length and store as root age:#
	tree$root.time <- max(diag(vcv(tree)))#
	# Get step times:#
	step_times <- seq(tree$root.time, 0, length.out=niter)#
#
	# Get step size:#
	step_size <- abs(diff(step_times)[1])#
	# Get node ages:#
	node_ages <- GetNodeAges(tree)#
	# Get matrix of beginning and end ages for branches:#
	edge_ages <- cbind(node_ages[tree$edge[, 1]], node_ages[tree$edge[, 2]], dimnames=c(c(), c()))#
	# Matrix to store beginning and end points for each branch:#
	end_points_matrix <- matrix(NA, ncol=4, nrow=nrow(tree$edge), dimnames=list(c(), c("Begin_lon", "Begin_lat", "End_lon", "End_lat")))#
	# Get starting edges:	#
	start_edges <- which(tree$edge[, 1] == root_node)#
	# Create edges list:#
	edges_list <- as.list(c(1:nrow(tree$edge)))#
	# Sub-function to random walk along a single branch:#
	BranchWalker <- function(slat = 0, slon = 0, step_times, step_size, edge_start_time, edge_end_time, steplengthmean = 0, steplengthsd = 1) {#
		# Get first step present on branch:#
		start_step <- min(which(edge_start_time >= step_times))#
		# Get last step present on branch:#
		end_step <- max(which(edge_end_time <= step_times))#
		# Case if branch starts at step value:#
		if((edge_start_time - step_times[start_step]) == 0) {#
			# Set starting longitude as input longitude:#
			start_lon <- slon#
			# Set starting longitude as input latitude:#
			start_lat <- slat#
		# Case if branch starts before a step value:#
		} else {#
			# Calculate fraction of a step being performed:#
			step_fraction <- edge_start_time - step_times[start_step]#
			# Make first step to join branch beginning to first step:#
			first_step <- EndPoint(slon = slon, slat = slat, bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record starting longitude:#
			start_lon <- first_step$long#
			# Record starting latitude:#
			start_lat <- first_step$lat			#
		}#
		# Create step matrix to store results:#
		step_matrix <- matrix(nrow = 3, ncol = end_step - start_step + 1, dimnames=list(c("step_time", "step_long", "step_lat"), start_step:end_step))#
		# Fill in step times:#
		step_matrix[1, ] <- step_times[start_step:end_step]#
		# For each step:#
		for(i in start_step:end_step) {#
			# Record starting longitude:#
			step_matrix[2, match(i, colnames(step_matrix))] <- start_lon#
			# Record starting latitude:#
			step_matrix[3, match(i, colnames(step_matrix))] <- start_lat#
			# Make next step:#
			next_step <- EndPoint(slon = start_lon, slat = start_lat, bearing = runif(1, 0, 360), distance = abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Update starting longitude:#
			start_lon <- next_step$long#
			# Update starting latitude:#
			start_lat <- next_step$lat#
		}#
		# Case if branch ends at step value:#
		if((step_times[end_step] - edge_end_time) == 0) {#
			# Set ending longitude as last value in step matrix:#
			elon <- step_matrix[2, end_step]#
			# Set ending latitude as last value in step matrix:#
			elat <- step_matrix[3, end_step]#
		# Case if branch ends after a step value:#
		} else {#
			# Calculate fraction of a step rom last step to end of branch:#
			step_fraction <- (step_times[end_step] - edge_end_time) / step_size#
			# Make actual last step to end of branch:#
			last_step <- EndPoint(slon = step_matrix[2, end_step], slat = step_matrix[3, end_step], bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record ending longitude:#
			elon <- last_step$long#
			# Record ending latitude:#
			elat <- last_step$lat			#
		}#
		# Compile output:#
		output <- cbind(c(edge_start_time, slon, slat), step_matrix, c(edge_end_time, elon, elat))#
		# Update row names:#
		rownames(output) <- c("step_time", "step_long", "step_lat")#
		# Update column names:#
		colnames(output)[1] <- "begin"#
		# Update column names:#
		colnames(output)[ncol(output)] <- "end"#
		# Return output:#
		return(output)#
	}#
	for(i in start_edges) {#
		step_matrix <- BranchWalker(slat, slon, step_times, step_size, edge_ages[i, 1], edge_ages[i, 2], steplengthmean, steplengthsd)#
		edges_list[[i]] <- step_matrix#
		end_points_matrix[i, ] <- c(step_matrix[2:3, "begin"], step_matrix[2:3, "end"])#
	}
end_points_matrix
# For each starting (root connected) edge:#
	for(i in start_edges) {#
		# Get step_matrix for branch and add to edges_list:#
		edges_list[[i]] <- step_matrix <- BranchWalker(slat, slon, step_times, step_size, edge_ages[i, 1], edge_ages[i, 2], steplengthmean, steplengthsd)#
		end_points_matrix[i, ] <- c(edges_list[[i]][2:3, "begin"], edges_list[[i]][2:3, "end"])#
	}
end_points_matrix
any(is.na(end_points_matrix))
end_points_matrix
end_points_matrix[, 1]
is.na(end_points_matrix[, 1])
which(is.na(end_points_matrix[, 1]))
tree$edge[which(is.na(end_points_matrix[, 1])), ]
tree$edge[which(is.na(end_points_matrix[, 1])), 1]
which(!is.na(end_points_matrix[, 1]))
tree$edge[which(!is.na(end_points_matrix[, 1])), 2]
c(tree$edge[which(is.na(end_points_matrix[, 1])), 1], tree$edge[which(!is.na(end_points_matrix[, 1])), 2])
intersect(tree$edge[which(is.na(end_points_matrix[, 1])), 1], tree$edge[which(!is.na(end_points_matrix[, 1])), 2])
match(intersect(tree$edge[which(is.na(end_points_matrix[, 1])), 1], tree$edge[which(!is.na(end_points_matrix[, 1])), 2]), tree$edge[which(is.na(end_points_matrix[, 1])), 1])
which(is.na(end_points_matrix[, 1]))[match(intersect(tree$edge[which(is.na(end_points_matrix[, 1])), 1], tree$edge[which(!is.na(end_points_matrix[, 1])), 2]), tree$edge[which(is.na(end_points_matrix[, 1])), 1])]
which(is.na(end_points_matrix[, 1]))[match(intersect(tree$edge[which(is.na(end_points_matrix[, 1])), 1], tree$edge[which(!is.na(end_points_matrix[, 1])), 2]), tree$edge[which(is.na(end_points_matrix[, 1])), 1])][1]
# Find an edge that has starting point available:#
		next_available_edge <- which(is.na(end_points_matrix[, 1]))[match(intersect(tree$edge[which(is.na(end_points_matrix[, 1])), 1], tree$edge[which(!is.na(end_points_matrix[, 1])), 2]), tree$edge[which(is.na(end_points_matrix[, 1])), 1])][1]
next_available_edge
tree$edge[next_available_edge, 1]
match(tree$edge[next_available_edge, 1], tree$edge[, 2])
# Find an edge that has starting point available:#
		next_available_edge <- which(is.na(end_points_matrix[, 1]))[match(intersect(tree$edge[which(is.na(end_points_matrix[, 1])), 1], tree$edge[which(!is.na(end_points_matrix[, 1])), 2]), tree$edge[which(is.na(end_points_matrix[, 1])), 1])][1]#
		preceding_edge <- match(tree$edge[next_available_edge, 1], tree$edge[, 2])
preceding_edge
edges_list[[preceding_edge]]
edges_list[[preceding_edge]][, "end"]
edges_list[[preceding_edge]]["step_long", "end"]
# As long as there are branches that have not been walked along:#
	while(any(is.na(end_points_matrix))) {#
		# Find an edge that has starting point available:#
		next_available_edge <- which(is.na(end_points_matrix[, 1]))[match(intersect(tree$edge[which(is.na(end_points_matrix[, 1])), 1], tree$edge[which(!is.na(end_points_matrix[, 1])), 2]), tree$edge[which(is.na(end_points_matrix[, 1])), 1])][1]#
		preceding_edge <- match(tree$edge[next_available_edge, 1], tree$edge[, 2])#
		edges_list[[next_available_edge]] <- BranchWalker(edges_list[[preceding_edge]]["step_lat", "end"], edges_list[[preceding_edge]]["step_long", "end"], step_times, step_size, edge_ages[next_available_edge, 1], edge_ages[next_available_edge, 2], steplengthmean, steplengthsd)#
#
		# Add end points of branches to end points matrix:#
		end_points_matrix[next_available_edge, ] <- c(edges_list[[next_available_edge]][2:3, "begin"], edges_list[[next_available_edge]][2:3, "end"])#
#
	}
i
end_points_matrix
# Find an edge that has starting point available:#
		next_available_edge <- which(is.na(end_points_matrix[, 1]))[match(intersect(tree$edge[which(is.na(end_points_matrix[, 1])), 1], tree$edge[which(!is.na(end_points_matrix[, 1])), 2]), tree$edge[which(is.na(end_points_matrix[, 1])), 1])][1]#
		preceding_edge <- match(tree$edge[next_available_edge, 1], tree$edge[, 2])
BranchWalker(edges_list[[preceding_edge]]["step_lat", "end"], edges_list[[preceding_edge]]["step_long", "end"], step_times, step_size, edge_ages[next_available_edge, 1], edge_ages[next_available_edge, 2], steplengthmean, steplengthsd)
slat<-edges_list[[preceding_edge]]["step_lat", "end"]
slon<-edges_list[[preceding_edge]]["step_long", "end"]
edge_ages[next_available_edge, 1]
edge_start_time <- edge_ages[next_available_edge, 1]
edge_end_time <- edge_ages[next_available_edge, 2]
# Get first step present on branch:#
		start_step <- min(which(edge_start_time >= step_times))#
		# Get last step present on branch:#
		end_step <- max(which(edge_end_time <= step_times))
start_step
end_step
(edge_start_time - step_times[start_step]) == 0
# Calculate fraction of a step being performed:#
			step_fraction <- edge_start_time - step_times[start_step]
step_fraction
# Calculate fraction of a step being performed:#
			step_fraction <- edge_start_time - step_times[start_step]#
			# Make first step to join branch beginning to first step:#
			first_step <- EndPoint(slon = slon, slat = slat, bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record starting longitude:#
			start_lon <- first_step$long#
			# Record starting latitude:#
			start_lat <- first_step$lat
start_lon
start_lat
# Create step matrix to store results:#
		step_matrix <- matrix(nrow = 3, ncol = end_step - start_step + 1, dimnames=list(c("step_time", "step_long", "step_lat"), start_step:end_step))#
		# Fill in step times:#
		step_matrix[1, ] <- step_times[start_step:end_step]
step_matrix
# For each step:#
		for(i in start_step:end_step) {#
}
# For each step:#
		for(i in start_step:end_step) {#
			# Record starting longitude:#
			step_matrix[2, match(i, colnames(step_matrix))] <- start_lon#
			# Record starting latitude:#
			step_matrix[3, match(i, colnames(step_matrix))] <- start_lat#
			# Make next step:#
			next_step <- EndPoint(slon = start_lon, slat = start_lat, bearing = runif(1, 0, 360), distance = abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Update starting longitude:#
			start_lon <- next_step$long#
			# Update starting latitude:#
			start_lat <- next_step$lat#
		}
step_matrix
(step_times[end_step] - edge_end_time) == 0
# Calculate fraction of a step rom last step to end of branch:#
			step_fraction <- (step_times[end_step] - edge_end_time) / step_size#
			# Make actual last step to end of branch:#
			last_step <- EndPoint(slon = step_matrix[2, end_step], slat = step_matrix[3, end_step], bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record ending longitude:#
			elon <- last_step$long#
			# Record ending latitude:#
			elat <- last_step$lat
end_step
# Establish root node number:#
	root_node <- Ntip(tree) + 1#
	# Get maximum path length and store as root age:#
	tree$root.time <- max(diag(vcv(tree)))#
	# Get step times:#
	step_times <- seq(tree$root.time, 0, length.out=niter)#
#
	# Get step size:#
	step_size <- abs(diff(step_times)[1])#
	# Get node ages:#
	node_ages <- GetNodeAges(tree)#
	# Get matrix of beginning and end ages for branches:#
	edge_ages <- cbind(node_ages[tree$edge[, 1]], node_ages[tree$edge[, 2]], dimnames=c(c(), c()))#
	# Matrix to store beginning and end points for each branch:#
	end_points_matrix <- matrix(NA, ncol=4, nrow=nrow(tree$edge), dimnames=list(c(), c("Begin_lon", "Begin_lat", "End_lon", "End_lat")))#
	# Get starting edges:	#
	start_edges <- which(tree$edge[, 1] == root_node)#
	# Create edges list:#
	edges_list <- as.list(c(1:nrow(tree$edge)))#
	# Sub-function to random walk along a single branch:#
	BranchWalker <- function(slat = 0, slon = 0, step_times, step_size, edge_start_time, edge_end_time, steplengthmean = 0, steplengthsd = 1) {#
		# Get first step present on branch:#
		start_step <- min(which(edge_start_time >= step_times))#
		# Get last step present on branch:#
		end_step <- max(which(edge_end_time <= step_times))#
		# Case if branch starts at step value:#
		if((edge_start_time - step_times[start_step]) == 0) {#
			# Set starting longitude as input longitude:#
			start_lon <- slon#
			# Set starting longitude as input latitude:#
			start_lat <- slat#
		# Case if branch starts before a step value:#
		} else {#
			# Calculate fraction of a step being performed:#
			step_fraction <- edge_start_time - step_times[start_step]#
			# Make first step to join branch beginning to first step:#
			first_step <- EndPoint(slon = slon, slat = slat, bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record starting longitude:#
			start_lon <- first_step$long#
			# Record starting latitude:#
			start_lat <- first_step$lat#
		}#
		# Create step matrix to store results:#
		step_matrix <- matrix(nrow = 3, ncol = end_step - start_step + 1, dimnames=list(c("step_time", "step_long", "step_lat"), start_step:end_step))#
		# Fill in step times:#
		step_matrix[1, ] <- step_times[start_step:end_step]#
		# For each step:#
		for(i in start_step:end_step) {#
			# Record starting longitude:#
			step_matrix[2, match(i, colnames(step_matrix))] <- start_lon#
			# Record starting latitude:#
			step_matrix[3, match(i, colnames(step_matrix))] <- start_lat#
			# Make next step:#
			next_step <- EndPoint(slon = start_lon, slat = start_lat, bearing = runif(1, 0, 360), distance = abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Update starting longitude:#
			start_lon <- next_step$long#
			# Update starting latitude:#
			start_lat <- next_step$lat#
		}#
		# Case if branch ends at step value:#
		if((step_times[end_step] - edge_end_time) == 0) {#
			# Set ending longitude as last value in step matrix:#
			elon <- step_matrix[2, as.character(end_step)]#
			# Set ending latitude as last value in step matrix:#
			elat <- step_matrix[3, as.character(end_step)]#
		# Case if branch ends after a step value:#
		} else {#
			# Calculate fraction of a step rom last step to end of branch:#
			step_fraction <- (step_times[end_step] - edge_end_time) / step_size#
			# Make actual last step to end of branch:#
			last_step <- EndPoint(slon = step_matrix[2, as.character(end_step)], slat = step_matrix[3, as.character(end_step)], bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record ending longitude:#
			elon <- last_step$long#
			# Record ending latitude:#
			elat <- last_step$lat			#
		}#
		# Compile output:#
		output <- cbind(c(edge_start_time, slon, slat), step_matrix, c(edge_end_time, elon, elat))#
		# Update row names:#
		rownames(output) <- c("step_time", "step_long", "step_lat")#
		# Update column names:#
		colnames(output)[1] <- "begin"#
		# Update column names:#
		colnames(output)[ncol(output)] <- "end"#
		# Return output:#
		return(output)#
	}#
	# For each starting (root connected) edge:#
	for(i in start_edges) {#
		# Get step_matrix for branch and add to edges_list:#
		edges_list[[i]] <- BranchWalker(slat, slon, step_times, step_size, edge_ages[i, 1], edge_ages[i, 2], steplengthmean, steplengthsd)#
		# Add end points of branches to end points matrix:#
		end_points_matrix[i, ] <- c(edges_list[[i]][2:3, "begin"], edges_list[[i]][2:3, "end"])#
	}#
#
	# As long as there are branches that have not been walked along:#
	while(any(is.na(end_points_matrix))) {#
		# Find an edge that has starting point available:#
		next_available_edge <- which(is.na(end_points_matrix[, 1]))[match(intersect(tree$edge[which(is.na(end_points_matrix[, 1])), 1], tree$edge[which(!is.na(end_points_matrix[, 1])), 2]), tree$edge[which(is.na(end_points_matrix[, 1])), 1])][1]#
		preceding_edge <- match(tree$edge[next_available_edge, 1], tree$edge[, 2])#
		edges_list[[next_available_edge]] <- BranchWalker(edges_list[[preceding_edge]]["step_lat", "end"], edges_list[[preceding_edge]]["step_long", "end"], step_times, step_size, edge_ages[next_available_edge, 1], edge_ages[next_available_edge, 2], steplengthmean, steplengthsd)#
#
		# Add end points of branches to end points matrix:#
		end_points_matrix[next_available_edge, ] <- c(edges_list[[next_available_edge]][2:3, "begin"], edges_list[[next_available_edge]][2:3, "end"])#
#
	}
end_points_matrix
edges_list
TreeWalker <- function(tree, slat = 0, slon = 0, niter = 1000, steplengthmean = 0, steplengthsd = 1) {#
# Add conditional to check tree is rooted!#
# Add Claddis to dependencies?#
#
	require(Claddis)#
	# Establish root node number:#
	root_node <- Ntip(tree) + 1#
	# Get maximum path length and store as root age:#
	tree$root.time <- max(diag(vcv(tree)))#
	# Get step times:#
	step_times <- seq(tree$root.time, 0, length.out=niter)#
#
	# Get step size:#
	step_size <- abs(diff(step_times)[1])#
	# Get node ages:#
	node_ages <- GetNodeAges(tree)#
	# Get matrix of beginning and end ages for branches:#
	edge_ages <- cbind(node_ages[tree$edge[, 1]], node_ages[tree$edge[, 2]], dimnames=c(c(), c()))#
	# Matrix to store beginning and end points for each branch:#
	end_points_matrix <- matrix(NA, ncol=4, nrow=nrow(tree$edge), dimnames=list(c(), c("Begin_lon", "Begin_lat", "End_lon", "End_lat")))#
	# Get starting edges:	#
	start_edges <- which(tree$edge[, 1] == root_node)#
	# Create edges list:#
	edges_list <- as.list(c(1:nrow(tree$edge)))#
	# Sub-function to random walk along a single branch:#
	BranchWalker <- function(slat = 0, slon = 0, step_times, step_size, edge_start_time, edge_end_time, steplengthmean = 0, steplengthsd = 1) {#
		# Get first step present on branch:#
		start_step <- min(which(edge_start_time >= step_times))#
		# Get last step present on branch:#
		end_step <- max(which(edge_end_time <= step_times))#
		# Case if branch starts at step value:#
		if((edge_start_time - step_times[start_step]) == 0) {#
			# Set starting longitude as input longitude:#
			start_lon <- slon#
			# Set starting longitude as input latitude:#
			start_lat <- slat#
		# Case if branch starts before a step value:#
		} else {#
			# Calculate fraction of a step being performed:#
			step_fraction <- edge_start_time - step_times[start_step]#
			# Make first step to join branch beginning to first step:#
			first_step <- EndPoint(slon = slon, slat = slat, bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record starting longitude:#
			start_lon <- first_step$long#
			# Record starting latitude:#
			start_lat <- first_step$lat#
		}#
		# Create step matrix to store results:#
		step_matrix <- matrix(nrow = 3, ncol = end_step - start_step + 1, dimnames=list(c("step_time", "step_long", "step_lat"), start_step:end_step))#
		# Fill in step times:#
		step_matrix[1, ] <- step_times[start_step:end_step]#
		# For each step:#
		for(i in start_step:end_step) {#
			# Record starting longitude:#
			step_matrix[2, match(i, colnames(step_matrix))] <- start_lon#
			# Record starting latitude:#
			step_matrix[3, match(i, colnames(step_matrix))] <- start_lat#
			# Make next step:#
			next_step <- EndPoint(slon = start_lon, slat = start_lat, bearing = runif(1, 0, 360), distance = abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Update starting longitude:#
			start_lon <- next_step$long#
			# Update starting latitude:#
			start_lat <- next_step$lat#
		}#
		# Case if branch ends at step value:#
		if((step_times[end_step] - edge_end_time) == 0) {#
			# Set ending longitude as last value in step matrix:#
			elon <- step_matrix[2, as.character(end_step)]#
			# Set ending latitude as last value in step matrix:#
			elat <- step_matrix[3, as.character(end_step)]#
		# Case if branch ends after a step value:#
		} else {#
			# Calculate fraction of a step rom last step to end of branch:#
			step_fraction <- (step_times[end_step] - edge_end_time) / step_size#
			# Make actual last step to end of branch:#
			last_step <- EndPoint(slon = step_matrix[2, as.character(end_step)], slat = step_matrix[3, as.character(end_step)], bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record ending longitude:#
			elon <- last_step$long#
			# Record ending latitude:#
			elat <- last_step$lat			#
		}#
		# Compile output:#
		output <- cbind(c(edge_start_time, slon, slat), step_matrix, c(edge_end_time, elon, elat))#
		# Update row names:#
		rownames(output) <- c("step_time", "step_long", "step_lat")#
		# Update column names:#
		colnames(output)[1] <- "begin"#
		# Update column names:#
		colnames(output)[ncol(output)] <- "end"#
		# Return output:#
		return(output)#
	}#
	# For each starting (root connected) edge:#
	for(i in start_edges) {#
		# Get step_matrix for branch and add to edges_list:#
		edges_list[[i]] <- BranchWalker(slat, slon, step_times, step_size, edge_ages[i, 1], edge_ages[i, 2], steplengthmean, steplengthsd)#
		# Add end points of branches to end points matrix:#
		end_points_matrix[i, ] <- c(edges_list[[i]][2:3, "begin"], edges_list[[i]][2:3, "end"])#
	}#
#
	# As long as there are branches that have not been walked along:#
	while(any(is.na(end_points_matrix))) {#
		# Find an edge that has starting point available:#
		next_available_edge <- which(is.na(end_points_matrix[, 1]))[match(intersect(tree$edge[which(is.na(end_points_matrix[, 1])), 1], tree$edge[which(!is.na(end_points_matrix[, 1])), 2]), tree$edge[which(is.na(end_points_matrix[, 1])), 1])][1]#
		preceding_edge <- match(tree$edge[next_available_edge, 1], tree$edge[, 2])#
		edges_list[[next_available_edge]] <- BranchWalker(edges_list[[preceding_edge]]["step_lat", "end"], edges_list[[preceding_edge]]["step_long", "end"], step_times, step_size, edge_ages[next_available_edge, 1], edge_ages[next_available_edge, 2], steplengthmean, steplengthsd)#
#
		# Add end points of branches to end points matrix:#
		end_points_matrix[next_available_edge, ] <- c(edges_list[[next_available_edge]][2:3, "begin"], edges_list[[next_available_edge]][2:3, "end"])#
#
	}#
	return(edges_list)#
#
# Discretize tree?#
# Output list of edges each a vector showing position in random walk#
# Allow for rate changes on tree in future?#
}
# Run function setting start point at equator-Greenwich Meridian intersection:#
TreeWalker(tree, slat = 0, slon = 0, niter = 1000, lengthmean = 0, lengthsd = 100)
# Run function setting start point at equator-Greenwich Meridian intersection:#
TreeWalker(tree, slat = 0, slon = 0, niter = 1000, steplengthmean = 0, steplengthsd = 100)
# Run function setting start point at equator-Greenwich Meridian intersection:#
TreeWalker(tree, slat = 0, slon = 0, niter = 100, steplengthmean = 0, steplengthsd = 100)
tree
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 100, steplengthmean = 0, steplengthsd = 100)
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 100, steplengthmean = 0, steplengthsd = 1000)#
#
# Plot map:#
map()#
#
for(i in 1:length(out)) {#
#
lines(edges_list[[i]][2, ], edges_list[[i]][3, ], col="red")#
#
}
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 100, steplengthmean = 0, steplengthsd = 10000)#
#
# Plot map:#
map()#
#
for(i in 1:length(out)) {#
#
lines(edges_list[[i]][2, ], edges_list[[i]][3, ], col="red")#
#
}
TreeWalker <- function(tree, slat = 0, slon = 0, niter = 1000, steplengthmean = 0, steplengthsd = 1) {#
# Add conditional to check tree is rooted!#
# Add Claddis to dependencies?#
#
	require(Claddis)#
	# Establish root node number:#
	root_node <- Ntip(tree) + 1#
	# Get maximum path length and store as root age:#
	tree$root.time <- max(diag(vcv(tree)))#
	# Get step times:#
	step_times <- seq(tree$root.time, 0, length.out=niter)#
#
	# Get step size:#
	step_size <- abs(diff(step_times)[1])#
	# Get node ages:#
	node_ages <- GetNodeAges(tree)#
	# Get matrix of beginning and end ages for branches:#
	edge_ages <- cbind(node_ages[tree$edge[, 1]], node_ages[tree$edge[, 2]], dimnames=c(c(), c()))#
	# Matrix to store beginning and end points for each branch:#
	end_points_matrix <- matrix(NA, ncol=4, nrow=nrow(tree$edge), dimnames=list(c(), c("Begin_lon", "Begin_lat", "End_lon", "End_lat")))#
	# Get starting edges:	#
	start_edges <- which(tree$edge[, 1] == root_node)#
	# Create edges list:#
	edges_list <- as.list(c(1:nrow(tree$edge)))#
	# Sub-function to random walk along a single branch:#
	BranchWalker <- function(slat = 0, slon = 0, step_times, step_size, edge_start_time, edge_end_time, steplengthmean = steplengthmean, steplengthsd = steplengthsd) {#
		# Get first step present on branch:#
		start_step <- min(which(edge_start_time >= step_times))#
		# Get last step present on branch:#
		end_step <- max(which(edge_end_time <= step_times))#
		# Case if branch starts at step value:#
		if((edge_start_time - step_times[start_step]) == 0) {#
			# Set starting longitude as input longitude:#
			start_lon <- slon#
			# Set starting longitude as input latitude:#
			start_lat <- slat#
		# Case if branch starts before a step value:#
		} else {#
			# Calculate fraction of a step being performed:#
			step_fraction <- edge_start_time - step_times[start_step]#
			# Make first step to join branch beginning to first step:#
			first_step <- EndPoint(slon = slon, slat = slat, bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record starting longitude:#
			start_lon <- first_step$long#
			# Record starting latitude:#
			start_lat <- first_step$lat#
		}#
		# Create step matrix to store results:#
		step_matrix <- matrix(nrow = 3, ncol = end_step - start_step + 1, dimnames=list(c("step_time", "step_long", "step_lat"), start_step:end_step))#
		# Fill in step times:#
		step_matrix[1, ] <- step_times[start_step:end_step]#
		# For each step:#
		for(i in start_step:end_step) {#
			# Record starting longitude:#
			step_matrix[2, match(i, colnames(step_matrix))] <- start_lon#
			# Record starting latitude:#
			step_matrix[3, match(i, colnames(step_matrix))] <- start_lat#
			# Make next step:#
			next_step <- EndPoint(slon = start_lon, slat = start_lat, bearing = runif(1, 0, 360), distance = abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Update starting longitude:#
			start_lon <- next_step$long#
			# Update starting latitude:#
			start_lat <- next_step$lat#
		}#
		# Case if branch ends at step value:#
		if((step_times[end_step] - edge_end_time) == 0) {#
			# Set ending longitude as last value in step matrix:#
			elon <- step_matrix[2, as.character(end_step)]#
			# Set ending latitude as last value in step matrix:#
			elat <- step_matrix[3, as.character(end_step)]#
		# Case if branch ends after a step value:#
		} else {#
			# Calculate fraction of a step rom last step to end of branch:#
			step_fraction <- (step_times[end_step] - edge_end_time) / step_size#
			# Make actual last step to end of branch:#
			last_step <- EndPoint(slon = step_matrix[2, as.character(end_step)], slat = step_matrix[3, as.character(end_step)], bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record ending longitude:#
			elon <- last_step$long#
			# Record ending latitude:#
			elat <- last_step$lat			#
		}#
		# Compile output:#
		output <- cbind(c(edge_start_time, slon, slat), step_matrix, c(edge_end_time, elon, elat))#
		# Update row names:#
		rownames(output) <- c("step_time", "step_long", "step_lat")#
		# Update column names:#
		colnames(output)[1] <- "begin"#
		# Update column names:#
		colnames(output)[ncol(output)] <- "end"#
		# Return output:#
		return(output)#
	}#
	# For each starting (root connected) edge:#
	for(i in start_edges) {#
		# Get step_matrix for branch and add to edges_list:#
		edges_list[[i]] <- BranchWalker(slat, slon, step_times, step_size, edge_ages[i, 1], edge_ages[i, 2], steplengthmean, steplengthsd)#
		# Add end points of branches to end points matrix:#
		end_points_matrix[i, ] <- c(edges_list[[i]][2:3, "begin"], edges_list[[i]][2:3, "end"])#
	}#
#
	# As long as there are branches that have not been walked along:#
	while(any(is.na(end_points_matrix))) {#
		# Find an edge that has starting point available:#
		next_available_edge <- which(is.na(end_points_matrix[, 1]))[match(intersect(tree$edge[which(is.na(end_points_matrix[, 1])), 1], tree$edge[which(!is.na(end_points_matrix[, 1])), 2]), tree$edge[which(is.na(end_points_matrix[, 1])), 1])][1]#
		preceding_edge <- match(tree$edge[next_available_edge, 1], tree$edge[, 2])#
		edges_list[[next_available_edge]] <- BranchWalker(edges_list[[preceding_edge]]["step_lat", "end"], edges_list[[preceding_edge]]["step_long", "end"], step_times, step_size, edge_ages[next_available_edge, 1], edge_ages[next_available_edge, 2], steplengthmean, steplengthsd)#
#
		# Add end points of branches to end points matrix:#
		end_points_matrix[next_available_edge, ] <- c(edges_list[[next_available_edge]][2:3, "begin"], edges_list[[next_available_edge]][2:3, "end"])#
#
	}#
	return(edges_list)#
#
# Discretize tree?#
# Output list of edges each a vector showing position in random walk#
# Allow for rate changes on tree in future?#
}#
#
# Generate random 50-taxon tree:#
#tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 100, steplengthmean = 0, steplengthsd = 10000)#
#
# Plot map:#
map()#
#
for(i in 1:length(out)) {#
#
lines(edges_list[[i]][2, ], edges_list[[i]][3, ], col="red")#
#
}
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 100, steplengthmean = 0, steplengthsd = 100)#
#
# Plot map:#
map(xlim=c(-10, 10), ylim=c(-10, 10))#
#
for(i in 1:length(out)) {#
#
lines(edges_list[[i]][2, ], edges_list[[i]][3, ], col="red")#
#
}
# Plot map:#
map(xlim=c(-10, 10), ylim=c(-10, 10))#
#
for(i in 1:length(out)) {#
#
lines(edges_list[[i]][2, ], edges_list[[i]][3, ], col="red", rainbow(length(out))[i])#
#
}
rainbow(length(out))
# Plot map:#
map(xlim=c(-10, 10), ylim=c(-10, 10))#
#
for(i in 1:length(out)) {#
#
lines(edges_list[[i]][2, ], edges_list[[i]][3, ], col=rainbow(length(out))[i])#
#
}
Sys.sleep(1)
# Plot map:#
map(xlim=c(-10, 10), ylim=c(-10, 10))#
#
for(i in 1:length(out)) {#
#
	Sys.sleep(1)#
lines(edges_list[[i]][2, ], edges_list[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 100, steplengthmean = 0, steplengthsd = 10000)#
#
# Plot map:#
map(xlim=c(-10, 10), ylim=c(-10, 10))#
#
for(i in 1:length(out)) {#
#
lines(edges_list[[i]][2, ], edges_list[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 100, steplengthmean = 0, steplengthsd = 100000000)#
#
# Plot map:#
map(xlim=c(-10, 10), ylim=c(-10, 10))#
#
for(i in 1:length(out)) {#
#
lines(edges_list[[i]][2, ], edges_list[[i]][3, ], col=rainbow(length(out))[i])#
#
}
TreeWalker <- function(tree, slat = 0, slon = 0, niter = 1000, steplengthmean = 0, steplengthsd = 1000) {#
# Add conditional to check tree is rooted!#
# Add Claddis to dependencies?#
#
	require(Claddis)#
	# Establish root node number:#
	root_node <- Ntip(tree) + 1#
	# Get maximum path length and store as root age:#
	tree$root.time <- max(diag(vcv(tree)))#
	# Get step times:#
	step_times <- seq(tree$root.time, 0, length.out=niter)#
#
	# Get step size:#
	step_size <- abs(diff(step_times)[1])#
	# Get node ages:#
	node_ages <- GetNodeAges(tree)#
	# Get matrix of beginning and end ages for branches:#
	edge_ages <- cbind(node_ages[tree$edge[, 1]], node_ages[tree$edge[, 2]], dimnames=c(c(), c()))#
	# Matrix to store beginning and end points for each branch:#
	end_points_matrix <- matrix(NA, ncol=4, nrow=nrow(tree$edge), dimnames=list(c(), c("Begin_lon", "Begin_lat", "End_lon", "End_lat")))#
	# Get starting edges:	#
	start_edges <- which(tree$edge[, 1] == root_node)#
	# Create edges list:#
	edges_list <- as.list(c(1:nrow(tree$edge)))#
	# Sub-function to random walk along a single branch:#
	BranchWalker <- function(slat = 0, slon = 0, step_times, step_size, edge_start_time, edge_end_time, steplengthmean = steplengthmean, steplengthsd = steplengthsd) {#
		# Get first step present on branch:#
		start_step <- min(which(edge_start_time >= step_times))#
		# Get last step present on branch:#
		end_step <- max(which(edge_end_time <= step_times))#
		# Case if branch starts at step value:#
		if((edge_start_time - step_times[start_step]) == 0) {#
			# Set starting longitude as input longitude:#
			start_lon <- slon#
			# Set starting longitude as input latitude:#
			start_lat <- slat#
		# Case if branch starts before a step value:#
		} else {#
			# Calculate fraction of a step being performed:#
			step_fraction <- edge_start_time - step_times[start_step]#
			# Make first step to join branch beginning to first step:#
			first_step <- EndPoint(slon = slon, slat = slat, bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record starting longitude:#
			start_lon <- first_step$long#
			# Record starting latitude:#
			start_lat <- first_step$lat#
		}#
		# Create step matrix to store results:#
		step_matrix <- matrix(nrow = 3, ncol = end_step - start_step + 1, dimnames=list(c("step_time", "step_long", "step_lat"), start_step:end_step))#
		# Fill in step times:#
		step_matrix[1, ] <- step_times[start_step:end_step]#
		# For each step:#
		for(i in start_step:end_step) {#
			# Record starting longitude:#
			step_matrix[2, match(i, colnames(step_matrix))] <- start_lon#
			# Record starting latitude:#
			step_matrix[3, match(i, colnames(step_matrix))] <- start_lat#
			# Make next step:#
			next_step <- EndPoint(slon = start_lon, slat = start_lat, bearing = runif(1, 0, 360), distance = abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Update starting longitude:#
			start_lon <- next_step$long#
			# Update starting latitude:#
			start_lat <- next_step$lat#
		}#
		# Case if branch ends at step value:#
		if((step_times[end_step] - edge_end_time) == 0) {#
			# Set ending longitude as last value in step matrix:#
			elon <- step_matrix[2, as.character(end_step)]#
			# Set ending latitude as last value in step matrix:#
			elat <- step_matrix[3, as.character(end_step)]#
		# Case if branch ends after a step value:#
		} else {#
			# Calculate fraction of a step rom last step to end of branch:#
			step_fraction <- (step_times[end_step] - edge_end_time) / step_size#
			# Make actual last step to end of branch:#
			last_step <- EndPoint(slon = step_matrix[2, as.character(end_step)], slat = step_matrix[3, as.character(end_step)], bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record ending longitude:#
			elon <- last_step$long#
			# Record ending latitude:#
			elat <- last_step$lat			#
		}#
		# Compile output:#
		output <- cbind(c(edge_start_time, slon, slat), step_matrix, c(edge_end_time, elon, elat))#
		# Update row names:#
		rownames(output) <- c("step_time", "step_long", "step_lat")#
		# Update column names:#
		colnames(output)[1] <- "begin"#
		# Update column names:#
		colnames(output)[ncol(output)] <- "end"#
		# Return output:#
		return(output)#
	}#
	# For each starting (root connected) edge:#
	for(i in start_edges) {#
		# Get step_matrix for branch and add to edges_list:#
		edges_list[[i]] <- BranchWalker(slat, slon, step_times, step_size, edge_ages[i, 1], edge_ages[i, 2], steplengthmean, steplengthsd)#
		# Add end points of branches to end points matrix:#
		end_points_matrix[i, ] <- c(edges_list[[i]][2:3, "begin"], edges_list[[i]][2:3, "end"])#
	}#
#
	# As long as there are branches that have not been walked along:#
	while(any(is.na(end_points_matrix))) {#
		# Find an edge that has starting point available:#
		next_available_edge <- which(is.na(end_points_matrix[, 1]))[match(intersect(tree$edge[which(is.na(end_points_matrix[, 1])), 1], tree$edge[which(!is.na(end_points_matrix[, 1])), 2]), tree$edge[which(is.na(end_points_matrix[, 1])), 1])][1]#
		# Find preceding edge (which has starting values for latitude and longitude at end):#
		preceding_edge <- match(tree$edge[next_available_edge, 1], tree$edge[, 2])#
		# Randomly walk along branch and store results:#
		edges_list[[next_available_edge]] <- BranchWalker(edges_list[[preceding_edge]]["step_lat", "end"], edges_list[[preceding_edge]]["step_long", "end"], step_times, step_size, edge_ages[next_available_edge, 1], edge_ages[next_available_edge, 2], steplengthmean, steplengthsd)#
#
		# Add end points of branches to end points matrix:#
		end_points_matrix[next_available_edge, ] <- c(edges_list[[next_available_edge]][2:3, "begin"], edges_list[[next_available_edge]][2:3, "end"])#
#
	}#
	# Return edges list:#
	return(edges_list)#
#
# Discretize tree?#
# Output list of edges each a vector showing position in random walk#
# Allow for rate changes on tree in future?#
}#
#
# Generate random 50-taxon tree:#
#tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 100, steplengthmean = 0, steplengthsd = 100000000)#
#
# Plot map:#
map(xlim=c(-10, 10), ylim=c(-10, 10))#
#
for(i in 1:length(out)) {#
#
lines(edges_list[[i]][2, ], edges_list[[i]][3, ], col=rainbow(length(out))[i])#
#
}
TreeWalker <- function(tree, slat = 0, slon = 0, niter = 1000, steplengthmean = 0, steplengthsd = 10000000000) {#
# Add conditional to check tree is rooted!#
# Add Claddis to dependencies?#
#
	require(Claddis)#
	# Establish root node number:#
	root_node <- Ntip(tree) + 1#
	# Get maximum path length and store as root age:#
	tree$root.time <- max(diag(vcv(tree)))#
	# Get step times:#
	step_times <- seq(tree$root.time, 0, length.out=niter)#
#
	# Get step size:#
	step_size <- abs(diff(step_times)[1])#
	# Get node ages:#
	node_ages <- GetNodeAges(tree)#
	# Get matrix of beginning and end ages for branches:#
	edge_ages <- cbind(node_ages[tree$edge[, 1]], node_ages[tree$edge[, 2]], dimnames=c(c(), c()))#
	# Matrix to store beginning and end points for each branch:#
	end_points_matrix <- matrix(NA, ncol=4, nrow=nrow(tree$edge), dimnames=list(c(), c("Begin_lon", "Begin_lat", "End_lon", "End_lat")))#
	# Get starting edges:	#
	start_edges <- which(tree$edge[, 1] == root_node)#
	# Create edges list:#
	edges_list <- as.list(c(1:nrow(tree$edge)))#
	# Sub-function to random walk along a single branch:#
	BranchWalker <- function(slat = 0, slon = 0, step_times, step_size, edge_start_time, edge_end_time, steplengthmean = steplengthmean, steplengthsd = steplengthsd) {#
		# Get first step present on branch:#
		start_step <- min(which(edge_start_time >= step_times))#
		# Get last step present on branch:#
		end_step <- max(which(edge_end_time <= step_times))#
		# Case if branch starts at step value:#
		if((edge_start_time - step_times[start_step]) == 0) {#
			# Set starting longitude as input longitude:#
			start_lon <- slon#
			# Set starting longitude as input latitude:#
			start_lat <- slat#
		# Case if branch starts before a step value:#
		} else {#
			# Calculate fraction of a step being performed:#
			step_fraction <- edge_start_time - step_times[start_step]#
			# Make first step to join branch beginning to first step:#
			first_step <- EndPoint(slon = slon, slat = slat, bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record starting longitude:#
			start_lon <- first_step$long#
			# Record starting latitude:#
			start_lat <- first_step$lat#
		}#
		# Create step matrix to store results:#
		step_matrix <- matrix(nrow = 3, ncol = end_step - start_step + 1, dimnames=list(c("step_time", "step_long", "step_lat"), start_step:end_step))#
		# Fill in step times:#
		step_matrix[1, ] <- step_times[start_step:end_step]#
		# For each step:#
		for(i in start_step:end_step) {#
			# Record starting longitude:#
			step_matrix[2, match(i, colnames(step_matrix))] <- start_lon#
			# Record starting latitude:#
			step_matrix[3, match(i, colnames(step_matrix))] <- start_lat#
			# Make next step:#
			next_step <- EndPoint(slon = start_lon, slat = start_lat, bearing = runif(1, 0, 360), distance = abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Update starting longitude:#
			start_lon <- next_step$long#
			# Update starting latitude:#
			start_lat <- next_step$lat#
		}#
		# Case if branch ends at step value:#
		if((step_times[end_step] - edge_end_time) == 0) {#
			# Set ending longitude as last value in step matrix:#
			elon <- step_matrix[2, as.character(end_step)]#
			# Set ending latitude as last value in step matrix:#
			elat <- step_matrix[3, as.character(end_step)]#
		# Case if branch ends after a step value:#
		} else {#
			# Calculate fraction of a step rom last step to end of branch:#
			step_fraction <- (step_times[end_step] - edge_end_time) / step_size#
			# Make actual last step to end of branch:#
			last_step <- EndPoint(slon = step_matrix[2, as.character(end_step)], slat = step_matrix[3, as.character(end_step)], bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record ending longitude:#
			elon <- last_step$long#
			# Record ending latitude:#
			elat <- last_step$lat			#
		}#
		# Compile output:#
		output <- cbind(c(edge_start_time, slon, slat), step_matrix, c(edge_end_time, elon, elat))#
		# Update row names:#
		rownames(output) <- c("step_time", "step_long", "step_lat")#
		# Update column names:#
		colnames(output)[1] <- "begin"#
		# Update column names:#
		colnames(output)[ncol(output)] <- "end"#
		# Return output:#
		return(output)#
	}#
	# For each starting (root connected) edge:#
	for(i in start_edges) {#
		# Get step_matrix for branch and add to edges_list:#
		edges_list[[i]] <- BranchWalker(slat, slon, step_times, step_size, edge_ages[i, 1], edge_ages[i, 2], steplengthmean, steplengthsd)#
		# Add end points of branches to end points matrix:#
		end_points_matrix[i, ] <- c(edges_list[[i]][2:3, "begin"], edges_list[[i]][2:3, "end"])#
	}#
#
	# As long as there are branches that have not been walked along:#
	while(any(is.na(end_points_matrix))) {#
		# Find an edge that has starting point available:#
		next_available_edge <- which(is.na(end_points_matrix[, 1]))[match(intersect(tree$edge[which(is.na(end_points_matrix[, 1])), 1], tree$edge[which(!is.na(end_points_matrix[, 1])), 2]), tree$edge[which(is.na(end_points_matrix[, 1])), 1])][1]#
		# Find preceding edge (which has starting values for latitude and longitude at end):#
		preceding_edge <- match(tree$edge[next_available_edge, 1], tree$edge[, 2])#
		# Randomly walk along branch and store results:#
		edges_list[[next_available_edge]] <- BranchWalker(edges_list[[preceding_edge]]["step_lat", "end"], edges_list[[preceding_edge]]["step_long", "end"], step_times, step_size, edge_ages[next_available_edge, 1], edge_ages[next_available_edge, 2], steplengthmean, steplengthsd)#
#
		# Add end points of branches to end points matrix:#
		end_points_matrix[next_available_edge, ] <- c(edges_list[[next_available_edge]][2:3, "begin"], edges_list[[next_available_edge]][2:3, "end"])#
#
	}#
	# Return edges list:#
	return(edges_list)#
#
# Discretize tree?#
# Output list of edges each a vector showing position in random walk#
# Allow for rate changes on tree in future?#
}#
#
# Generate random 50-taxon tree:#
#tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 100, steplengthmean = 0, steplengthsd = 100000000)#
#
# Plot map:#
map(xlim=c(-10, 10), ylim=c(-10, 10))#
#
for(i in 1:length(out)) {#
#
lines(edges_list[[i]][2, ], edges_list[[i]][3, ], col=rainbow(length(out))[i])#
#
}
TreeWalker <- function(tree, slat = 0, slon = 0, niter = 1000, steplengthmean = 0, steplengthsd = 100) {#
# Add conditional to check tree is rooted!#
# Add Claddis to dependencies?#
#
	require(Claddis)#
	# Establish root node number:#
	root_node <- Ntip(tree) + 1#
	# Get maximum path length and store as root age:#
	tree$root.time <- max(diag(vcv(tree)))#
	# Get step times:#
	step_times <- seq(tree$root.time, 0, length.out=niter)#
#
	# Get step size:#
	step_size <- abs(diff(step_times)[1])#
	# Get node ages:#
	node_ages <- GetNodeAges(tree)#
	# Get matrix of beginning and end ages for branches:#
	edge_ages <- cbind(node_ages[tree$edge[, 1]], node_ages[tree$edge[, 2]], dimnames=c(c(), c()))#
	# Matrix to store beginning and end points for each branch:#
	end_points_matrix <- matrix(NA, ncol=4, nrow=nrow(tree$edge), dimnames=list(c(), c("Begin_lon", "Begin_lat", "End_lon", "End_lat")))#
	# Get starting edges:	#
	start_edges <- which(tree$edge[, 1] == root_node)#
	# Create edges list:#
	edges_list <- as.list(c(1:nrow(tree$edge)))#
	# Sub-function to random walk along a single branch:#
	BranchWalker <- function(slat = 0, slon = 0, step_times, step_size, edge_start_time, edge_end_time, steplengthmean = steplengthmean, steplengthsd = steplengthsd) {#
		# Get first step present on branch:#
		start_step <- min(which(edge_start_time >= step_times))#
		# Get last step present on branch:#
		end_step <- max(which(edge_end_time <= step_times))#
		# Case if branch starts at step value:#
		if((edge_start_time - step_times[start_step]) == 0) {#
			# Set starting longitude as input longitude:#
			start_lon <- slon#
			# Set starting longitude as input latitude:#
			start_lat <- slat#
		# Case if branch starts before a step value:#
		} else {#
			# Calculate fraction of a step being performed:#
			step_fraction <- edge_start_time - step_times[start_step]#
			# Make first step to join branch beginning to first step:#
			first_step <- EndPoint(slon = slon, slat = slat, bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record starting longitude:#
			start_lon <- first_step$long#
			# Record starting latitude:#
			start_lat <- first_step$lat#
		}#
		# Create step matrix to store results:#
		step_matrix <- matrix(nrow = 3, ncol = end_step - start_step + 1, dimnames=list(c("step_time", "step_long", "step_lat"), start_step:end_step))#
		# Fill in step times:#
		step_matrix[1, ] <- step_times[start_step:end_step]#
		# For each step:#
		for(i in start_step:end_step) {#
			# Record starting longitude:#
			step_matrix[2, match(i, colnames(step_matrix))] <- start_lon#
			# Record starting latitude:#
			step_matrix[3, match(i, colnames(step_matrix))] <- start_lat#
			# Make next step:#
			next_step <- EndPoint(slon = start_lon, slat = start_lat, bearing = runif(1, 0, 360), distance = abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Update starting longitude:#
			start_lon <- next_step$long#
			# Update starting latitude:#
			start_lat <- next_step$lat#
		}#
		# Case if branch ends at step value:#
		if((step_times[end_step] - edge_end_time) == 0) {#
			# Set ending longitude as last value in step matrix:#
			elon <- step_matrix[2, as.character(end_step)]#
			# Set ending latitude as last value in step matrix:#
			elat <- step_matrix[3, as.character(end_step)]#
		# Case if branch ends after a step value:#
		} else {#
			# Calculate fraction of a step rom last step to end of branch:#
			step_fraction <- (step_times[end_step] - edge_end_time) / step_size#
			# Make actual last step to end of branch:#
			last_step <- EndPoint(slon = step_matrix[2, as.character(end_step)], slat = step_matrix[3, as.character(end_step)], bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record ending longitude:#
			elon <- last_step$long#
			# Record ending latitude:#
			elat <- last_step$lat			#
		}#
		# Compile output:#
		output <- cbind(c(edge_start_time, slon, slat), step_matrix, c(edge_end_time, elon, elat))#
		# Update row names:#
		rownames(output) <- c("step_time", "step_long", "step_lat")#
		# Update column names:#
		colnames(output)[1] <- "begin"#
		# Update column names:#
		colnames(output)[ncol(output)] <- "end"#
		# Return output:#
		return(output)#
	}#
	# For each starting (root connected) edge:#
	for(i in start_edges) {#
		# Get step_matrix for branch and add to edges_list:#
		edges_list[[i]] <- BranchWalker(slat, slon, step_times, step_size, edge_ages[i, 1], edge_ages[i, 2], steplengthmean, steplengthsd)#
		# Add end points of branches to end points matrix:#
		end_points_matrix[i, ] <- c(edges_list[[i]][2:3, "begin"], edges_list[[i]][2:3, "end"])#
	}#
#
	# As long as there are branches that have not been walked along:#
	while(any(is.na(end_points_matrix))) {#
		# Find an edge that has starting point available:#
		next_available_edge <- which(is.na(end_points_matrix[, 1]))[match(intersect(tree$edge[which(is.na(end_points_matrix[, 1])), 1], tree$edge[which(!is.na(end_points_matrix[, 1])), 2]), tree$edge[which(is.na(end_points_matrix[, 1])), 1])][1]#
		# Find preceding edge (which has starting values for latitude and longitude at end):#
		preceding_edge <- match(tree$edge[next_available_edge, 1], tree$edge[, 2])#
		# Randomly walk along branch and store results:#
		edges_list[[next_available_edge]] <- BranchWalker(edges_list[[preceding_edge]]["step_lat", "end"], edges_list[[preceding_edge]]["step_long", "end"], step_times, step_size, edge_ages[next_available_edge, 1], edge_ages[next_available_edge, 2], steplengthmean, steplengthsd)#
#
		# Add end points of branches to end points matrix:#
		end_points_matrix[next_available_edge, ] <- c(edges_list[[next_available_edge]][2:3, "begin"], edges_list[[next_available_edge]][2:3, "end"])#
#
	}#
	# Return edges list:#
	return(steplengthsd)#
#
# Discretize tree?#
# Output list of edges each a vector showing position in random walk#
# Allow for rate changes on tree in future?#
}#
#
# Generate random 50-taxon tree:#
#tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 100, steplengthmean = 0, steplengthsd = 100000000)
out
TreeWalker <- function(tree, slat = 0, slon = 0, niter = 1000, steplengthmean = 0, steplengthsd = 100) {#
# Add conditional to check tree is rooted!#
# Add Claddis to dependencies?#
#
	require(Claddis)#
	# Establish root node number:#
	root_node <- Ntip(tree) + 1#
	# Get maximum path length and store as root age:#
	tree$root.time <- max(diag(vcv(tree)))#
	# Get step times:#
	step_times <- seq(tree$root.time, 0, length.out=niter)#
#
	# Get step size:#
	step_size <- abs(diff(step_times)[1])#
	# Get node ages:#
	node_ages <- GetNodeAges(tree)#
	# Get matrix of beginning and end ages for branches:#
	edge_ages <- cbind(node_ages[tree$edge[, 1]], node_ages[tree$edge[, 2]], dimnames=c(c(), c()))#
	# Matrix to store beginning and end points for each branch:#
	end_points_matrix <- matrix(NA, ncol=4, nrow=nrow(tree$edge), dimnames=list(c(), c("Begin_lon", "Begin_lat", "End_lon", "End_lat")))#
	# Get starting edges:	#
	start_edges <- which(tree$edge[, 1] == root_node)#
	# Create edges list:#
	edges_list <- as.list(c(1:nrow(tree$edge)))#
	# Sub-function to random walk along a single branch:#
	BranchWalker <- function(slat = 0, slon = 0, step_times, step_size, edge_start_time, edge_end_time, steplengthmean = steplengthmean, steplengthsd = steplengthsd) {#
		# Get first step present on branch:#
		start_step <- min(which(edge_start_time >= step_times))#
		# Get last step present on branch:#
		end_step <- max(which(edge_end_time <= step_times))#
		# Case if branch starts at step value:#
		if((edge_start_time - step_times[start_step]) == 0) {#
			# Set starting longitude as input longitude:#
			start_lon <- slon#
			# Set starting longitude as input latitude:#
			start_lat <- slat#
		# Case if branch starts before a step value:#
		} else {#
			# Calculate fraction of a step being performed:#
			step_fraction <- edge_start_time - step_times[start_step]#
			# Make first step to join branch beginning to first step:#
			first_step <- EndPoint(slon = slon, slat = slat, bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record starting longitude:#
			start_lon <- first_step$long#
			# Record starting latitude:#
			start_lat <- first_step$lat#
		}#
		# Create step matrix to store results:#
		step_matrix <- matrix(nrow = 3, ncol = end_step - start_step + 1, dimnames=list(c("step_time", "step_long", "step_lat"), start_step:end_step))#
		# Fill in step times:#
		step_matrix[1, ] <- step_times[start_step:end_step]#
		# For each step:#
		for(i in start_step:end_step) {#
			# Record starting longitude:#
			step_matrix[2, match(i, colnames(step_matrix))] <- start_lon#
			# Record starting latitude:#
			step_matrix[3, match(i, colnames(step_matrix))] <- start_lat#
			# Make next step:#
			next_step <- EndPoint(slon = start_lon, slat = start_lat, bearing = runif(1, 0, 360), distance = abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Update starting longitude:#
			start_lon <- next_step$long#
			# Update starting latitude:#
			start_lat <- next_step$lat#
		}#
		# Case if branch ends at step value:#
		if((step_times[end_step] - edge_end_time) == 0) {#
			# Set ending longitude as last value in step matrix:#
			elon <- step_matrix[2, as.character(end_step)]#
			# Set ending latitude as last value in step matrix:#
			elat <- step_matrix[3, as.character(end_step)]#
		# Case if branch ends after a step value:#
		} else {#
			# Calculate fraction of a step rom last step to end of branch:#
			step_fraction <- (step_times[end_step] - edge_end_time) / step_size#
			# Make actual last step to end of branch:#
			last_step <- EndPoint(slon = step_matrix[2, as.character(end_step)], slat = step_matrix[3, as.character(end_step)], bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record ending longitude:#
			elon <- last_step$long#
			# Record ending latitude:#
			elat <- last_step$lat			#
		}#
		# Compile output:#
		output <- cbind(c(edge_start_time, slon, slat), step_matrix, c(edge_end_time, elon, elat))#
		# Update row names:#
		rownames(output) <- c("step_time", "step_long", "step_lat")#
		# Update column names:#
		colnames(output)[1] <- "begin"#
		# Update column names:#
		colnames(output)[ncol(output)] <- "end"#
		# Return output:#
		return(output)#
	}#
	# For each starting (root connected) edge:#
	for(i in start_edges) {#
		# Get step_matrix for branch and add to edges_list:#
		edges_list[[i]] <- BranchWalker(slat, slon, step_times, step_size, edge_ages[i, 1], edge_ages[i, 2], steplengthmean, steplengthsd)#
		# Add end points of branches to end points matrix:#
		end_points_matrix[i, ] <- c(edges_list[[i]][2:3, "begin"], edges_list[[i]][2:3, "end"])#
	}#
#
	# As long as there are branches that have not been walked along:#
	while(any(is.na(end_points_matrix))) {#
		# Find an edge that has starting point available:#
		next_available_edge <- which(is.na(end_points_matrix[, 1]))[match(intersect(tree$edge[which(is.na(end_points_matrix[, 1])), 1], tree$edge[which(!is.na(end_points_matrix[, 1])), 2]), tree$edge[which(is.na(end_points_matrix[, 1])), 1])][1]#
		# Find preceding edge (which has starting values for latitude and longitude at end):#
		preceding_edge <- match(tree$edge[next_available_edge, 1], tree$edge[, 2])#
		# Randomly walk along branch and store results:#
		edges_list[[next_available_edge]] <- BranchWalker(edges_list[[preceding_edge]]["step_lat", "end"], edges_list[[preceding_edge]]["step_long", "end"], step_times, step_size, edge_ages[next_available_edge, 1], edge_ages[next_available_edge, 2], steplengthmean, steplengthsd)#
#
		# Add end points of branches to end points matrix:#
		end_points_matrix[next_available_edge, ] <- c(edges_list[[next_available_edge]][2:3, "begin"], edges_list[[next_available_edge]][2:3, "end"])#
#
	}#
	# Return edges list:#
	return(steplengthsd)#
#
# Discretize tree?#
# Output list of edges each a vector showing position in random walk#
# Allow for rate changes on tree in future?#
}#
#
# Generate random 50-taxon tree:#
#tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 100, steplengthmean = 0, steplengthsd = 10000)
out
?rnorm
abs(rnorm(1, steplengthmean, steplengthsd)
)
abs(rnorm(1, steplengthmean, steplengthsd))
abs(rnorm(1000, steplengthmean, steplengthsd))
hist(abs(rnorm(1000, steplengthmean, steplengthsd)))
hist(abs(rnorm(1000, steplengthmean, steplengthsd)), breaks=20)
hist(abs(rnorm(100000, steplengthmean, steplengthsd)), breaks=20)
hist(abs(rnorm(10000000, steplengthmean, steplengthsd)), breaks=20)
TreeWalker <- function(tree, slat = 0, slon = 0, niter = 1000, steplengthmean = 0, steplengthsd = 100) {#
# Add conditional to check tree is rooted!#
# Add Claddis to dependencies?#
#
	require(Claddis)#
	# Establish root node number:#
	root_node <- Ntip(tree) + 1#
	# Get maximum path length and store as root age:#
	tree$root.time <- max(diag(vcv(tree)))#
	# Get step times:#
	step_times <- seq(tree$root.time, 0, length.out=niter)#
#
	# Get step size:#
	step_size <- abs(diff(step_times)[1])#
	# Get node ages:#
	node_ages <- GetNodeAges(tree)#
	# Get matrix of beginning and end ages for branches:#
	edge_ages <- cbind(node_ages[tree$edge[, 1]], node_ages[tree$edge[, 2]], dimnames=c(c(), c()))#
	# Matrix to store beginning and end points for each branch:#
	end_points_matrix <- matrix(NA, ncol=4, nrow=nrow(tree$edge), dimnames=list(c(), c("Begin_lon", "Begin_lat", "End_lon", "End_lat")))#
	# Get starting edges:	#
	start_edges <- which(tree$edge[, 1] == root_node)#
	# Create edges list:#
	edges_list <- as.list(c(1:nrow(tree$edge)))#
	# Sub-function to random walk along a single branch:#
	BranchWalker <- function(slat = 0, slon = 0, step_times, step_size, edge_start_time, edge_end_time, steplengthmean = steplengthmean, steplengthsd = steplengthsd) {#
		# Get first step present on branch:#
		start_step <- min(which(edge_start_time >= step_times))#
		# Get last step present on branch:#
		end_step <- max(which(edge_end_time <= step_times))#
		# Case if branch starts at step value:#
		if((edge_start_time - step_times[start_step]) == 0) {#
			# Set starting longitude as input longitude:#
			start_lon <- slon#
			# Set starting longitude as input latitude:#
			start_lat <- slat#
		# Case if branch starts before a step value:#
		} else {#
			# Calculate fraction of a step being performed:#
			step_fraction <- edge_start_time - step_times[start_step]#
			# Make first step to join branch beginning to first step:#
			first_step <- EndPoint(slon = slon, slat = slat, bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record starting longitude:#
			start_lon <- first_step$long#
			# Record starting latitude:#
			start_lat <- first_step$lat#
		}#
		# Create step matrix to store results:#
		step_matrix <- matrix(nrow = 3, ncol = end_step - start_step + 1, dimnames=list(c("step_time", "step_long", "step_lat"), start_step:end_step))#
		# Fill in step times:#
		step_matrix[1, ] <- step_times[start_step:end_step]#
		# For each step:#
		for(i in start_step:end_step) {#
			# Record starting longitude:#
			step_matrix[2, match(i, colnames(step_matrix))] <- start_lon#
			# Record starting latitude:#
			step_matrix[3, match(i, colnames(step_matrix))] <- start_lat#
			# Make next step:#
			next_step <- EndPoint(slon = start_lon, slat = start_lat, bearing = runif(1, 0, 360), distance = abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Update starting longitude:#
			start_lon <- next_step$long#
			# Update starting latitude:#
			start_lat <- next_step$lat#
		}#
		# Case if branch ends at step value:#
		if((step_times[end_step] - edge_end_time) == 0) {#
			# Set ending longitude as last value in step matrix:#
			elon <- step_matrix[2, as.character(end_step)]#
			# Set ending latitude as last value in step matrix:#
			elat <- step_matrix[3, as.character(end_step)]#
		# Case if branch ends after a step value:#
		} else {#
			# Calculate fraction of a step rom last step to end of branch:#
			step_fraction <- (step_times[end_step] - edge_end_time) / step_size#
			# Make actual last step to end of branch:#
			last_step <- EndPoint(slon = step_matrix[2, as.character(end_step)], slat = step_matrix[3, as.character(end_step)], bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record ending longitude:#
			elon <- last_step$long#
			# Record ending latitude:#
			elat <- last_step$lat			#
		}#
		# Compile output:#
		output <- cbind(c(edge_start_time, slon, slat), step_matrix, c(edge_end_time, elon, elat))#
		# Update row names:#
		rownames(output) <- c("step_time", "step_long", "step_lat")#
		# Update column names:#
		colnames(output)[1] <- "begin"#
		# Update column names:#
		colnames(output)[ncol(output)] <- "end"#
		# Return output:#
		return(output)#
	}#
	# For each starting (root connected) edge:#
	for(i in start_edges) {#
		# Get step_matrix for branch and add to edges_list:#
		edges_list[[i]] <- BranchWalker(slat, slon, step_times, step_size, edge_ages[i, 1], edge_ages[i, 2], steplengthmean, steplengthsd)#
		# Add end points of branches to end points matrix:#
		end_points_matrix[i, ] <- c(edges_list[[i]][2:3, "begin"], edges_list[[i]][2:3, "end"])#
	}#
#
	# As long as there are branches that have not been walked along:#
	while(any(is.na(end_points_matrix))) {#
		# Find an edge that has starting point available:#
		next_available_edge <- which(is.na(end_points_matrix[, 1]))[match(intersect(tree$edge[which(is.na(end_points_matrix[, 1])), 1], tree$edge[which(!is.na(end_points_matrix[, 1])), 2]), tree$edge[which(is.na(end_points_matrix[, 1])), 1])][1]#
		# Find preceding edge (which has starting values for latitude and longitude at end):#
		preceding_edge <- match(tree$edge[next_available_edge, 1], tree$edge[, 2])#
		# Randomly walk along branch and store results:#
		edges_list[[next_available_edge]] <- BranchWalker(edges_list[[preceding_edge]]["step_lat", "end"], edges_list[[preceding_edge]]["step_long", "end"], step_times, step_size, edge_ages[next_available_edge, 1], edge_ages[next_available_edge, 2], steplengthmean, steplengthsd)#
#
		# Add end points of branches to end points matrix:#
		end_points_matrix[next_available_edge, ] <- c(edges_list[[next_available_edge]][2:3, "begin"], edges_list[[next_available_edge]][2:3, "end"])#
#
	}#
	# Return edges list:#
	return(steplengthsd)#
#
# Discretize tree?#
# Output list of edges each a vector showing position in random walk#
# Allow for rate changes on tree in future?#
}#
#
# Generate random 50-taxon tree:#
#tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 100, steplengthmean = 0, steplengthsd = 100000000)#
#
# Plot map:#
map(xlim=c(-10, 10), ylim=c(-10, 10))#
#
for(i in 1:length(out)) {#
#
lines(edges_list[[i]][2, ], edges_list[[i]][3, ], col=rainbow(length(out))[i])#
#
}#
#
# For 1000 random walk steps:#
#for(i in 1:1000) {#
	# Take a random step and store new coordinates:#
	#lonlat2 <- unlist(EndPoint(lonlat[2], lonlat[1], runif(1, 0, 360), abs(rnorm(1, 0, 100)))[c(2, 1)])#
	# Plot coordinates on sphere in rainbow colour order:#
	#lines()#
	# Update lonlat ready for next step:#
	#lonlat <- lonlat2#
#}
# Plot map:#
map(xlim=c(-10, 10), ylim=c(-10, 10))#
#
for(i in 1:length(out)) {#
#
lines(edges_list[[i]][2, ], edges_list[[i]][3, ], col=rainbow(length(out))[i])#
#
}
TreeWalker <- function(tree, slat = 0, slon = 0, niter = 1000, steplengthmean = 0, steplengthsd = 100) {#
# Add conditional to check tree is rooted!#
# Add Claddis to dependencies?#
#
	require(Claddis)#
	# Establish root node number:#
	root_node <- Ntip(tree) + 1#
	# Get maximum path length and store as root age:#
	tree$root.time <- max(diag(vcv(tree)))#
	# Get step times:#
	step_times <- seq(tree$root.time, 0, length.out=niter)#
#
	# Get step size:#
	step_size <- abs(diff(step_times)[1])#
	# Get node ages:#
	node_ages <- GetNodeAges(tree)#
	# Get matrix of beginning and end ages for branches:#
	edge_ages <- cbind(node_ages[tree$edge[, 1]], node_ages[tree$edge[, 2]], dimnames=c(c(), c()))#
	# Matrix to store beginning and end points for each branch:#
	end_points_matrix <- matrix(NA, ncol=4, nrow=nrow(tree$edge), dimnames=list(c(), c("Begin_lon", "Begin_lat", "End_lon", "End_lat")))#
	# Get starting edges:	#
	start_edges <- which(tree$edge[, 1] == root_node)#
	# Create edges list:#
	edges_list <- as.list(c(1:nrow(tree$edge)))#
	# Sub-function to random walk along a single branch:#
	BranchWalker <- function(slat = 0, slon = 0, step_times, step_size, edge_start_time, edge_end_time, steplengthmean = steplengthmean, steplengthsd = steplengthsd) {#
		# Get first step present on branch:#
		start_step <- min(which(edge_start_time >= step_times))#
		# Get last step present on branch:#
		end_step <- max(which(edge_end_time <= step_times))#
		# Case if branch starts at step value:#
		if((edge_start_time - step_times[start_step]) == 0) {#
			# Set starting longitude as input longitude:#
			start_lon <- slon#
			# Set starting longitude as input latitude:#
			start_lat <- slat#
		# Case if branch starts before a step value:#
		} else {#
			# Calculate fraction of a step being performed:#
			step_fraction <- edge_start_time - step_times[start_step]#
			# Make first step to join branch beginning to first step:#
			first_step <- EndPoint(slon = slon, slat = slat, bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record starting longitude:#
			start_lon <- first_step$long#
			# Record starting latitude:#
			start_lat <- first_step$lat#
		}#
		# Create step matrix to store results:#
		step_matrix <- matrix(nrow = 3, ncol = end_step - start_step + 1, dimnames=list(c("step_time", "step_long", "step_lat"), start_step:end_step))#
		# Fill in step times:#
		step_matrix[1, ] <- step_times[start_step:end_step]#
		# For each step:#
		for(i in start_step:end_step) {#
			# Record starting longitude:#
			step_matrix[2, match(i, colnames(step_matrix))] <- start_lon#
			# Record starting latitude:#
			step_matrix[3, match(i, colnames(step_matrix))] <- start_lat#
			# Make next step:#
			next_step <- EndPoint(slon = start_lon, slat = start_lat, bearing = runif(1, 0, 360), distance = abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Update starting longitude:#
			start_lon <- next_step$long#
			# Update starting latitude:#
			start_lat <- next_step$lat#
		}#
		# Case if branch ends at step value:#
		if((step_times[end_step] - edge_end_time) == 0) {#
			# Set ending longitude as last value in step matrix:#
			elon <- step_matrix[2, as.character(end_step)]#
			# Set ending latitude as last value in step matrix:#
			elat <- step_matrix[3, as.character(end_step)]#
		# Case if branch ends after a step value:#
		} else {#
			# Calculate fraction of a step rom last step to end of branch:#
			step_fraction <- (step_times[end_step] - edge_end_time) / step_size#
			# Make actual last step to end of branch:#
			last_step <- EndPoint(slon = step_matrix[2, as.character(end_step)], slat = step_matrix[3, as.character(end_step)], bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record ending longitude:#
			elon <- last_step$long#
			# Record ending latitude:#
			elat <- last_step$lat			#
		}#
		# Compile output:#
		output <- cbind(c(edge_start_time, slon, slat), step_matrix, c(edge_end_time, elon, elat))#
		# Update row names:#
		rownames(output) <- c("step_time", "step_long", "step_lat")#
		# Update column names:#
		colnames(output)[1] <- "begin"#
		# Update column names:#
		colnames(output)[ncol(output)] <- "end"#
		# Return output:#
		return(output)#
	}#
	# For each starting (root connected) edge:#
	for(i in start_edges) {#
		# Get step_matrix for branch and add to edges_list:#
		edges_list[[i]] <- BranchWalker(slat, slon, step_times, step_size, edge_ages[i, 1], edge_ages[i, 2], steplengthmean, steplengthsd)#
		# Add end points of branches to end points matrix:#
		end_points_matrix[i, ] <- c(edges_list[[i]][2:3, "begin"], edges_list[[i]][2:3, "end"])#
	}#
#
	# As long as there are branches that have not been walked along:#
	while(any(is.na(end_points_matrix))) {#
		# Find an edge that has starting point available:#
		next_available_edge <- which(is.na(end_points_matrix[, 1]))[match(intersect(tree$edge[which(is.na(end_points_matrix[, 1])), 1], tree$edge[which(!is.na(end_points_matrix[, 1])), 2]), tree$edge[which(is.na(end_points_matrix[, 1])), 1])][1]#
		# Find preceding edge (which has starting values for latitude and longitude at end):#
		preceding_edge <- match(tree$edge[next_available_edge, 1], tree$edge[, 2])#
		# Randomly walk along branch and store results:#
		edges_list[[next_available_edge]] <- BranchWalker(edges_list[[preceding_edge]]["step_lat", "end"], edges_list[[preceding_edge]]["step_long", "end"], step_times, step_size, edge_ages[next_available_edge, 1], edge_ages[next_available_edge, 2], steplengthmean, steplengthsd)#
#
		# Add end points of branches to end points matrix:#
		end_points_matrix[next_available_edge, ] <- c(edges_list[[next_available_edge]][2:3, "begin"], edges_list[[next_available_edge]][2:3, "end"])#
#
	}#
	# Return edges list:#
	return(edges_list)#
#
# Discretize tree?#
# Output list of edges each a vector showing position in random walk#
# Allow for rate changes on tree in future?#
}#
#
# Generate random 50-taxon tree:#
#tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 100, steplengthmean = 0, steplengthsd = 100000000)#
#
# Plot map:#
map(xlim=c(-10, 10), ylim=c(-10, 10))#
#
for(i in 1:length(out)) {#
#
lines(edges_list[[i]][2, ], edges_list[[i]][3, ], col=rainbow(length(out))[i])#
#
}#
#
# For 1000 random walk steps:#
#for(i in 1:1000) {#
	# Take a random step and store new coordinates:#
	#lonlat2 <- unlist(EndPoint(lonlat[2], lonlat[1], runif(1, 0, 360), abs(rnorm(1, 0, 100)))[c(2, 1)])#
	# Plot coordinates on sphere in rainbow colour order:#
	#lines()#
	# Update lonlat ready for next step:#
	#lonlat <- lonlat2#
#}
# Add and load the Claddis package into R:#
library(devtools)#
install_github("graemetlloyd/Claddis")#
library(Claddis)#
#
# Load libraries:#
library(dispeRse)#
install.packages(c("ape", "maps"), dependencies=T)#
library(ape)#
library(maps)#
#
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 100, steplengthmean = 0, steplengthsd = 1000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 100, steplengthmean = 0, steplengthsd = 1000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 100, steplengthmean = 0, steplengthsd = 1000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 10, steplengthmean = 0, steplengthsd = 1000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
tree
plot(tree)
slon = 0
slat = 0
niter = 1000
steplengthmean = 0
niter = 10
steplengthsd = 100
require(Claddis)
# Establish root node number:#
	root_node <- Ntip(tree) + 1#
	# Get maximum path length and store as root age:#
	tree$root.time <- max(diag(vcv(tree)))#
	# Get step times:#
	step_times <- seq(tree$root.time, 0, length.out=niter)#
#
	# Get step size:#
	step_size <- abs(diff(step_times)[1])#
	# Get node ages:#
	node_ages <- GetNodeAges(tree)#
	# Get matrix of beginning and end ages for branches:#
	edge_ages <- cbind(node_ages[tree$edge[, 1]], node_ages[tree$edge[, 2]], dimnames=c(c(), c()))#
	# Matrix to store beginning and end points for each branch:#
	end_points_matrix <- matrix(NA, ncol=4, nrow=nrow(tree$edge), dimnames=list(c(), c("Begin_lon", "Begin_lat", "End_lon", "End_lat")))#
	# Get starting edges:	#
	start_edges <- which(tree$edge[, 1] == root_node)#
	# Create edges list:#
	edges_list <- as.list(c(1:nrow(tree$edge)))
# Sub-function to random walk along a single branch:#
	BranchWalker <- function(slat = 0, slon = 0, step_times, step_size, edge_start_time, edge_end_time, steplengthmean = steplengthmean, steplengthsd = steplengthsd) {#
		# Get first step present on branch:#
		start_step <- min(which(edge_start_time >= step_times))#
		# Get last step present on branch:#
		end_step <- max(which(edge_end_time <= step_times))#
		# Case if branch starts at step value:#
		if((edge_start_time - step_times[start_step]) == 0) {#
			# Set starting longitude as input longitude:#
			start_lon <- slon#
			# Set starting longitude as input latitude:#
			start_lat <- slat#
		# Case if branch starts before a step value:#
		} else {#
			# Calculate fraction of a step being performed:#
			step_fraction <- edge_start_time - step_times[start_step]#
			# Make first step to join branch beginning to first step:#
			first_step <- EndPoint(slon = slon, slat = slat, bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record starting longitude:#
			start_lon <- first_step$long#
			# Record starting latitude:#
			start_lat <- first_step$lat#
		}#
		# Create step matrix to store results:#
		step_matrix <- matrix(nrow = 3, ncol = end_step - start_step + 1, dimnames=list(c("step_time", "step_long", "step_lat"), c(start_step:end_step)))#
		# Fill in step times:#
		step_matrix[1, ] <- step_times[start_step:end_step]#
		# For each step:#
		for(i in start_step:end_step) {#
			# Record starting longitude:#
			step_matrix[2, match(i, colnames(step_matrix))] <- start_lon#
			# Record starting latitude:#
			step_matrix[3, match(i, colnames(step_matrix))] <- start_lat#
			# Make next step:#
			next_step <- EndPoint(slon = start_lon, slat = start_lat, bearing = runif(1, 0, 360), distance = abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Update starting longitude:#
			start_lon <- next_step$long#
			# Update starting latitude:#
			start_lat <- next_step$lat#
		}#
		# Case if branch ends at step value:#
		if((step_times[end_step] - edge_end_time) == 0) {#
			# Set ending longitude as last value in step matrix:#
			elon <- step_matrix[2, as.character(end_step)]#
			# Set ending latitude as last value in step matrix:#
			elat <- step_matrix[3, as.character(end_step)]#
		# Case if branch ends after a step value:#
		} else {#
			# Calculate fraction of a step rom last step to end of branch:#
			step_fraction <- (step_times[end_step] - edge_end_time) / step_size#
			# Make actual last step to end of branch:#
			last_step <- EndPoint(slon = step_matrix[2, as.character(end_step)], slat = step_matrix[3, as.character(end_step)], bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Record ending longitude:#
			elon <- last_step$long#
			# Record ending latitude:#
			elat <- last_step$lat			#
		}#
		# Compile output:#
		output <- cbind(c(edge_start_time, slon, slat), step_matrix, c(edge_end_time, elon, elat))#
		# Update row names:#
		rownames(output) <- c("step_time", "step_long", "step_lat")#
		# Update column names:#
		colnames(output)[1] <- "begin"#
		# Update column names:#
		colnames(output)[ncol(output)] <- "end"#
		# Return output:#
		return(output)#
	}#
	# For each starting (root connected) edge:#
	for(i in start_edges) {#
		# Get step_matrix for branch and add to edges_list:#
		edges_list[[i]] <- BranchWalker(slat, slon, step_times, step_size, edge_ages[i, 1], edge_ages[i, 2], steplengthmean, steplengthsd)#
		# Add end points of branches to end points matrix:#
		end_points_matrix[i, ] <- c(edges_list[[i]][2:3, "begin"], edges_list[[i]][2:3, "end"])#
	}
edges_list
# As long as there are branches that have not been walked along:#
	while(any(is.na(end_points_matrix))) {#
		# Find an edge that has starting point available:#
		next_available_edge <- which(is.na(end_points_matrix[, 1]))[match(intersect(tree$edge[which(is.na(end_points_matrix[, 1])), 1], tree$edge[which(!is.na(end_points_matrix[, 1])), 2]), tree$edge[which(is.na(end_points_matrix[, 1])), 1])][1]#
		# Find preceding edge (which has starting values for latitude and longitude at end):#
		preceding_edge <- match(tree$edge[next_available_edge, 1], tree$edge[, 2])#
		# Randomly walk along branch and store results:#
		edges_list[[next_available_edge]] <- BranchWalker(edges_list[[preceding_edge]]["step_lat", "end"], edges_list[[preceding_edge]]["step_long", "end"], step_times, step_size, edge_ages[next_available_edge, 1], edge_ages[next_available_edge, 2], steplengthmean, steplengthsd)#
#
		# Add end points of branches to end points matrix:#
		end_points_matrix[next_available_edge, ] <- c(edges_list[[next_available_edge]][2:3, "begin"], edges_list[[next_available_edge]][2:3, "end"])#
#
	}
next_available_edge
end_points_matrix
# Find an edge that has starting point available:#
		next_available_edge <- which(is.na(end_points_matrix[, 1]))[match(intersect(tree$edge[which(is.na(end_points_matrix[, 1])), 1], tree$edge[which(!is.na(end_points_matrix[, 1])), 2]), tree$edge[which(is.na(end_points_matrix[, 1])), 1])][1]#
		# Find preceding edge (which has starting values for latitude and longitude at end):#
		preceding_edge <- match(tree$edge[next_available_edge, 1], tree$edge[, 2])
BranchWalker(edges_list[[preceding_edge]]["step_lat", "end"], edges_list[[preceding_edge]]["step_long", "end"], step_times, step_size, edge_ages[next_available_edge, 1], edge_ages[next_available_edge, 2], steplengthmean, steplengthsd)
slat<-edges_list[[preceding_edge]]["step_lat", "end"]
slon<-edges_list[[preceding_edge]]["step_long", "end"]
step_times
step_size
edge_ages[next_available_edge, 1]
edge_start_time<-edge_ages[next_available_edge, 1]
edge_end_time<-edge_ages[next_available_edge, 2]
# Get first step present on branch:#
		start_step <- min(which(edge_start_time >= step_times))#
		# Get last step present on branch:#
		end_step <- max(which(edge_end_time <= step_times))
start_step
end_step
(edge_start_time - step_times[start_step]) == 0
start_step <- end_step
start_step <= end_step
# Get first step present on branch:#
		start_step <- min(which(edge_start_time >= step_times))#
		# Get last step present on branch:#
		end_step <- max(which(edge_end_time <= step_times))
start_step <= end_step
start_step >= end_step
library(geosphere)
?destPoint
# Get first step present on branch:#
		start_step <- min(which(edge_start_time >= step_times))#
		# Get last step present on branch:#
		end_step <- max(which(edge_end_time <= step_times))#
		# Case if there is at least one step point along branch:#
		if(start_step >= end_step) {#
			# Case if branch starts at step value:#
			if((edge_start_time - step_times[start_step]) == 0) {#
				# Set starting longitude as input longitude:#
				start_lon <- slon#
				# Set starting longitude as input latitude:#
				start_lat <- slat#
			# Case if branch starts before a step value:#
			} else {#
				# Calculate fraction of a step being performed:#
				step_fraction <- edge_start_time - step_times[start_step]#
				# Make first step to join branch beginning to first step:#
				first_step <- EndPoint(slon = slon, slat = slat, bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
				# Record starting longitude:#
				start_lon <- first_step$long#
				# Record starting latitude:#
				start_lat <- first_step$lat#
			}#
			# Create step matrix to store results:#
			step_matrix <- matrix(nrow = 3, ncol = end_step - start_step + 1, dimnames=list(c("step_time", "step_long", "step_lat"), c(start_step:end_step)))#
			# Fill in step times:#
			step_matrix[1, ] <- step_times[start_step:end_step]#
			# For each step:#
			for(i in start_step:end_step) {#
				# Record starting longitude:#
				step_matrix[2, match(i, colnames(step_matrix))] <- start_lon#
				# Record starting latitude:#
				step_matrix[3, match(i, colnames(step_matrix))] <- start_lat#
				# Make next step:#
				next_step <- EndPoint(slon = start_lon, slat = start_lat, bearing = runif(1, 0, 360), distance = abs(rnorm(1, steplengthmean, steplengthsd)))#
				# Update starting longitude:#
				start_lon <- next_step$long#
				# Update starting latitude:#
				start_lat <- next_step$lat#
			}#
			# Case if branch ends at step value:#
			if((step_times[end_step] - edge_end_time) == 0) {#
				# Set ending longitude as last value in step matrix:#
				elon <- step_matrix[2, as.character(end_step)]#
				# Set ending latitude as last value in step matrix:#
				elat <- step_matrix[3, as.character(end_step)]#
			# Case if branch ends after a step value:#
			} else {#
				# Calculate fraction of a step rom last step to end of branch:#
				step_fraction <- (step_times[end_step] - edge_end_time) / step_size#
				# Make actual last step to end of branch:#
				last_step <- EndPoint(slon = step_matrix[2, as.character(end_step)], slat = step_matrix[3, as.character(end_step)], bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
				# Record ending longitude:#
				elon <- last_step$long#
				# Record ending latitude:#
				elat <- last_step$lat			#
			}#
			# Compile output:#
			output <- cbind(c(edge_start_time, slon, slat), step_matrix, c(edge_end_time, elon, elat))#
			# Update row names:#
			rownames(output) <- c("step_time", "step_long", "step_lat")#
			# Update column names:#
			colnames(output)[1] <- "begin"#
			# Update column names:#
			colnames(output)[ncol(output)] <- "end"#
		# Case if no steps on branch:#
		} else {#
		}
start_step
end_step
start_step >= end_step
# Get first step present on branch:#
		start_step <- min(which(edge_start_time >= step_times))#
		# Get last step present on branch:#
		end_step <- max(which(edge_end_time <= step_times))#
		# Case if there is at least one step point along branch:#
		if(start_step <= end_step) {#
			# Case if branch starts at step value:#
			if((edge_start_time - step_times[start_step]) == 0) {#
				# Set starting longitude as input longitude:#
				start_lon <- slon#
				# Set starting longitude as input latitude:#
				start_lat <- slat#
			# Case if branch starts before a step value:#
			} else {#
				# Calculate fraction of a step being performed:#
				step_fraction <- edge_start_time - step_times[start_step]#
				# Make first step to join branch beginning to first step:#
				first_step <- EndPoint(slon = slon, slat = slat, bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
				# Record starting longitude:#
				start_lon <- first_step$long#
				# Record starting latitude:#
				start_lat <- first_step$lat#
			}#
			# Create step matrix to store results:#
			step_matrix <- matrix(nrow = 3, ncol = end_step - start_step + 1, dimnames=list(c("step_time", "step_long", "step_lat"), c(start_step:end_step)))#
			# Fill in step times:#
			step_matrix[1, ] <- step_times[start_step:end_step]#
			# For each step:#
			for(i in start_step:end_step) {#
				# Record starting longitude:#
				step_matrix[2, match(i, colnames(step_matrix))] <- start_lon#
				# Record starting latitude:#
				step_matrix[3, match(i, colnames(step_matrix))] <- start_lat#
				# Make next step:#
				next_step <- EndPoint(slon = start_lon, slat = start_lat, bearing = runif(1, 0, 360), distance = abs(rnorm(1, steplengthmean, steplengthsd)))#
				# Update starting longitude:#
				start_lon <- next_step$long#
				# Update starting latitude:#
				start_lat <- next_step$lat#
			}#
			# Case if branch ends at step value:#
			if((step_times[end_step] - edge_end_time) == 0) {#
				# Set ending longitude as last value in step matrix:#
				elon <- step_matrix[2, as.character(end_step)]#
				# Set ending latitude as last value in step matrix:#
				elat <- step_matrix[3, as.character(end_step)]#
			# Case if branch ends after a step value:#
			} else {#
				# Calculate fraction of a step rom last step to end of branch:#
				step_fraction <- (step_times[end_step] - edge_end_time) / step_size#
				# Make actual last step to end of branch:#
				last_step <- EndPoint(slon = step_matrix[2, as.character(end_step)], slat = step_matrix[3, as.character(end_step)], bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
				# Record ending longitude:#
				elon <- last_step$long#
				# Record ending latitude:#
				elat <- last_step$lat			#
			}#
			# Compile output:#
			output <- cbind(c(edge_start_time, slon, slat), step_matrix, c(edge_end_time, elon, elat))#
			# Update row names:#
			rownames(output) <- c("step_time", "step_long", "step_lat")#
			# Update column names:#
			colnames(output)[1] <- "begin"#
			# Update column names:#
			colnames(output)[ncol(output)] <- "end"#
		# Case if no steps on branch:#
		} else {#
		}
edge_start_time, edge_end_time
edge_start_time - edge_end_time
(edge_start_time - edge_end_time) / step_size
c(edge_start_time, edge_end_time, slon, slat, elon, elat)
# Calculate fraction of a step represented by branch:#
			step_fraction <- (edge_start_time - edge_end_time) / step_size#
			# Make fractional step proportioned by branch length:#
			branch_step <- EndPoint(slon = slon, slat = slat, bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Update starting longitude:#
			elon <- branch_step$long#
			# Update starting latitude:#
			elat <- branch_step$lat
c(edge_start_time, edge_end_time, slon, slat, elon, elat)
matrix(c(edge_start_time, edge_end_time, slon, slat, elon, elat), nrow=3)
matrix(c(edge_start_time, edge_end_time, slon, slat, elon, elat), nrow=3, byrow=TRUE)
branch_step
slat
slon
matrix(c(edge_start_time, edge_end_time, slon, elon, slat, elat), nrow=3, byrow=TRUE)
matrix(c(edge_start_time, edge_end_time, slon, elon, slat, elat), nrow=3, byrow=TRUE, dimnames=dimnames=list(c("step_time", "step_long", "step_lat"), c("begin", "end")))
matrix(c(edge_start_time, edge_end_time, slon, elon, slat, elat), nrow=3, byrow=TRUE, dimnames=list(c("step_time", "step_long", "step_lat"), c("begin", "end")))
#' Brownian motion (random walk) on a sphere#
#'#
#' Perform Brownian motion (a random walk) on a sphere.#
#'#
#' @param tree tree (as phylo object) to use#
#' @param slon starting longitude#
#' @param slat starting latitude#
#' @param niter number of time steps to use#
#' @param steplengthmean mean used for random walk draws#
#' @param steplengthsd standard deviation used for random walk draws#
#'#
#' @return A list of edges with matrices showing times and coordinates#
#' @keywords random walk#
#' @export#
#' @examples#
#' tree <- tree(10)#
#' TreeWalker(tree, slat = 0, slon = 0, niter = 1000, steplengthmean = 0, steplengthsd = 100)#
#'#
#
TreeWalker <- function(tree, slon = 0, slat = 0, niter = 1000, steplengthmean = 0, steplengthsd = 100) {#
# Add conditional to check tree is rooted!#
# Add Claddis to dependencies?#
# Hard to modify for changes in dispersal rate in future, not sure if can do anything about this though#
#
	require(Claddis)#
	# Establish root node number:#
	root_node <- Ntip(tree) + 1#
	# Get maximum path length and store as root age:#
	tree$root.time <- max(diag(vcv(tree)))#
	# Get step times:#
	step_times <- seq(tree$root.time, 0, length.out=niter)#
#
	# Get step size:#
	step_size <- abs(diff(step_times)[1])#
	# Get node ages:#
	node_ages <- GetNodeAges(tree)#
	# Get matrix of beginning and end ages for branches:#
	edge_ages <- cbind(node_ages[tree$edge[, 1]], node_ages[tree$edge[, 2]], dimnames=c(c(), c()))#
	# Matrix to store beginning and end points for each branch:#
	end_points_matrix <- matrix(NA, ncol=4, nrow=nrow(tree$edge), dimnames=list(c(), c("Begin_lon", "Begin_lat", "End_lon", "End_lat")))#
	# Get starting edges:	#
	start_edges <- which(tree$edge[, 1] == root_node)#
	# Create edges list:#
	edges_list <- as.list(c(1:nrow(tree$edge)))#
	# Sub-function to random walk along a single branch:#
	BranchWalker <- function(slon = 0, slat = 0, step_times, step_size, edge_start_time, edge_end_time, steplengthmean = steplengthmean, steplengthsd = steplengthsd) {#
		# Get first step present on branch:#
		start_step <- min(which(edge_start_time >= step_times))#
		# Get last step present on branch:#
		end_step <- max(which(edge_end_time <= step_times))#
		# Case if there is at least one step point along branch:#
		if(start_step <= end_step) {#
			# Case if branch starts at step value:#
			if((edge_start_time - step_times[start_step]) == 0) {#
				# Set starting longitude as input longitude:#
				start_lon <- slon#
				# Set starting longitude as input latitude:#
				start_lat <- slat#
			# Case if branch starts before a step value:#
			} else {#
				# Calculate fraction of a step being performed:#
				step_fraction <- edge_start_time - step_times[start_step]#
				# Make first step to join branch beginning to first step:#
				first_step <- EndPoint(slon = slon, slat = slat, bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
				# Record starting longitude:#
				start_lon <- first_step$long#
				# Record starting latitude:#
				start_lat <- first_step$lat#
			}#
			# Create step matrix to store results:#
			step_matrix <- matrix(nrow = 3, ncol = end_step - start_step + 1, dimnames=list(c("step_time", "step_long", "step_lat"), c(start_step:end_step)))#
			# Fill in step times:#
			step_matrix[1, ] <- step_times[start_step:end_step]#
			# For each step:#
			for(i in start_step:end_step) {#
				# Record starting longitude:#
				step_matrix[2, match(i, colnames(step_matrix))] <- start_lon#
				# Record starting latitude:#
				step_matrix[3, match(i, colnames(step_matrix))] <- start_lat#
				# Make next step:#
				next_step <- EndPoint(slon = start_lon, slat = start_lat, bearing = runif(1, 0, 360), distance = abs(rnorm(1, steplengthmean, steplengthsd)))#
				# Update starting longitude:#
				start_lon <- next_step$long#
				# Update starting latitude:#
				start_lat <- next_step$lat#
			}#
			# Case if branch ends at step value:#
			if((step_times[end_step] - edge_end_time) == 0) {#
				# Set ending longitude as last value in step matrix:#
				elon <- step_matrix[2, as.character(end_step)]#
				# Set ending latitude as last value in step matrix:#
				elat <- step_matrix[3, as.character(end_step)]#
			# Case if branch ends after a step value:#
			} else {#
				# Calculate fraction of a step from last step to end of branch:#
				step_fraction <- (step_times[end_step] - edge_end_time) / step_size#
				# Make actual last step to end of branch:#
				last_step <- EndPoint(slon = step_matrix[2, as.character(end_step)], slat = step_matrix[3, as.character(end_step)], bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
				# Record ending longitude:#
				elon <- last_step$long#
				# Record ending latitude:#
				elat <- last_step$lat			#
			}#
			# Compile output:#
			output <- cbind(c(edge_start_time, slon, slat), step_matrix, c(edge_end_time, elon, elat))#
			# Update row names:#
			rownames(output) <- c("step_time", "step_long", "step_lat")#
			# Update column names:#
			colnames(output)[1] <- "begin"#
			# Update column names:#
			colnames(output)[ncol(output)] <- "end"#
		# Case if no steps on branch:#
		} else {#
			# Calculate fraction of a step represented by branch:#
			step_fraction <- (edge_start_time - edge_end_time) / step_size#
			# Make fractional step proportioned by branch length:#
			branch_step <- EndPoint(slon = slon, slat = slat, bearing = runif(1, 0, 360), distance = step_fraction * abs(rnorm(1, steplengthmean, steplengthsd)))#
			# Update starting longitude:#
			elon <- branch_step$long#
			# Update starting latitude:#
			elat <- branch_step$lat#
			# Compile output:#
			output <- matrix(c(edge_start_time, edge_end_time, slon, elon, slat, elat), nrow=3, byrow=TRUE, dimnames=list(c("step_time", "step_long", "step_lat"), c("begin", "end")))#
		}#
		# Return output:#
		return(output)#
	}#
	# For each starting (root connected) edge:#
	for(i in start_edges) {#
		# Get step_matrix for branch and add to edges_list:#
		edges_list[[i]] <- BranchWalker(slon, slat, step_times, step_size, edge_ages[i, 1], edge_ages[i, 2], steplengthmean, steplengthsd)#
		# Add end points of branches to end points matrix:#
		end_points_matrix[i, ] <- c(edges_list[[i]][2:3, "begin"], edges_list[[i]][2:3, "end"])#
	}#
#
	# As long as there are branches that have not been walked along:#
	while(any(is.na(end_points_matrix))) {#
		# Find an edge that has starting point available:#
		next_available_edge <- which(is.na(end_points_matrix[, 1]))[match(intersect(tree$edge[which(is.na(end_points_matrix[, 1])), 1], tree$edge[which(!is.na(end_points_matrix[, 1])), 2]), tree$edge[which(is.na(end_points_matrix[, 1])), 1])][1]#
		# Find preceding edge (which has starting values for latitude and longitude at end):#
		preceding_edge <- match(tree$edge[next_available_edge, 1], tree$edge[, 2])#
		# Randomly walk along branch and store results:#
		edges_list[[next_available_edge]] <- BranchWalker(edges_list[[preceding_edge]]["step_long", "end"], edges_list[[preceding_edge]]["step_lat", "end"], step_times, step_size, edge_ages[next_available_edge, 1], edge_ages[next_available_edge, 2], steplengthmean, steplengthsd)#
#
		# Add end points of branches to end points matrix:#
		end_points_matrix[next_available_edge, ] <- c(edges_list[[next_available_edge]][2:3, "begin"], edges_list[[next_available_edge]][2:3, "end"])#
#
	}#
	# Return edges list:#
	return(edges_list)#
}
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 100, steplengthmean = 0, steplengthsd = 1000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 10, steplengthmean = 0, steplengthsd = 1000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 10, steplengthmean = 0, steplengthsd = 10000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 10, steplengthmean = 0, steplengthsd = 10000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 10, steplengthmean = 0, steplengthsd = 1000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 10, steplengthmean = 0, steplengthsd = 1000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 10, steplengthmean = 0, steplengthsd = 1000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 10, steplengthmean = 0, steplengthsd = 1000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 10, steplengthmean = 0, steplengthsd = 1000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 10, steplengthmean = 0, steplengthsd = 1000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 10, steplengthmean = 0, steplengthsd = 1000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 10, steplengthmean = 0, steplengthsd = 1000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 10, steplengthmean = 0, steplengthsd = 1000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 10, steplengthmean = 0, steplengthsd = 2000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 10, steplengthmean = 0, steplengthsd = 2000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 10, steplengthmean = 0, steplengthsd = 2000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 10, steplengthmean = 0, steplengthsd = 2000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 5, steplengthmean = 0, steplengthsd = 2000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 5, steplengthmean = 0, steplengthsd = 10000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 5, steplengthmean = 0, steplengthsd = 10000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slat = 0, slon = 0, niter = 5, steplengthmean = 0, steplengthsd = 10000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Add and load the Claddis package into R:#
library(devtools)#
install_github("graemetlloyd/Claddis")#
library(Claddis)#
#
# Load libraries:#
library(dispeRse)#
install.packages(c("ape", "maps"), dependencies=T)#
library(ape)#
library(maps)#
#
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slon = 0, slat = 0, niter = 100, steplengthmean = 0, steplengthsd = 1000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Add and load the Claddis package into R:#
library(devtools)#
install_github("graemetlloyd/Claddis")#
library(Claddis)#
#
# Load libraries:#
library(dispeRse)#
install.packages(c("ape", "maps"), dependencies=T)#
library(ape)#
library(maps)#
#
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalker(tree, slon = 0, slat = 0, niter = 100, steplengthmean = 0, steplengthsd = 1000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Load the devtools package into R:#
library(devtools)#
#
# Install the dispeRse package from github:#
install_github("laurasoul/dispeRse")#
#
# Load the dispeRse package into R:#
library(dispeRse)
# Load libraries:#
library(dispeRse)#
install.packages("sphereplot", dependencies=T)#
library(sphereplot)#
#
# Plot spherical grid:#
rgl.sphgrid()#
#
# Start at North Pole:#
lonlat <- c(0, 90)#
#
# For 1000 random walk steps:#
for(i in 1:1000) {#
#
    # Take a random step and store new coordinates:#
    lonlat2 <- unlist(EndPoint(lonlat[1], lonlat[2], runif(1, 0, 360), abs(rnorm(1, 0, 100)))[c(2, 1)])#
#
    # Plot coordinates on sphere in rainbow colour order:#
    rgl.sphpoints(lonlat2[1], lonlat2[2], 1, deg=TRUE, col=rainbow(1000)[i], cex=2)#
#
    # Update lonlat ready for next step:#
    lonlat <- lonlat2#
#
}
# Plot spherical grid:#
rgl.sphgrid()#
#
# Start at North Pole:#
lonlat <- c(0, 90)#
#
# For 1000 random walk steps:#
for(i in 1:1000) {#
#
    # Take a random step and store new coordinates:#
    lonlat2 <- unlist(EndPoint(lonlat[1], lonlat[2], runif(1, 0, 360), abs(rnorm(1, 0, 100)))[c(1, 2)])#
#
    # Plot coordinates on sphere in rainbow colour order:#
    rgl.sphpoints(lonlat2[1], lonlat2[2], 1, deg=TRUE, col=rainbow(1000)[i], cex=2)#
#
    # Update lonlat ready for next step:#
    lonlat <- lonlat2#
#
}
EndPoint
setwd("~/Documents/Publications/in prep/dispeRse")
library(roxygen2)
roxygenise()
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalkerContinuous(tree, slon = 0, slat = 0, niter = 100, steplengthmean = 0, steplengthsd = 1000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
library(devtools)#
#
# Install the dispeRse package from github:#
install_github("laurasoul/dispeRse")#
#
# Load the dispeRse package into R:#
library(dispeRse)
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalkerContinuous(tree, slon = 0, slat = 0, niter = 100, steplengthmean = 0, steplengthsd = 1000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalkerContinuous(tree, slon = 0, slat = 0, niter = 100, steplengthmean = 0, steplengthsd = 1000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
# Generate random 50-taxon tree:#
tree <- rtree(10)#
#
# Run function setting start point at equator-Greenwich Meridian intersection:#
out <- TreeWalkerContinuous(tree, slon = 0, slat = 0, niter = 100, steplengthmean = 0, steplengthsd = 1000)#
#
# Plot map:#
map()#
#
# For each branch:#
for(i in 1:length(out)) {#
#
    # Plot walk along branch:#
    lines(out[[i]][2, ], out[[i]][3, ], col=rainbow(length(out))[i])#
#
}
