Gauthier1986$ordering
Michaux1989
Gauthier1986$step.matrices <- NULL
Gauthier1986
Gauthier1986[[7]] <- NULL
names(Gauthier1986)[7]
names(Gauthier1986)[[7]]
names(Gauthier1986)
Gauthier1986
Gauthier1986[[7]] <- "q"
Gauthier1986[[8]] <- "q"
Gauthier1986
names(Gauthier1986)
names(Gauthier1986)[c(7, 8)]
names(Gauthier1986)[c(7, 8)] <- c("step.matrices", "symbols")
names(Gauthier1986)
names(Michaux1989)
Gauthier1986$step.matrices <- NULL
Gauthier1986
Gauthier1986$matrix
Michaux1989$
symbols
Gauthier1986
Gauthier1986$symbolcs
Gauthier1986$symbols
Gauthier1986$symbols <- c("0", "1")
Gauthier1986
save(Gauthier1986, file="~/Documents/Publications/in prep/Claddis/Claddis/data/Gauthier1986_2.RData")
load('~/Documents/Publications/in prep/Claddis/Claddis/data/Gauthier1986_2.RData')
Gauthier1986_2
objects()
Gauthier1986
load('~/Documents/Publications/in prep/Claddis/Claddis/data/Gauthier1986_2.RData')
objects()
Gauthier1986
names(Gauthier1986)
libary(Claddis)
library(Claddis)
Michaux1989
names(Michaux1989)
names(Gauthier1986)
Gauthier1986[[8]] <- "q"
names(Gauthier1986)
names(Gauthier1986)[8]
names(Gauthier1986)[8] <- "step.matrices"
names(Gauthier1986)
Gauthier1986[c("header", "matrix", "ordering", "weights", "max.vals", "min.vals", "step.matrices", "symbols")]
Gauthier1986 <- Gauthier1986[c("header", "matrix", "ordering", "weights", "max.vals", "min.vals", "step.matrices", "symbols")]
names(Gauthier1986)
names(Michaux1989)
Gauthier1986
Gauthier1986$step.matrices
Gauthier1986$step.matrices <- NULL
Gauthier1986$step.matrices
Gauthier1986
Gauthier1986[[8]] <- "q"
names(Gauthier1986)[8] <- "step.matrices"
Gauthier1986 <- Gauthier1986[c("header", "matrix", "ordering", "weights", "max.vals", "min.vals", "step.matrices", "symbols")]
Gauthier1986
Gauthier1986$step.matrices
Gauthier1986$step.matrices[1]
Gauthier1986$step.matrices[1] <- NULL
Michaux1989
Michaux1989$step.matrices
Gauthier1986$step.matrices
Gauthier1986$step.matrices <- Michaux1989$step.matrices
authier1986
Gauthier1986
ReadMorphNexus("file:///Users/gral/Documents/Homepage/www.graemetlloyd.com/nexus/Gauthier_1986a.nex")
Gauthier1986 <- ReadMorphNexus("file:///Users/gral/Documents/Homepage/www.graemetlloyd.com/nexus/Gauthier_1986a.nex")
Gauthier1986$heading
Gauthier1986$header
Gauthier1986$header <- ""
Gauthier1986
Michaux1989
Michaux1989$header <- ""
Michaux1989
save(Michaux1989, file="~/Documents/Publications/in prep/Claddis/Claddis/data/Michaux1989.RData")
save(Gauthier1986, file="~/Documents/Publications/in prep/Claddis/Claddis/data/Gauthier1986.RData")
library(Claddis)
Michaux1986
Michaux1989
Gauthier1986
MorphDistMatrix <- function(morph.matrix, transform.proportional.distances="arcsine_sqrt") {#
#
  # Check format of transform.proportional.distances:#
  if(transform.proportional.distances != "none" && transform.proportional.distances != "sqrt" && transform.proportional.distances != "arcsine_sqrt") {#
#
    # Give error if something other than three possible settings is given:#
    stop("ERROR: transform.proportional.distances must be one of \"none\", \"sqrt\", or \"arcsine_sqrt\".")#
#
  }#
#
  # Isolate ordering element of morphology matrix:#
  ordering <- morph.matrix$ordering#
#
  # Isolate max values element of morphology matrix:#
  max.vals <- morph.matrix$max.vals#
  # Isolate min values element of morphology matrix:#
  min.vals <- morph.matrix$min.vals#
  # Isolate weighting element of morphology matrix:#
  weights <- morph.matrix$weights#
  # Isolate character-taxon matrix element of morphology matrix:#
  morph.matrix <- morph.matrix$matrix#
#
  # Create empty vectors to store S and W value for Wills 2001 equations (1 and 2):#
  differences <- maximum.differences <- vector(mode="numeric")#
  # Distance matrices for storing:#
  comp.char.matrix <- gower.dist.matrix <- max.dist.matrix <- dist.matrix <- matrix(0, nrow=length(rownames(morph.matrix)), ncol=length(rownames(morph.matrix)))#
  # Fill comparable characters diagonal:#
  for(i in 1:length(morph.matrix[, 1])) comp.char.matrix[i,i] <- length(morph.matrix[i, ]) - length(grep(TRUE, is.na(morph.matrix[i, ])))#
#
  # Set up empty matrix for storing data to calculate the Generalised Euclidean Distance of Wills (2001):#
  GED.data <- matrix(nrow=0, ncol=ncol(morph.matrix))#
#
  # Go through matrix rows:#
  for(i in 1:(length(morph.matrix[, 1]) - 1)) {#
    # Go through matrix columns:#
    for(j in (i + 1):length(morph.matrix[, 1])) {#
      # Get just the comparable characters (those coded for both taxa):#
      compchar <- intersect(grep(TRUE, !is.na(morph.matrix[rownames(morph.matrix)[i], ])), grep(TRUE, !is.na(morph.matrix[rownames(morph.matrix)[j], ])))#
      # Get comparable characters for ith taxon:#
      firstrow <- morph.matrix[rownames(morph.matrix)[i], compchar]#
#
      # Get comparable characters for jth taxon:#
      secondrow <- morph.matrix[rownames(morph.matrix)[j], compchar]#
      # Deal with polymorphic characters (if present):#
      if(length(grep("&", unique(c(firstrow, secondrow)))) > 0) {#
        # Find ampersands (polymorphisms):#
        ampersand.elements <- sort(c(grep("&", firstrow), grep("&", secondrow)))#
        # Go through each polymorphic character:#
        for(k in 1:length(ampersand.elements)) {#
          # Find out if two codings overlap once all polymorphism resolutions are considered:#
          intersection.value <- intersect(strsplit(firstrow[ampersand.elements[k]], "&")[[1]], strsplit(secondrow[ampersand.elements[k]], "&")[[1]])#
          # Case if polymorphic and non-polymorphic values overlap:#
          if(length(intersection.value) > 0) {#
            # Set ith value as zero (no difference):#
            firstrow[ampersand.elements[k]] <- 0#
#
            # Set jth value as zero (no difference)#
            secondrow[ampersand.elements[k]] <- 0#
#
          }#
          # Case if polymorphic and non-polymorphic values do not overlap:#
          if(length(intersection.value) == 0) {#
            # Case if character is unordered (max difference is 1):#
            if(ordering[compchar[ampersand.elements[k]]] == "unord") {#
              # Set ith value as zero:#
              firstrow[ampersand.elements[k]] <- 0#
#
              # Set jth value as 1 (making the ij difference equal to one):#
              secondrow[ampersand.elements[k]] <- 1#
#
            }#
            # Case if character is ordered (max difference is > 1):#
            if(ordering[compchar[ampersand.elements[k]]] == "ord") {#
              # Get first row value(s):#
              firstrowvals <- as.numeric(strsplit(firstrow[ampersand.elements[k]], "&")[[1]])#
              # Get second row value(s):#
              secondrowvals <- as.numeric(strsplit(secondrow[ampersand.elements[k]], "&")[[1]])#
              # Make mini distance matrix:#
              poly.dist.mat <- matrix(0, nrow=length(firstrowvals), ncol=length(secondrowvals))#
              # Go through each comparison:#
              for(l in 1:length(firstrowvals)) {#
                # Record absolute difference:#
                for(m in 1:length(secondrowvals)) poly.dist.mat[l, m] <- sqrt((firstrowvals[l] - secondrowvals[m]) ^ 2)#
#
              }#
              # Set first value as zero:#
              firstrow[ampersand.elements[k]] <- 0#
              # Set second value as minimum possible difference:#
              secondrow[ampersand.elements[k]] <- min(poly.dist.mat)#
#
            }#
#
          }#
#
        }#
#
      }#
      # Get the absolute difference between the two rows:#
      raw.diffs <- diffs <- abs(as.numeric(firstrow) - as.numeric(secondrow))#
      # If there are differences greater than 1 for unordered characters then rescore as 1:#
      if(length(grep(TRUE, diffs > 1)) > 0) diffs[grep(TRUE, diffs > 1)[grep(TRUE, ordering[compchar[grep(TRUE, diffs > 1)]] == "unord")]] <- 1#
#
      # Find the incomparable characters:#
      incompchar <- setdiff(1:ncol(morph.matrix), compchar)#
#
      # Store data for GED with NAs for missing distances:#
      GED.data <- rbind(GED.data, rbind(c(diffs, rep(NA, length(incompchar))), c(weights[compchar], weights[incompchar])))#
#
      # Get weighted differences:#
      diffs <- as.numeric(weights[compchar]) * diffs#
#
      # Get raw Euclidean distance:#
      raw.dist <- dist(rbind(diffs, rep(0, length(diffs))), method="euclidean")#
#
      # Work out maximum difference (again, checked against ordering) using compchar characters only:#
      raw.maxdiffs <- maxdiffs <- as.numeric(max.vals[compchar]) - as.numeric(min.vals[compchar])#
#
      # Correct maximum possible differences for unordered characters:#
      if(length(grep(TRUE, maxdiffs > 1)) > 0) maxdiffs[grep(TRUE, maxdiffs > 1)[grep(TRUE, ordering[compchar[grep(TRUE, maxdiffs > 1)]] == "unord")]] <- 1#
#
      # Get vector of maximum differences (corrected for character weights):#
      maxdiffs <- as.numeric(weights[compchar]) * maxdiffs#
#
      # Store raw distance:#
      dist.matrix[i, j] <- dist.matrix[j, i] <- raw.dist#
#
      # Store Gower distance:#
      gower.dist.matrix[i, j] <- gower.dist.matrix[j, i] <- sum(diffs) / sum(weights[compchar])#
#
      # Store maximum-rescaled distance:#
      max.dist.matrix[i, j] <- max.dist.matrix[j, i] <- sum(diffs) / sum(maxdiffs)#
#
      # Store N comparable characters:#
      comp.char.matrix[i, j] <- comp.char.matrix[j, i] <- length(compchar)#
#
      # Add to maximum differences (S_ijk * W_ijk in equation 1 of Wills 2001):#
      differences <- c(differences, diffs)#
#
      # Add to maximum differences (S_ijk_max * W_ijk in equation 1 of Wills 2001):#
      maximum.differences <- c(maximum.differences, maxdiffs)#
#
    }#
#
  }#
#
  # Calculated weighted mean univariate distance for calculating GED (equation 2 in Wills 2001):#
  S_ijk_bar <- sum(differences) / sum(maximum.differences)#
#
  # Replace missing distances with S_ijk_bar (i.e., results of equation 2 in Wills 2001 into equation 1 of Wills 2001):#
  GED.data[is.na(GED.data)] <- S_ijk_bar#
#
  # Isolate the distances:#
  S_ijk <- GED.data[grep(TRUE, (1:nrow(GED.data) %% 2) == 1), ]#
#
  # Isolate the weights:#
  W_ijk <- GED.data[grep(TRUE, (1:nrow(GED.data) %% 2) == 0), ]#
#
  # Calculate the GED (equation 1 of Wills 2001) for each pairwise comparison (ij):#
  GED_ij <- sqrt(apply(W_ijk * (S_ijk ^ 2), 1, sum))#
#
  # Create empty GED distance matrix:#
  GED.dist.matrix <- matrix(0, nrow=nrow(morph.matrix), ncol=nrow(morph.matrix))#
#
  # Set initial value for counter:#
  counter <- 1#
#
  # Go through matrix rows:#
  for(i in 1:(length(morph.matrix[, 1]) - 1)) {#
#
    # Go through matrix columns:#
    for(j in (i + 1):length(morph.matrix[, 1])) {#
#
      # Store distance:#
      GED.dist.matrix[i, j] <- GED.dist.matrix[j, i] <- GED_ij[counter]#
#
      # Update counter:#
      counter <- counter + 1#
#
    }#
#
  }#
  # Set diagonals as zero:#
  diag(gower.dist.matrix) <- diag(max.dist.matrix) <- 0#
#
  # Add row and column names (taxa) to distance matrices:#
  rownames(comp.char.matrix) <- colnames(comp.char.matrix) <- rownames(GED.dist.matrix) <- colnames(GED.dist.matrix) <- rownames(gower.dist.matrix) <- colnames(gower.dist.matrix) <- rownames(max.dist.matrix) <- colnames(max.dist.matrix) <- rownames(dist.matrix) <- colnames(dist.matrix) <- rownames(morph.matrix)#
#
# If transformation option is not "none":#
if(transform.proportional.distances != "none") {#
#
  # Convert all Gower values to 0 to 1 scale then take arcsine of sqrt to get values that better approximate a normal distribution:#
  gower.dist.matrix <- matrix(as.numeric(gsub(NaN, NA, asin(sqrt(gower.dist.matrix / max(sort(gower.dist.matrix)))))), nrow=nrow(gower.dist.matrix), dimnames=list(rownames(gower.dist.matrix), rownames(gower.dist.matrix)))#
#
  # Take arcsine square root of all MOD dist values:#
  max.dist.matrix <- matrix(as.numeric(gsub(NaN, NA, asin(sqrt(max.dist.matrix)))), nrow=nrow(max.dist.matrix), dimnames=list(rownames(max.dist.matrix), rownames(max.dist.matrix)))#
#
}#
#
  # Compile results as a list:#
  result <- list(dist.matrix, GED.dist.matrix, gower.dist.matrix, max.dist.matrix, comp.char.matrix)#
  # Add names to results list:#
  names(result) <- c("raw.dist.matrix", "GED.dist.matrix", "gower.dist.matrix", "max.dist.matrix", "comp.char.matrix")#
  # Output result:#
  return(result)#
#
}
MorphDistMatrix(Michaux1989, transform.proportional.distances="none")
MorphDistMatrix(Gauthier1986, transform.proportional.distances="none")
MorphDistMatrix <- function(morph.matrix, transform.proportional.distances="arcsine_sqrt") {#
#
  # Check format of transform.proportional.distances:#
  if(transform.proportional.distances != "none" && transform.proportional.distances != "sqrt" && transform.proportional.distances != "arcsine_sqrt") {#
#
    # Give error if something other than three possible settings is given:#
    stop("ERROR: transform.proportional.distances must be one of \"none\", \"sqrt\", or \"arcsine_sqrt\".")#
#
  }#
#
  # Isolate ordering element of morphology matrix:#
  ordering <- morph.matrix$ordering#
#
  # Isolate max values element of morphology matrix:#
  max.vals <- morph.matrix$max.vals#
  # Isolate min values element of morphology matrix:#
  min.vals <- morph.matrix$min.vals#
  # Isolate weighting element of morphology matrix:#
  weights <- morph.matrix$weights#
  # Isolate character-taxon matrix element of morphology matrix:#
  morph.matrix <- morph.matrix$matrix#
#
  # Create empty vectors to store S and W value for Wills 2001 equations (1 and 2):#
  differences <- maximum.differences <- vector(mode="numeric")#
  # Distance matrices for storing:#
  comp.char.matrix <- gower.dist.matrix <- max.dist.matrix <- dist.matrix <- matrix(0, nrow=length(rownames(morph.matrix)), ncol=length(rownames(morph.matrix)))#
  # Fill comparable characters diagonal:#
  for(i in 1:length(morph.matrix[, 1])) comp.char.matrix[i,i] <- length(morph.matrix[i, ]) - length(grep(TRUE, is.na(morph.matrix[i, ])))#
#
  # Set up empty matrix for storing data to calculate the Generalised Euclidean Distance of Wills (2001):#
  GED.data <- matrix(nrow=0, ncol=ncol(morph.matrix))#
#
  # Go through matrix rows:#
  for(i in 1:(length(morph.matrix[, 1]) - 1)) {#
    # Go through matrix columns:#
    for(j in (i + 1):length(morph.matrix[, 1])) {#
      # Get just the comparable characters (those coded for both taxa):#
      compchar <- intersect(grep(TRUE, !is.na(morph.matrix[rownames(morph.matrix)[i], ])), grep(TRUE, !is.na(morph.matrix[rownames(morph.matrix)[j], ])))#
      # Get comparable characters for ith taxon:#
      firstrow <- morph.matrix[rownames(morph.matrix)[i], compchar]#
#
      # Get comparable characters for jth taxon:#
      secondrow <- morph.matrix[rownames(morph.matrix)[j], compchar]#
      # Deal with polymorphic characters (if present):#
      if(length(grep("&", unique(c(firstrow, secondrow)))) > 0) {#
        # Find ampersands (polymorphisms):#
        ampersand.elements <- sort(c(grep("&", firstrow), grep("&", secondrow)))#
        # Go through each polymorphic character:#
        for(k in 1:length(ampersand.elements)) {#
          # Find out if two codings overlap once all polymorphism resolutions are considered:#
          intersection.value <- intersect(strsplit(firstrow[ampersand.elements[k]], "&")[[1]], strsplit(secondrow[ampersand.elements[k]], "&")[[1]])#
          # Case if polymorphic and non-polymorphic values overlap:#
          if(length(intersection.value) > 0) {#
            # Set ith value as zero (no difference):#
            firstrow[ampersand.elements[k]] <- 0#
#
            # Set jth value as zero (no difference)#
            secondrow[ampersand.elements[k]] <- 0#
#
          }#
          # Case if polymorphic and non-polymorphic values do not overlap:#
          if(length(intersection.value) == 0) {#
            # Case if character is unordered (max difference is 1):#
            if(ordering[compchar[ampersand.elements[k]]] == "unord") {#
              # Set ith value as zero:#
              firstrow[ampersand.elements[k]] <- 0#
#
              # Set jth value as 1 (making the ij difference equal to one):#
              secondrow[ampersand.elements[k]] <- 1#
#
            }#
            # Case if character is ordered (max difference is > 1):#
            if(ordering[compchar[ampersand.elements[k]]] == "ord") {#
              # Get first row value(s):#
              firstrowvals <- as.numeric(strsplit(firstrow[ampersand.elements[k]], "&")[[1]])#
              # Get second row value(s):#
              secondrowvals <- as.numeric(strsplit(secondrow[ampersand.elements[k]], "&")[[1]])#
              # Make mini distance matrix:#
              poly.dist.mat <- matrix(0, nrow=length(firstrowvals), ncol=length(secondrowvals))#
              # Go through each comparison:#
              for(l in 1:length(firstrowvals)) {#
                # Record absolute difference:#
                for(m in 1:length(secondrowvals)) poly.dist.mat[l, m] <- sqrt((firstrowvals[l] - secondrowvals[m]) ^ 2)#
#
              }#
              # Set first value as zero:#
              firstrow[ampersand.elements[k]] <- 0#
              # Set second value as minimum possible difference:#
              secondrow[ampersand.elements[k]] <- min(poly.dist.mat)#
#
            }#
#
          }#
#
        }#
#
      }#
      # Get the absolute difference between the two rows:#
      raw.diffs <- diffs <- abs(as.numeric(firstrow) - as.numeric(secondrow))#
      # If there are differences greater than 1 for unordered characters then rescore as 1:#
      if(length(grep(TRUE, diffs > 1)) > 0) diffs[grep(TRUE, diffs > 1)[grep(TRUE, ordering[compchar[grep(TRUE, diffs > 1)]] == "unord")]] <- 1#
#
      # Find the incomparable characters:#
      incompchar <- setdiff(1:ncol(morph.matrix), compchar)#
#
      # Store data for GED with NAs for missing distances:#
      GED.data <- rbind(GED.data, rbind(c(diffs, rep(NA, length(incompchar))), c(weights[compchar], weights[incompchar])))#
#
      # Get weighted differences:#
      diffs <- as.numeric(weights[compchar]) * diffs#
#
      # Get raw Euclidean distance:#
      raw.dist <- dist(rbind(diffs, rep(0, length(diffs))), method="euclidean")#
#
      # Work out maximum difference (again, checked against ordering) using compchar characters only:#
      raw.maxdiffs <- maxdiffs <- as.numeric(max.vals[compchar]) - as.numeric(min.vals[compchar])#
#
      # Correct maximum possible differences for unordered characters:#
      if(length(grep(TRUE, maxdiffs > 1)) > 0) maxdiffs[grep(TRUE, maxdiffs > 1)[grep(TRUE, ordering[compchar[grep(TRUE, maxdiffs > 1)]] == "unord")]] <- 1#
#
      # Get vector of maximum differences (corrected for character weights):#
      maxdiffs <- as.numeric(weights[compchar]) * maxdiffs#
#
      # Store raw distance:#
      dist.matrix[i, j] <- dist.matrix[j, i] <- raw.dist#
#
      # Store Gower distance:#
      gower.dist.matrix[i, j] <- gower.dist.matrix[j, i] <- sum(diffs) / sum(weights[compchar])#
#
      # Store maximum-rescaled distance:#
      max.dist.matrix[i, j] <- max.dist.matrix[j, i] <- sum(diffs) / sum(maxdiffs)#
#
      # Store N comparable characters:#
      comp.char.matrix[i, j] <- comp.char.matrix[j, i] <- length(compchar)#
#
      # Add to maximum differences (S_ijk * W_ijk in equation 1 of Wills 2001):#
      differences <- c(differences, diffs)#
#
      # Add to maximum differences (S_ijk_max * W_ijk in equation 1 of Wills 2001):#
      maximum.differences <- c(maximum.differences, maxdiffs)#
#
    }#
#
  }#
#
  # Calculated weighted mean univariate distance for calculating GED (equation 2 in Wills 2001):#
  S_ijk_bar <- sum(differences) / sum(maximum.differences)#
#
  # Replace missing distances with S_ijk_bar (i.e., results of equation 2 in Wills 2001 into equation 1 of Wills 2001):#
  GED.data[is.na(GED.data)] <- S_ijk_bar#
#
  # Isolate the distances:#
  S_ijk <- GED.data[grep(TRUE, (1:nrow(GED.data) %% 2) == 1), ]#
#
  # Isolate the weights:#
  W_ijk <- GED.data[grep(TRUE, (1:nrow(GED.data) %% 2) == 0), ]#
#
  # Calculate the GED (equation 1 of Wills 2001) for each pairwise comparison (ij):#
  GED_ij <- sqrt(apply(W_ijk * (S_ijk ^ 2), 1, sum))#
#
  # Create empty GED distance matrix:#
  GED.dist.matrix <- matrix(0, nrow=nrow(morph.matrix), ncol=nrow(morph.matrix))#
#
  # Set initial value for counter:#
  counter <- 1#
#
  # Go through matrix rows:#
  for(i in 1:(length(morph.matrix[, 1]) - 1)) {#
#
    # Go through matrix columns:#
    for(j in (i + 1):length(morph.matrix[, 1])) {#
#
      # Store distance:#
      GED.dist.matrix[i, j] <- GED.dist.matrix[j, i] <- GED_ij[counter]#
#
      # Update counter:#
      counter <- counter + 1#
#
    }#
#
  }#
  # Set diagonals as zero:#
  diag(gower.dist.matrix) <- diag(max.dist.matrix) <- 0#
#
  # Add row and column names (taxa) to distance matrices:#
  rownames(comp.char.matrix) <- colnames(comp.char.matrix) <- rownames(GED.dist.matrix) <- colnames(GED.dist.matrix) <- rownames(gower.dist.matrix) <- colnames(gower.dist.matrix) <- rownames(max.dist.matrix) <- colnames(max.dist.matrix) <- rownames(dist.matrix) <- colnames(dist.matrix) <- rownames(morph.matrix)#
#
# If transformation option is not "none":#
if(transform.proportional.distances != "none") {#
#
  # Convert all Gower values to 0 to 1 scale then take arcsine of sqrt to get values that better approximate a normal distribution:#
  gower.dist.matrix <- matrix(as.numeric(gsub(NaN, NA, asin(sqrt(gower.dist.matrix / max(sort(gower.dist.matrix)))))), nrow=nrow(gower.dist.matrix), dimnames=list(rownames(gower.dist.matrix), rownames(gower.dist.matrix)))#
#
  # Take arcsine square root of all MOD dist values:#
  max.dist.matrix <- matrix(as.numeric(gsub(NaN, NA, asin(sqrt(max.dist.matrix)))), nrow=nrow(max.dist.matrix), dimnames=list(rownames(max.dist.matrix), rownames(max.dist.matrix)))#
#
} else {#
#
gower.dist.matrix <- matrix(as.numeric(gsub(NaN, NA, gower.dist.matrix), nrow=nrow(gower.dist.matrix), dimnames=list(rownames(gower.dist.matrix), rownames(gower.dist.matrix)))#
#
}#
#
  # Compile results as a list:#
  result <- list(dist.matrix, GED.dist.matrix, gower.dist.matrix, max.dist.matrix, comp.char.matrix)#
  # Add names to results list:#
  names(result) <- c("raw.dist.matrix", "GED.dist.matrix", "gower.dist.matrix", "max.dist.matrix", "comp.char.matrix")#
  # Output result:#
  return(result)#
#
}
MorphDistMatrix <- function(morph.matrix, transform.proportional.distances="arcsine_sqrt") {#
#
  # Check format of transform.proportional.distances:#
  if(transform.proportional.distances != "none" && transform.proportional.distances != "sqrt" && transform.proportional.distances != "arcsine_sqrt") {#
#
    # Give error if something other than three possible settings is given:#
    stop("ERROR: transform.proportional.distances must be one of \"none\", \"sqrt\", or \"arcsine_sqrt\".")#
#
  }#
#
  # Isolate ordering element of morphology matrix:#
  ordering <- morph.matrix$ordering#
#
  # Isolate max values element of morphology matrix:#
  max.vals <- morph.matrix$max.vals#
  # Isolate min values element of morphology matrix:#
  min.vals <- morph.matrix$min.vals#
  # Isolate weighting element of morphology matrix:#
  weights <- morph.matrix$weights#
  # Isolate character-taxon matrix element of morphology matrix:#
  morph.matrix <- morph.matrix$matrix#
#
  # Create empty vectors to store S and W value for Wills 2001 equations (1 and 2):#
  differences <- maximum.differences <- vector(mode="numeric")#
  # Distance matrices for storing:#
  comp.char.matrix <- gower.dist.matrix <- max.dist.matrix <- dist.matrix <- matrix(0, nrow=length(rownames(morph.matrix)), ncol=length(rownames(morph.matrix)))#
  # Fill comparable characters diagonal:#
  for(i in 1:length(morph.matrix[, 1])) comp.char.matrix[i,i] <- length(morph.matrix[i, ]) - length(grep(TRUE, is.na(morph.matrix[i, ])))#
#
  # Set up empty matrix for storing data to calculate the Generalised Euclidean Distance of Wills (2001):#
  GED.data <- matrix(nrow=0, ncol=ncol(morph.matrix))#
#
  # Go through matrix rows:#
  for(i in 1:(length(morph.matrix[, 1]) - 1)) {#
    # Go through matrix columns:#
    for(j in (i + 1):length(morph.matrix[, 1])) {#
      # Get just the comparable characters (those coded for both taxa):#
      compchar <- intersect(grep(TRUE, !is.na(morph.matrix[rownames(morph.matrix)[i], ])), grep(TRUE, !is.na(morph.matrix[rownames(morph.matrix)[j], ])))#
      # Get comparable characters for ith taxon:#
      firstrow <- morph.matrix[rownames(morph.matrix)[i], compchar]#
#
      # Get comparable characters for jth taxon:#
      secondrow <- morph.matrix[rownames(morph.matrix)[j], compchar]#
      # Deal with polymorphic characters (if present):#
      if(length(grep("&", unique(c(firstrow, secondrow)))) > 0) {#
        # Find ampersands (polymorphisms):#
        ampersand.elements <- sort(c(grep("&", firstrow), grep("&", secondrow)))#
        # Go through each polymorphic character:#
        for(k in 1:length(ampersand.elements)) {#
          # Find out if two codings overlap once all polymorphism resolutions are considered:#
          intersection.value <- intersect(strsplit(firstrow[ampersand.elements[k]], "&")[[1]], strsplit(secondrow[ampersand.elements[k]], "&")[[1]])#
          # Case if polymorphic and non-polymorphic values overlap:#
          if(length(intersection.value) > 0) {#
            # Set ith value as zero (no difference):#
            firstrow[ampersand.elements[k]] <- 0#
#
            # Set jth value as zero (no difference)#
            secondrow[ampersand.elements[k]] <- 0#
#
          }#
          # Case if polymorphic and non-polymorphic values do not overlap:#
          if(length(intersection.value) == 0) {#
            # Case if character is unordered (max difference is 1):#
            if(ordering[compchar[ampersand.elements[k]]] == "unord") {#
              # Set ith value as zero:#
              firstrow[ampersand.elements[k]] <- 0#
#
              # Set jth value as 1 (making the ij difference equal to one):#
              secondrow[ampersand.elements[k]] <- 1#
#
            }#
            # Case if character is ordered (max difference is > 1):#
            if(ordering[compchar[ampersand.elements[k]]] == "ord") {#
              # Get first row value(s):#
              firstrowvals <- as.numeric(strsplit(firstrow[ampersand.elements[k]], "&")[[1]])#
              # Get second row value(s):#
              secondrowvals <- as.numeric(strsplit(secondrow[ampersand.elements[k]], "&")[[1]])#
              # Make mini distance matrix:#
              poly.dist.mat <- matrix(0, nrow=length(firstrowvals), ncol=length(secondrowvals))#
              # Go through each comparison:#
              for(l in 1:length(firstrowvals)) {#
                # Record absolute difference:#
                for(m in 1:length(secondrowvals)) poly.dist.mat[l, m] <- sqrt((firstrowvals[l] - secondrowvals[m]) ^ 2)#
#
              }#
              # Set first value as zero:#
              firstrow[ampersand.elements[k]] <- 0#
              # Set second value as minimum possible difference:#
              secondrow[ampersand.elements[k]] <- min(poly.dist.mat)#
#
            }#
#
          }#
#
        }#
#
      }#
      # Get the absolute difference between the two rows:#
      raw.diffs <- diffs <- abs(as.numeric(firstrow) - as.numeric(secondrow))#
      # If there are differences greater than 1 for unordered characters then rescore as 1:#
      if(length(grep(TRUE, diffs > 1)) > 0) diffs[grep(TRUE, diffs > 1)[grep(TRUE, ordering[compchar[grep(TRUE, diffs > 1)]] == "unord")]] <- 1#
#
      # Find the incomparable characters:#
      incompchar <- setdiff(1:ncol(morph.matrix), compchar)#
#
      # Store data for GED with NAs for missing distances:#
      GED.data <- rbind(GED.data, rbind(c(diffs, rep(NA, length(incompchar))), c(weights[compchar], weights[incompchar])))#
#
      # Get weighted differences:#
      diffs <- as.numeric(weights[compchar]) * diffs#
#
      # Get raw Euclidean distance:#
      raw.dist <- dist(rbind(diffs, rep(0, length(diffs))), method="euclidean")#
#
      # Work out maximum difference (again, checked against ordering) using compchar characters only:#
      raw.maxdiffs <- maxdiffs <- as.numeric(max.vals[compchar]) - as.numeric(min.vals[compchar])#
#
      # Correct maximum possible differences for unordered characters:#
      if(length(grep(TRUE, maxdiffs > 1)) > 0) maxdiffs[grep(TRUE, maxdiffs > 1)[grep(TRUE, ordering[compchar[grep(TRUE, maxdiffs > 1)]] == "unord")]] <- 1#
#
      # Get vector of maximum differences (corrected for character weights):#
      maxdiffs <- as.numeric(weights[compchar]) * maxdiffs#
#
      # Store raw distance:#
      dist.matrix[i, j] <- dist.matrix[j, i] <- raw.dist#
#
      # Store Gower distance:#
      gower.dist.matrix[i, j] <- gower.dist.matrix[j, i] <- sum(diffs) / sum(weights[compchar])#
#
      # Store maximum-rescaled distance:#
      max.dist.matrix[i, j] <- max.dist.matrix[j, i] <- sum(diffs) / sum(maxdiffs)#
#
      # Store N comparable characters:#
      comp.char.matrix[i, j] <- comp.char.matrix[j, i] <- length(compchar)#
#
      # Add to maximum differences (S_ijk * W_ijk in equation 1 of Wills 2001):#
      differences <- c(differences, diffs)#
#
      # Add to maximum differences (S_ijk_max * W_ijk in equation 1 of Wills 2001):#
      maximum.differences <- c(maximum.differences, maxdiffs)#
#
    }#
#
  }#
#
  # Calculated weighted mean univariate distance for calculating GED (equation 2 in Wills 2001):#
  S_ijk_bar <- sum(differences) / sum(maximum.differences)#
#
  # Replace missing distances with S_ijk_bar (i.e., results of equation 2 in Wills 2001 into equation 1 of Wills 2001):#
  GED.data[is.na(GED.data)] <- S_ijk_bar#
#
  # Isolate the distances:#
  S_ijk <- GED.data[grep(TRUE, (1:nrow(GED.data) %% 2) == 1), ]#
#
  # Isolate the weights:#
  W_ijk <- GED.data[grep(TRUE, (1:nrow(GED.data) %% 2) == 0), ]#
#
  # Calculate the GED (equation 1 of Wills 2001) for each pairwise comparison (ij):#
  GED_ij <- sqrt(apply(W_ijk * (S_ijk ^ 2), 1, sum))#
#
  # Create empty GED distance matrix:#
  GED.dist.matrix <- matrix(0, nrow=nrow(morph.matrix), ncol=nrow(morph.matrix))#
#
  # Set initial value for counter:#
  counter <- 1#
#
  # Go through matrix rows:#
  for(i in 1:(length(morph.matrix[, 1]) - 1)) {#
#
    # Go through matrix columns:#
    for(j in (i + 1):length(morph.matrix[, 1])) {#
#
      # Store distance:#
      GED.dist.matrix[i, j] <- GED.dist.matrix[j, i] <- GED_ij[counter]#
#
      # Update counter:#
      counter <- counter + 1#
#
    }#
#
  }#
  # Set diagonals as zero:#
  diag(gower.dist.matrix) <- diag(max.dist.matrix) <- 0#
#
  # Add row and column names (taxa) to distance matrices:#
  rownames(comp.char.matrix) <- colnames(comp.char.matrix) <- rownames(GED.dist.matrix) <- colnames(GED.dist.matrix) <- rownames(gower.dist.matrix) <- colnames(gower.dist.matrix) <- rownames(max.dist.matrix) <- colnames(max.dist.matrix) <- rownames(dist.matrix) <- colnames(dist.matrix) <- rownames(morph.matrix)#
#
# If transformation option is not "none":#
if(transform.proportional.distances != "none") {#
#
  # Convert all Gower values to 0 to 1 scale then take arcsine of sqrt to get values that better approximate a normal distribution:#
  gower.dist.matrix <- matrix(as.numeric(gsub(NaN, NA, asin(sqrt(gower.dist.matrix / max(sort(gower.dist.matrix)))))), nrow=nrow(gower.dist.matrix), dimnames=list(rownames(gower.dist.matrix), rownames(gower.dist.matrix)))#
#
  # Take arcsine square root of all MOD dist values:#
  max.dist.matrix <- matrix(as.numeric(gsub(NaN, NA, asin(sqrt(max.dist.matrix)))), nrow=nrow(max.dist.matrix), dimnames=list(rownames(max.dist.matrix), rownames(max.dist.matrix)))#
#
} else {#
#
gower.dist.matrix <- matrix(as.numeric(gsub(NaN, NA, gower.dist.matrix)), nrow=nrow(gower.dist.matrix), dimnames=list(rownames(gower.dist.matrix), rownames(gower.dist.matrix)))#
#
}#
#
  # Compile results as a list:#
  result <- list(dist.matrix, GED.dist.matrix, gower.dist.matrix, max.dist.matrix, comp.char.matrix)#
  # Add names to results list:#
  names(result) <- c("raw.dist.matrix", "GED.dist.matrix", "gower.dist.matrix", "max.dist.matrix", "comp.char.matrix")#
  # Output result:#
  return(result)#
#
}
MorphDistMatrix(Gauthier1986, transform.proportional.distances="none")
Gauthier1986
Gauthier1986$matrix
Gauthier1986$matrix[c("Outgroup", "Hulsanpes"), ]
MorphDistMatrix <- function(morph.matrix, transform.proportional.distances="arcsine_sqrt") {#
#
  # Check format of transform.proportional.distances:#
  if(transform.proportional.distances != "none" && transform.proportional.distances != "sqrt" && transform.proportional.distances != "arcsine_sqrt") {#
#
    # Give error if something other than three possible settings is given:#
    stop("ERROR: transform.proportional.distances must be one of \"none\", \"sqrt\", or \"arcsine_sqrt\".")#
#
  }#
#
  # Isolate ordering element of morphology matrix:#
  ordering <- morph.matrix$ordering#
#
  # Isolate max values element of morphology matrix:#
  max.vals <- morph.matrix$max.vals#
  # Isolate min values element of morphology matrix:#
  min.vals <- morph.matrix$min.vals#
  # Isolate weighting element of morphology matrix:#
  weights <- morph.matrix$weights#
  # Isolate character-taxon matrix element of morphology matrix:#
  morph.matrix <- morph.matrix$matrix#
#
  # Create empty vectors to store S and W value for Wills 2001 equations (1 and 2):#
  differences <- maximum.differences <- vector(mode="numeric")#
  # Distance matrices for storing:#
  comp.char.matrix <- gower.dist.matrix <- max.dist.matrix <- dist.matrix <- matrix(0, nrow=length(rownames(morph.matrix)), ncol=length(rownames(morph.matrix)))#
  # Fill comparable characters diagonal:#
  for(i in 1:length(morph.matrix[, 1])) comp.char.matrix[i,i] <- length(morph.matrix[i, ]) - length(grep(TRUE, is.na(morph.matrix[i, ])))#
#
  # Set up empty matrix for storing data to calculate the Generalised Euclidean Distance of Wills (2001):#
  GED.data <- matrix(nrow=0, ncol=ncol(morph.matrix))#
#
  # Go through matrix rows:#
  for(i in 1:(length(morph.matrix[, 1]) - 1)) {#
    # Go through matrix columns:#
    for(j in (i + 1):length(morph.matrix[, 1])) {#
      # Get just the comparable characters (those coded for both taxa):#
      compchar <- intersect(grep(TRUE, !is.na(morph.matrix[rownames(morph.matrix)[i], ])), grep(TRUE, !is.na(morph.matrix[rownames(morph.matrix)[j], ])))#
      # Get comparable characters for ith taxon:#
      firstrow <- morph.matrix[rownames(morph.matrix)[i], compchar]#
#
      # Get comparable characters for jth taxon:#
      secondrow <- morph.matrix[rownames(morph.matrix)[j], compchar]#
      # Deal with polymorphic characters (if present):#
      if(length(grep("&", unique(c(firstrow, secondrow)))) > 0) {#
        # Find ampersands (polymorphisms):#
        ampersand.elements <- sort(c(grep("&", firstrow), grep("&", secondrow)))#
        # Go through each polymorphic character:#
        for(k in 1:length(ampersand.elements)) {#
          # Find out if two codings overlap once all polymorphism resolutions are considered:#
          intersection.value <- intersect(strsplit(firstrow[ampersand.elements[k]], "&")[[1]], strsplit(secondrow[ampersand.elements[k]], "&")[[1]])#
          # Case if polymorphic and non-polymorphic values overlap:#
          if(length(intersection.value) > 0) {#
            # Set ith value as zero (no difference):#
            firstrow[ampersand.elements[k]] <- 0#
#
            # Set jth value as zero (no difference)#
            secondrow[ampersand.elements[k]] <- 0#
#
          }#
          # Case if polymorphic and non-polymorphic values do not overlap:#
          if(length(intersection.value) == 0) {#
            # Case if character is unordered (max difference is 1):#
            if(ordering[compchar[ampersand.elements[k]]] == "unord") {#
              # Set ith value as zero:#
              firstrow[ampersand.elements[k]] <- 0#
#
              # Set jth value as 1 (making the ij difference equal to one):#
              secondrow[ampersand.elements[k]] <- 1#
#
            }#
            # Case if character is ordered (max difference is > 1):#
            if(ordering[compchar[ampersand.elements[k]]] == "ord") {#
              # Get first row value(s):#
              firstrowvals <- as.numeric(strsplit(firstrow[ampersand.elements[k]], "&")[[1]])#
              # Get second row value(s):#
              secondrowvals <- as.numeric(strsplit(secondrow[ampersand.elements[k]], "&")[[1]])#
              # Make mini distance matrix:#
              poly.dist.mat <- matrix(0, nrow=length(firstrowvals), ncol=length(secondrowvals))#
              # Go through each comparison:#
              for(l in 1:length(firstrowvals)) {#
                # Record absolute difference:#
                for(m in 1:length(secondrowvals)) poly.dist.mat[l, m] <- sqrt((firstrowvals[l] - secondrowvals[m]) ^ 2)#
#
              }#
              # Set first value as zero:#
              firstrow[ampersand.elements[k]] <- 0#
              # Set second value as minimum possible difference:#
              secondrow[ampersand.elements[k]] <- min(poly.dist.mat)#
#
            }#
#
          }#
#
        }#
#
      }#
      # Get the absolute difference between the two rows:#
      raw.diffs <- diffs <- abs(as.numeric(firstrow) - as.numeric(secondrow))#
      # If there are differences greater than 1 for unordered characters then rescore as 1:#
      if(length(grep(TRUE, diffs > 1)) > 0) diffs[grep(TRUE, diffs > 1)[grep(TRUE, ordering[compchar[grep(TRUE, diffs > 1)]] == "unord")]] <- 1#
#
      # Find the incomparable characters:#
      incompchar <- setdiff(1:ncol(morph.matrix), compchar)#
#
      # Store data for GED with NAs for missing distances:#
      GED.data <- rbind(GED.data, rbind(c(diffs, rep(NA, length(incompchar))), c(weights[compchar], weights[incompchar])))#
#
      # Get weighted differences:#
      diffs <- as.numeric(weights[compchar]) * diffs#
#
      # Get raw Euclidean distance:#
      raw.dist <- dist(rbind(diffs, rep(0, length(diffs))), method="euclidean")#
#
      # Work out maximum difference (again, checked against ordering) using compchar characters only:#
      raw.maxdiffs <- maxdiffs <- as.numeric(max.vals[compchar]) - as.numeric(min.vals[compchar])#
#
      # Correct maximum possible differences for unordered characters:#
      if(length(grep(TRUE, maxdiffs > 1)) > 0) maxdiffs[grep(TRUE, maxdiffs > 1)[grep(TRUE, ordering[compchar[grep(TRUE, maxdiffs > 1)]] == "unord")]] <- 1#
#
      # Get vector of maximum differences (corrected for character weights):#
      maxdiffs <- as.numeric(weights[compchar]) * maxdiffs#
#
      # Store raw distance:#
      dist.matrix[i, j] <- dist.matrix[j, i] <- raw.dist#
#
      # Store Gower distance:#
      gower.dist.matrix[i, j] <- gower.dist.matrix[j, i] <- sum(diffs) / sum(weights[compchar])#
#
      # Store maximum-rescaled distance:#
      max.dist.matrix[i, j] <- max.dist.matrix[j, i] <- sum(diffs) / sum(maxdiffs)#
#
      # Store N comparable characters:#
      comp.char.matrix[i, j] <- comp.char.matrix[j, i] <- length(compchar)#
#
      # Add to maximum differences (S_ijk * W_ijk in equation 1 of Wills 2001):#
      differences <- c(differences, diffs)#
#
      # Add to maximum differences (S_ijk_max * W_ijk in equation 1 of Wills 2001):#
      maximum.differences <- c(maximum.differences, maxdiffs)#
#
    }#
#
  }#
#
  # Calculated weighted mean univariate distance for calculating GED (equation 2 in Wills 2001):#
  S_ijk_bar <- sum(differences) / sum(maximum.differences)#
#
  # Replace missing distances with S_ijk_bar (i.e., results of equation 2 in Wills 2001 into equation 1 of Wills 2001):#
  GED.data[is.na(GED.data)] <- S_ijk_bar#
#
  # Isolate the distances:#
  S_ijk <- GED.data[grep(TRUE, (1:nrow(GED.data) %% 2) == 1), ]#
#
  # Isolate the weights:#
  W_ijk <- GED.data[grep(TRUE, (1:nrow(GED.data) %% 2) == 0), ]#
#
  # Calculate the GED (equation 1 of Wills 2001) for each pairwise comparison (ij):#
  GED_ij <- sqrt(apply(W_ijk * (S_ijk ^ 2), 1, sum))#
#
  # Create empty GED distance matrix:#
  GED.dist.matrix <- matrix(0, nrow=nrow(morph.matrix), ncol=nrow(morph.matrix))#
#
  # Set initial value for counter:#
  counter <- 1#
#
  # Go through matrix rows:#
  for(i in 1:(length(morph.matrix[, 1]) - 1)) {#
#
    # Go through matrix columns:#
    for(j in (i + 1):length(morph.matrix[, 1])) {#
#
      # Store distance:#
      GED.dist.matrix[i, j] <- GED.dist.matrix[j, i] <- GED_ij[counter]#
#
      # Update counter:#
      counter <- counter + 1#
#
    }#
#
  }#
  # Set diagonals as zero:#
  diag(gower.dist.matrix) <- diag(max.dist.matrix) <- 0#
#
  # Add row and column names (taxa) to distance matrices:#
  rownames(comp.char.matrix) <- colnames(comp.char.matrix) <- rownames(GED.dist.matrix) <- colnames(GED.dist.matrix) <- rownames(gower.dist.matrix) <- colnames(gower.dist.matrix) <- rownames(max.dist.matrix) <- colnames(max.dist.matrix) <- rownames(dist.matrix) <- colnames(dist.matrix) <- rownames(morph.matrix)#
#
# If transformation option is not "none":#
if(transform.proportional.distances != "none") {#
#
  # Convert all Gower values to 0 to 1 scale then take arcsine of sqrt to get values that better approximate a normal distribution:#
  gower.dist.matrix <- matrix(as.numeric(gsub(NaN, NA, asin(sqrt(gower.dist.matrix / max(sort(gower.dist.matrix)))))), nrow=nrow(gower.dist.matrix), dimnames=list(rownames(gower.dist.matrix), rownames(gower.dist.matrix)))#
#
  # Take arcsine square root of all MOD dist values:#
  max.dist.matrix <- matrix(as.numeric(gsub(NaN, NA, asin(sqrt(max.dist.matrix)))), nrow=nrow(max.dist.matrix), dimnames=list(rownames(max.dist.matrix), rownames(max.dist.matrix)))#
#
} else {#
#
# Replace NaN with NA for Gower distances:#
gower.dist.matrix <- matrix(as.numeric(gsub(NaN, NA, gower.dist.matrix)), nrow=nrow(gower.dist.matrix), dimnames=list(rownames(gower.dist.matrix), rownames(gower.dist.matrix)))#
#
# Replace NaN with NA for Max distances:#
max.dist.matrix <- matrix(as.numeric(gsub(NaN, NA, max.dist.matrix)), nrow=nrow(max.dist.matrix), dimnames=list(rownames(max.dist.matrix), rownames(max.dist.matrix)))#
#
}#
#
  # Compile results as a list:#
  result <- list(dist.matrix, GED.dist.matrix, gower.dist.matrix, max.dist.matrix, comp.char.matrix)#
  # Add names to results list:#
  names(result) <- c("raw.dist.matrix", "GED.dist.matrix", "gower.dist.matrix", "max.dist.matrix", "comp.char.matrix")#
  # Output result:#
  return(result)#
#
}
MorphDistMatrix(Gauthier1986, transform.proportional.distances="none")
MorphDistMatrix(Gauthier1986, transform.proportional.distances="none")$max.dist.matrix
MorphDistMatrix(Gauthier1986, transform.proportional.distances="none")$max.dist.matrix == MorphDistMatrix(Gauthier1986, transform.proportional.distances="none")$gower.dist.matrix
MorphDistMatrix(Gauthier1986, transform.proportional.distances="none")$gower.dist.matrix
sort(MorphDistMatrix(Gauthier1986, transform.proportional.distances="none")$gower.dist.matrix)
max(sort(MorphDistMatrix(Gauthier1986, transform.proportional.distances="none")$gower.dist.matrix))
c(max(sort(gower.dist.matrix)), 1)
gower.dist.matrix <- MorphDistMatrix(Gauthier1986, transform.proportional.distances="none")$gower.dist.matrix
c(max(sort(gower.dist.matrix)), 1)
max(c(max(sort(gower.dist.matrix)), 1))
MorphDistMatrix <- function(morph.matrix, transform.proportional.distances="arcsine_sqrt") {#
#
  # Check format of transform.proportional.distances:#
  if(transform.proportional.distances != "none" && transform.proportional.distances != "sqrt" && transform.proportional.distances != "arcsine_sqrt") {#
#
    # Give error if something other than three possible settings is given:#
    stop("ERROR: transform.proportional.distances must be one of \"none\", \"sqrt\", or \"arcsine_sqrt\".")#
#
  }#
#
  # Isolate ordering element of morphology matrix:#
  ordering <- morph.matrix$ordering#
#
  # Isolate max values element of morphology matrix:#
  max.vals <- morph.matrix$max.vals#
  # Isolate min values element of morphology matrix:#
  min.vals <- morph.matrix$min.vals#
  # Isolate weighting element of morphology matrix:#
  weights <- morph.matrix$weights#
  # Isolate character-taxon matrix element of morphology matrix:#
  morph.matrix <- morph.matrix$matrix#
#
  # Create empty vectors to store S and W value for Wills 2001 equations (1 and 2):#
  differences <- maximum.differences <- vector(mode="numeric")#
  # Distance matrices for storing:#
  comp.char.matrix <- gower.dist.matrix <- max.dist.matrix <- dist.matrix <- matrix(0, nrow=length(rownames(morph.matrix)), ncol=length(rownames(morph.matrix)))#
  # Fill comparable characters diagonal:#
  for(i in 1:length(morph.matrix[, 1])) comp.char.matrix[i,i] <- length(morph.matrix[i, ]) - length(grep(TRUE, is.na(morph.matrix[i, ])))#
#
  # Set up empty matrix for storing data to calculate the Generalised Euclidean Distance of Wills (2001):#
  GED.data <- matrix(nrow=0, ncol=ncol(morph.matrix))#
#
  # Go through matrix rows:#
  for(i in 1:(length(morph.matrix[, 1]) - 1)) {#
    # Go through matrix columns:#
    for(j in (i + 1):length(morph.matrix[, 1])) {#
      # Get just the comparable characters (those coded for both taxa):#
      compchar <- intersect(grep(TRUE, !is.na(morph.matrix[rownames(morph.matrix)[i], ])), grep(TRUE, !is.na(morph.matrix[rownames(morph.matrix)[j], ])))#
      # Get comparable characters for ith taxon:#
      firstrow <- morph.matrix[rownames(morph.matrix)[i], compchar]#
#
      # Get comparable characters for jth taxon:#
      secondrow <- morph.matrix[rownames(morph.matrix)[j], compchar]#
      # Deal with polymorphic characters (if present):#
      if(length(grep("&", unique(c(firstrow, secondrow)))) > 0) {#
        # Find ampersands (polymorphisms):#
        ampersand.elements <- sort(c(grep("&", firstrow), grep("&", secondrow)))#
        # Go through each polymorphic character:#
        for(k in 1:length(ampersand.elements)) {#
          # Find out if two codings overlap once all polymorphism resolutions are considered:#
          intersection.value <- intersect(strsplit(firstrow[ampersand.elements[k]], "&")[[1]], strsplit(secondrow[ampersand.elements[k]], "&")[[1]])#
          # Case if polymorphic and non-polymorphic values overlap:#
          if(length(intersection.value) > 0) {#
            # Set ith value as zero (no difference):#
            firstrow[ampersand.elements[k]] <- 0#
#
            # Set jth value as zero (no difference)#
            secondrow[ampersand.elements[k]] <- 0#
#
          }#
          # Case if polymorphic and non-polymorphic values do not overlap:#
          if(length(intersection.value) == 0) {#
            # Case if character is unordered (max difference is 1):#
            if(ordering[compchar[ampersand.elements[k]]] == "unord") {#
              # Set ith value as zero:#
              firstrow[ampersand.elements[k]] <- 0#
#
              # Set jth value as 1 (making the ij difference equal to one):#
              secondrow[ampersand.elements[k]] <- 1#
#
            }#
            # Case if character is ordered (max difference is > 1):#
            if(ordering[compchar[ampersand.elements[k]]] == "ord") {#
              # Get first row value(s):#
              firstrowvals <- as.numeric(strsplit(firstrow[ampersand.elements[k]], "&")[[1]])#
              # Get second row value(s):#
              secondrowvals <- as.numeric(strsplit(secondrow[ampersand.elements[k]], "&")[[1]])#
              # Make mini distance matrix:#
              poly.dist.mat <- matrix(0, nrow=length(firstrowvals), ncol=length(secondrowvals))#
              # Go through each comparison:#
              for(l in 1:length(firstrowvals)) {#
                # Record absolute difference:#
                for(m in 1:length(secondrowvals)) poly.dist.mat[l, m] <- sqrt((firstrowvals[l] - secondrowvals[m]) ^ 2)#
#
              }#
              # Set first value as zero:#
              firstrow[ampersand.elements[k]] <- 0#
              # Set second value as minimum possible difference:#
              secondrow[ampersand.elements[k]] <- min(poly.dist.mat)#
#
            }#
#
          }#
#
        }#
#
      }#
      # Get the absolute difference between the two rows:#
      raw.diffs <- diffs <- abs(as.numeric(firstrow) - as.numeric(secondrow))#
      # If there are differences greater than 1 for unordered characters then rescore as 1:#
      if(length(grep(TRUE, diffs > 1)) > 0) diffs[grep(TRUE, diffs > 1)[grep(TRUE, ordering[compchar[grep(TRUE, diffs > 1)]] == "unord")]] <- 1#
#
      # Find the incomparable characters:#
      incompchar <- setdiff(1:ncol(morph.matrix), compchar)#
#
      # Store data for GED with NAs for missing distances:#
      GED.data <- rbind(GED.data, rbind(c(diffs, rep(NA, length(incompchar))), c(weights[compchar], weights[incompchar])))#
#
      # Get weighted differences:#
      diffs <- as.numeric(weights[compchar]) * diffs#
#
      # Get raw Euclidean distance:#
      raw.dist <- dist(rbind(diffs, rep(0, length(diffs))), method="euclidean")#
#
      # Work out maximum difference (again, checked against ordering) using compchar characters only:#
      raw.maxdiffs <- maxdiffs <- as.numeric(max.vals[compchar]) - as.numeric(min.vals[compchar])#
#
      # Correct maximum possible differences for unordered characters:#
      if(length(grep(TRUE, maxdiffs > 1)) > 0) maxdiffs[grep(TRUE, maxdiffs > 1)[grep(TRUE, ordering[compchar[grep(TRUE, maxdiffs > 1)]] == "unord")]] <- 1#
#
      # Get vector of maximum differences (corrected for character weights):#
      maxdiffs <- as.numeric(weights[compchar]) * maxdiffs#
#
      # Store raw distance:#
      dist.matrix[i, j] <- dist.matrix[j, i] <- raw.dist#
#
      # Store Gower distance:#
      gower.dist.matrix[i, j] <- gower.dist.matrix[j, i] <- sum(diffs) / sum(weights[compchar])#
#
      # Store maximum-rescaled distance:#
      max.dist.matrix[i, j] <- max.dist.matrix[j, i] <- sum(diffs) / sum(maxdiffs)#
#
      # Store N comparable characters:#
      comp.char.matrix[i, j] <- comp.char.matrix[j, i] <- length(compchar)#
#
      # Add to maximum differences (S_ijk * W_ijk in equation 1 of Wills 2001):#
      differences <- c(differences, diffs)#
#
      # Add to maximum differences (S_ijk_max * W_ijk in equation 1 of Wills 2001):#
      maximum.differences <- c(maximum.differences, maxdiffs)#
#
    }#
#
  }#
#
  # Calculated weighted mean univariate distance for calculating GED (equation 2 in Wills 2001):#
  S_ijk_bar <- sum(differences) / sum(maximum.differences)#
#
  # Replace missing distances with S_ijk_bar (i.e., results of equation 2 in Wills 2001 into equation 1 of Wills 2001):#
  GED.data[is.na(GED.data)] <- S_ijk_bar#
#
  # Isolate the distances:#
  S_ijk <- GED.data[grep(TRUE, (1:nrow(GED.data) %% 2) == 1), ]#
#
  # Isolate the weights:#
  W_ijk <- GED.data[grep(TRUE, (1:nrow(GED.data) %% 2) == 0), ]#
#
  # Calculate the GED (equation 1 of Wills 2001) for each pairwise comparison (ij):#
  GED_ij <- sqrt(apply(W_ijk * (S_ijk ^ 2), 1, sum))#
#
  # Create empty GED distance matrix:#
  GED.dist.matrix <- matrix(0, nrow=nrow(morph.matrix), ncol=nrow(morph.matrix))#
#
  # Set initial value for counter:#
  counter <- 1#
#
  # Go through matrix rows:#
  for(i in 1:(length(morph.matrix[, 1]) - 1)) {#
#
    # Go through matrix columns:#
    for(j in (i + 1):length(morph.matrix[, 1])) {#
#
      # Store distance:#
      GED.dist.matrix[i, j] <- GED.dist.matrix[j, i] <- GED_ij[counter]#
#
      # Update counter:#
      counter <- counter + 1#
#
    }#
#
  }#
  # Set diagonals as zero:#
  diag(gower.dist.matrix) <- diag(max.dist.matrix) <- 0#
#
  # Add row and column names (taxa) to distance matrices:#
  rownames(comp.char.matrix) <- colnames(comp.char.matrix) <- rownames(GED.dist.matrix) <- colnames(GED.dist.matrix) <- rownames(gower.dist.matrix) <- colnames(gower.dist.matrix) <- rownames(max.dist.matrix) <- colnames(max.dist.matrix) <- rownames(dist.matrix) <- colnames(dist.matrix) <- rownames(morph.matrix)#
#
  # If transformation option is not "none":#
  if(transform.proportional.distances != "none") {#
#
    # If transformation option is "sqrt":#
    if(transform.proportional.distances == "sqrt") {#
#
      # Replace NaN with NA for Gower distances and take square root:#
      gower.dist.matrix <- matrix(as.numeric(gsub(NaN, NA, sqrt(gower.dist.matrix))), nrow=nrow(gower.dist.matrix), dimnames=list(rownames(gower.dist.matrix), rownames(gower.dist.matrix)))#
#
      # Replace NaN with NA for Max distances and take square root:#
      max.dist.matrix <- matrix(as.numeric(gsub(NaN, NA, sqrt(max.dist.matrix))), nrow=nrow(max.dist.matrix), dimnames=list(rownames(max.dist.matrix), rownames(max.dist.matrix)))#
#
    # If transformation option is "arcsine_sqrt":#
    } else {#
#
      # Establish correction factor to ensure Gower data is proportional:#
      gower.correction <- max(c(max(sort(gower.dist.matrix)), 1))#
#
      # Ensure all Gower values are on 0 to 1 scale then take arcsine of sqrt to get values that better approximate a normal distribution:#
      gower.dist.matrix <- matrix(as.numeric(gsub(NaN, NA, asin(sqrt(gower.dist.matrix / gower.correction)))), nrow=nrow(gower.dist.matrix), dimnames=list(rownames(gower.dist.matrix), rownames(gower.dist.matrix)))#
#
      # Take arcsine square root of all MOD dist values:#
      max.dist.matrix <- matrix(as.numeric(gsub(NaN, NA, asin(sqrt(max.dist.matrix)))), nrow=nrow(max.dist.matrix), dimnames=list(rownames(max.dist.matrix), rownames(max.dist.matrix)))#
#
    }#
#
  # If transformation option is "none":#
  } else {#
#
    # Replace NaN with NA for Gower distances:#
    gower.dist.matrix <- matrix(as.numeric(gsub(NaN, NA, gower.dist.matrix)), nrow=nrow(gower.dist.matrix), dimnames=list(rownames(gower.dist.matrix), rownames(gower.dist.matrix)))#
#
    # Replace NaN with NA for Max distances:#
    max.dist.matrix <- matrix(as.numeric(gsub(NaN, NA, max.dist.matrix)), nrow=nrow(max.dist.matrix), dimnames=list(rownames(max.dist.matrix), rownames(max.dist.matrix)))#
#
  }#
#
  # Compile results as a list:#
  result <- list(dist.matrix, GED.dist.matrix, gower.dist.matrix, max.dist.matrix, comp.char.matrix)#
  # Add names to results list:#
  names(result) <- c("raw.dist.matrix", "GED.dist.matrix", "gower.dist.matrix", "max.dist.matrix", "comp.char.matrix")#
  # Output result:#
  return(result)#
#
}
MorphDistMatrix(Gauthier1986, transform.proportional.distances="none")
MorphDistMatrix(Gauthier1986, transform.proportional.distances="sqrt")
MorphDistMatrix(Gauthier1986, transform.proportional.distances="sqrt")$max.dist.matrix
?diag
MorphDistMatrix(Gauthier1986, transform.proportional.distances="sqrt")$max.dist.matrix)
lower.tri(MorphDistMatrix(Gauthier1986, transform.proportional.distances="sqrt")$max.dist.matrix)
MorphDistMatrix(Gauthier1986, transform.proportional.distances="sqrt")$max.dist.matrix[lower.tri(MorphDistMatrix(Gauthier1986, transform.proportional.distances="sqrt")$max.dist.matrix)]
sort(MorphDistMatrix(Gauthier1986, transform.proportional.distances="sqrt")$max.dist.matrix[lower.tri(MorphDistMatrix(Gauthier1986, transform.proportional.distances="sqrt")$max.dist.matrix)])
hist(sort(MorphDistMatrix(Gauthier1986, transform.proportional.distances="sqrt")$max.dist.matrix[lower.tri(MorphDistMatrix(Gauthier1986, transform.proportional.distances="sqrt")$max.dist.matrix)]))
hist(sort(MorphDistMatrix(Gauthier1986, transform.proportional.distances="none")$max.dist.matrix[lower.tri(MorphDistMatrix(Gauthier1986, transform.proportional.distances="sqrt")$max.dist.matrix)]))
hist(sort(MorphDistMatrix(Gauthier1986, transform.proportional.distances="sqrt")$max.dist.matrix[lower.tri(MorphDistMatrix(Gauthier1986, transform.proportional.distances="sqrt")$max.dist.matrix)]))
hist(sort(MorphDistMatrix(Gauthier1986, transform.proportional.distances="none")$max.dist.matrix[lower.tri(MorphDistMatrix(Gauthier1986, transform.proportional.distances="sqrt")$max.dist.matrix)]))
hist(sort(MorphDistMatrix(Gauthier1986, transform.proportional.distances="arcsine_sqrt")$max.dist.matrix[lower.tri(MorphDistMatrix(Gauthier1986, transform.proportional.distances="sqrt")$max.dist.matrix)]))
sort(MorphDistMatrix(Gauthier1986, transform.proportional.distances="arcsine_sqrt")$max.dist.matrix[lower.tri(MorphDistMatrix(Gauthier1986, transform.proportional.distances="sqrt")$max.dist.matrix)])
MorphDistMatrix(Gauthier1986, transform.proportional.distances="arcsine_sqrt")$max.dist.matrix[lower.tri(MorphDistMatrix(Gauthier1986, transform.proportional.distances="sqrt")$max.dist.matrix)]
nchar("0?????????????????????????????????????????????????????????????????????00000?000???0101000??0?010?0001000000?????????????0??000???00000011000000000?000000010010100100000101100000000???000000???")
sqrt(0)
librart(Claddis)
library(Claddis)
Gauthier1986
MorphDistMatrix(Gauthier1986)
?TrimMorphDistMatrix
TrimMorphDistMatrix(MorphDistMatrix(Gauthier1986))
TrimMorphDistMatrix(MorphDistMatrix(Gauthier1986$max.dist.matrix))
TrimMorphDistMatrix(MorphDistMatrix(Gauthier1986)$max.dist.matrix)
is.matrix(MorphDistMatrix(Gauthier1986)$max.dist.matrix)
is.matrix(MorphDistMatrix(Gauthier1986))
is.matrix(MorphDistMatrix(Gauthier1986)$max.dist.matrix)
is.dist(MorphDistMatrix(Gauthier1986)$max.dist.matrix)
dist
as.dist(MorphDistMatrix(Gauthier1986)$max.dist.matrix)
is.matrix(as.dist(MorphDistMatrix(Gauthier1986)$max.dist.matrix))
as.matrix(as.dist(MorphDistMatrix(Gauthier1986)$max.dist.matrix))
?is.dist
??is.dist
?as.dist
as.dist(MorphDistMatrix(Gauthier1986)$max.dist.matrix)
class(as.dist(MorphDistMatrix(Gauthier1986)$max.dist.matrix))
is.matrix(dist.matrix)#
	class(dist.matrix) == "dist"
dist.matrix <- MorphDistMatrix(Gauthier1986)$max.dist.matrix
is.matrix(dist.matrix)#
	class(dist.matrix) == "dist"
if(class(dist.matrix) == "dist") dist.matrix <- as.matrix(dist.matrix)#
#
  # Check the input is a distance matrix:#
  if(!is.matrix(dist.matrix)) stop("ERROR: Input must be a distance matrix (i.e., either an object of class "dist" or a square matrix).")
if(class(dist.matrix) == "dist") dist.matrix <- as.matrix(dist.matrix)#
#
  # Check the input is a distance matrix:#
  if(!is.matrix(dist.matrix)) stop("ERROR: Input must be a distance matrix (i.e., either an object of class \"dist\" or a square matrix).")
dist.matrix
nrow(dist.matrix)
ncol(dist.matrix)
nrow(dist.matrix) == ncol(dist.matrix)
library(strap)
?strap
library(Claddis)
?Claddis
library(Claddis)#
#
A <- ReadMorphNexus("/Users/gral/Downloads/Averianov_et_al_matrix.nex")#
B <- ReadMorphNexus("/Users/gral/Downloads/Zhou_et_al_matrix.nex")#
C <- ReadMorphNexus("/Users/gral/Downloads/Yuan_et_al_matrix.nex")#
D <- ReadMorphNexus("/Users/gral/Downloads/Rougier_et_al_matrix.nex")#
E <- ReadMorphNexus("/Users/gral/Downloads/Krause_et_al_matrix.nex")
A
?Claddis
MorphDistMatrix(A)
library(Claddis)#
#
A <- ReadMorphNexus("/Users/gral/Downloads/Averianov_et_al_matrix.nex")#
B <- ReadMorphNexus("/Users/gral/Downloads/Zhou_et_al_matrix.nex")#
C <- ReadMorphNexus("/Users/gral/Downloads/Yuan_et_al_matrix.nex")#
D <- ReadMorphNexus("/Users/gral/Downloads/Rougier_et_al_matrix.nex")#
E <- ReadMorphNexus("/Users/gral/Downloads/Krause_et_al_matrix.nex")#
#
A.dist <- MorphDistMatrix(A)#
B.dist <- MorphDistMatrix(B)#
C.dist <- MorphDistMatrix(C)#
D.dist <- MorphDistMatrix(D)#
E.dist <- MorphDistMatrix(E)
A.dist
A.dist[[5]]
A.dist[[1]]
is.na(A.dist[[1]])
any(is.na(A.dist[[1]]))
any(is.na(A.dist[[2]]))
any(is.na(A.dist[[3]]))
any(is.na(A.dist[[4]]))
any(is.na(A.dist[[5]]))
any(is.na(A.dist[[1]]))#
any(is.na(A.dist[[2]]))#
any(is.na(A.dist[[3]]))#
any(is.na(A.dist[[4]]))#
any(is.na(B.dist[[1]]))#
any(is.na(B.dist[[2]]))#
any(is.na(B.dist[[3]]))#
any(is.na(B.dist[[4]]))#
any(is.na(C.dist[[1]]))#
any(is.na(C.dist[[2]]))#
any(is.na(C.dist[[3]]))#
any(is.na(C.dist[[4]]))#
any(is.na(D.dist[[1]]))#
any(is.na(D.dist[[2]]))#
any(is.na(D.dist[[3]]))#
any(is.na(D.dist[[4]]))#
any(is.na(E.dist[[1]]))#
any(is.na(E.dist[[2]]))#
any(is.na(E.dist[[3]]))#
any(is.na(E.dist[[4]]))
TrimMorphDistMatrix(B.dist[[1]])#
TrimMorphDistMatrix(B.dist[[3]])#
TrimMorphDistMatrix(B.dist[[4]])#
TrimMorphDistMatrix(E.dist[[1]])#
TrimMorphDistMatrix(E.dist[[3]])#
TrimMorphDistMatrix(E.dist[[4]])
TrimMorphDistMatrix(B.dist[[1]])$dist.matrix#
TrimMorphDistMatrix(B.dist[[3]])$dist.matrix#
TrimMorphDistMatrix(B.dist[[4]])$dist.matrix#
TrimMorphDistMatrix(E.dist[[1]])$dist.matrix#
TrimMorphDistMatrix(E.dist[[3]])$dist.matrix#
TrimMorphDistMatrix(E.dist[[4]])$dist.matrix
any(is.na(TrimMorphDistMatrix(B.dist[[1]])$dist.matrix))#
any(is.na(TrimMorphDistMatrix(B.dist[[3]])$dist.matrix))#
any(is.na(TrimMorphDistMatrix(B.dist[[4]])$dist.matrix))#
any(is.na(TrimMorphDistMatrix(E.dist[[1]])$dist.matrix))#
any(is.na(TrimMorphDistMatrix(E.dist[[3]])$dist.matrix))#
any(is.na(TrimMorphDistMatrix(E.dist[[4]])$dist.matrix))
citation()
library(devtools)#
install_github("dwbapst/paleotree")#
library(paleotree)#
#
getTaxaPBDB<-function(taxon){#
 #let's get some taxonomic data#
   taxaData<-read.csv(paste0("http://paleobiodb.org/",#
       "data1.1/taxa/list.txt?base_name=",taxon,#
       "&rel=all_children&show=phylo,img,nav&status=senior"))#
   return(taxaData)#
   }#
#
#graptolites#
data<-getTaxaPBDB("Graptolithina")#
graptTree<-makePBDBtaxontree(data,"genus")#
plot(graptTree)
graptTree
graptTree$node.label
names(graptTree)
?ape
data<-getTaxaPBDB("Ornithischia")
ornithTree<-makePBDBtaxontree(data,"genus")
data
makePBDBtaxontree
?timePaleoPhy
library(paleotree)
?timePaleoPhy
library(Claddis)
Gauthier1986
names(Gauthier1986)
?Claddis
AncStateEstMatrix
?rerootingMethod
?phytools
?
shapiro.test
?mantel.randtest
library(ade4)
?mantel.randtest
?cmdscale
?stats
?shapiro.test
?read.table
library(geosphere)#
library(rgl)#
library(sphereplot)#
#
rgl.sphgrid()#
#
lonlat <- c(0, 90)#
#
for(i in 1:1000) {#
#
lonlat2 <- destPoint(lonlat, runif(1, 0, 360), abs(rnorm(1, 0, 100000)))#
#
#lines(c(lonlat[1], lonlat2[1]), c(lonlat[2], lonlat2[2]), col="red")#
#
rgl.sphpoints(lonlat2[1], lonlat2[2], 1, deg=TRUE, col=rainbow(1000)[i], cex=2)#
#
lonlat <- lonlat2#
#
#print(lonlat)#
#
}#
#
# CONDITIONALS FOR TRAVELLING EXACTLY ALONG LINES OF LATITUDE-LONGITUDE (FLOATING POINT ERRORS; all.equal() ?)#
# CONDITIONALS FOR TRAVELLING FROM NORTH-SOUTH POLE
destPoint
# Install the devtools package from CRAN:#
install.packages("devtools")#
#
# Load the devtools package into R:#
library(devtools)#
#
# Install the dispeRse package from github:#
install_github("laurasoul/dispeRse")#
#
# Load the dispeRse package into R:#
library(dispeRse)
?dispeRse
?endPoint
?endpoint
# Install the Claddis package from github:#
install_github("graemetlloyd/Claddis")#
#
# Load the Claddis package into R:#
library(Claddis)
library(dispeRse)#
library(sphereplot)#
#
rgl.sphgrid()#
#
lonlat <- c(0, 90)#
#
for(i in 1:1000) {#
#
lonlat2 <- endpoint(lonlat[1], lonlat[2], runif(1, 0, 360), abs(rnorm(1, 0, 100000)))#
#
#lines(c(lonlat[1], lonlat2[1]), c(lonlat[2], lonlat2[2]), col="red")#
#
rgl.sphpoints(lonlat2[1], lonlat2[2], 1, deg=TRUE, col=rainbow(1000)[i], cex=2)#
#
lonlat <- lonlat2#
#
#print(lonlat)#
#
}#
#
# CONDITIONALS FOR TRAVELLING EXACTLY ALONG LINES OF LATITUDE-LONGITUDE (FLOATING POINT ERRORS; all.equal() ?)#
# CONDITIONALS FOR TRAVELLING FROM NORTH-SOUTH POLE
?endpoint
endpoint(lonlat[2], lonlat[1], runif(1, 0, 360), abs(rnorm(1, 0, 100000)))
library(dispeRse)#
library(sphereplot)#
#
rgl.sphgrid()#
#
lonlat <- c(0, 90)#
#
for(i in 1:1000) {#
#
lonlat2 <- endpoint(lonlat[2], lonlat[1], runif(1, 0, 360), abs(rnorm(1, 0, 100000)))[c(2, 1)]#
#
rgl.sphpoints(lonlat2[1], lonlat2[2], 1, deg=TRUE, col=rainbow(1000)[i], cex=2)#
#
lonlat <- lonlat2#
#
#print(lonlat)#
#
}
lonlat
lonlat2
i
library(dispeRse)#
library(sphereplot)#
#
rgl.sphgrid()#
#
lonlat <- c(0, 90)#
#
for(i in 1:1000) {#
#
lonlat2 <- unlist(endpoint(lonlat[2], lonlat[1], runif(1, 0, 360), abs(rnorm(1, 0, 100000)))[c(2, 1)])#
#
rgl.sphpoints(lonlat2[1], lonlat2[2], 1, deg=TRUE, col=rainbow(1000)[i], cex=2)#
#
lonlat <- lonlat2#
#
#print(lonlat)#
#
}
library(dispeRse)#
library(sphereplot)#
#
rgl.sphgrid()#
#
lonlat <- c(0, 90)#
#
for(i in 1:1000) {#
#
lonlat2 <- unlist(endpoint(lonlat[2], lonlat[1], runif(1, 0, 360), abs(rnorm(1, 0, 100)))[c(2, 1)])#
#
rgl.sphpoints(lonlat2[1], lonlat2[2], 1, deg=TRUE, col=rainbow(1000)[i], cex=2)#
#
lonlat <- lonlat2#
#
#print(lonlat)#
#
}#
#
# CONDITIONALS FOR TRAVELLING EXACTLY ALONG LINES OF LATITUDE-LONGITUDE (FLOATING POINT ERRORS; all.equal() ?)#
# CONDITIONALS FOR TRAVELLING FROM NORTH-SOUTH POLE
# Load libraries:#
library(dispeRse)#
install.packages("sphereplot", dependencies=T)#
library(sphereplot)#
#
# Plot spherical grid:#
rgl.sphgrid()#
#
# Start at North Pole:#
lonlat <- c(0, 90)#
#
# For 1000 random walk steps:#
for(i in 1:1000) {#
#
    # Take a random step and store new coordinates:#
    lonlat2 <- unlist(endpoint(lonlat[2], lonlat[1], runif(1, 0, 360), abs(rnorm(1, 0, 100)))[c(2, 1)])#
#
    # Plot coordinates on sphere in rainbow colour order:#
    rgl.sphpoints(lonlat2[1], lonlat2[2], 1, deg=TRUE, col=rainbow(1000)[i], cex=2)#
#
    # Update lonlat ready for next step:#
    lonlat <- lonlat2#
#
}
# Install the devtools package from CRAN:#
install.packages("devtools")#
#
# Load the devtools package into R:#
library(devtools)#
#
# Install the dispeRse package from github:#
install_github("laurasoul/dispeRse")#
#
# Load the dispeRse package into R:#
library(dispeRse)
?endpoint
library(roxygen2)
setwd("~/Documents/Publications/in prep/dispeRse")
document()
document()
# Install the dispeRse package from github:#
install_github("laurasoul/dispeRse")#
#
# Load the dispeRse package into R:#
library(dispeRse)
# Load libraries:#
library(dispeRse)#
install.packages("sphereplot", dependencies=T)#
library(sphereplot)#
#
# Plot spherical grid:#
rgl.sphgrid()#
#
# Start at North Pole:#
lonlat <- c(0, 90)#
#
# For 1000 random walk steps:#
for(i in 1:1000) {#
#
    # Take a random step and store new coordinates:#
    lonlat2 <- unlist(EndPoint(lonlat[2], lonlat[1], runif(1, 0, 360), abs(rnorm(1, 0, 100)))[c(2, 1)])#
#
    # Plot coordinates on sphere in rainbow colour order:#
    rgl.sphpoints(lonlat2[1], lonlat2[2], 1, deg=TRUE, col=rainbow(1000)[i], cex=2)#
#
    # Update lonlat ready for next step:#
    lonlat <- lonlat2#
#
}
rtree(100)
library(ape)
rtree(100)
rcoal(100)
plot(rcoal(100))
?runif
?rnorm
tree
vcv(tree)
tree <- rcoal(50)
vcv(tree)
max(vcv(tree))
max(diag(vcv(tree)))
tree$edge
tree$edge.length
?rcoal
rcoal
library(geiger)
?geiger
sim.bdtree(b=0.2, d=0.05, stop="time", t=20, extinct=FALSE)
plot(sim.bdtree(b=0.2, d=0.05, stop="time", t=20, extinct=FALSE))
sim.bdtree
?EndPoint
