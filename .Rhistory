OpenSpots <- function(longitudes, latitudes, min_separation, EarthRad = 6367.4447) {#
	# Get spherical angle of equilateral (spherical) triangle with sides equal to minimum separation:#
	spherical_angle <- SphericalAngleForEquilateralTriangleFromGreatCircleSideLength(min_separation, EarthRad = EarthRad)#
	# Get links between continents (essentially which ones are adjacent to each other):#
	intercontinental_links <- IntercontinentalLinks(min_separation, longitudes, latitudes, EarthRad = EarthRad)#
	# Create empty matrix to stoe open spots:#
	open_spots <- matrix(nrow=0, ncol=2)#
	# For each row in the lower triangle of intercontinental links:#
	for(i in 2:nrow(intercontinental_links)) {#
		# For each column in the lower triangle of intercontinental links:#
		for(j in 1:(i - 1)) {#
			# If there is a link:#
			if(intercontinental_links[i, j] == 1) {#
				# Get first of two possible bearings from centre of first continent to centre of adjacent continent:#
				new_bearing_1 <- (BearingBetweenTwoLongLatPoints(longitudes[i], latitudes[i], longitudes[j], latitudes[j]) - spherical_angle) %% 360#
				# Get second of two possible bearings from centre of first continent to centre of adjacent continent:#
				new_bearing_2 <- (BearingBetweenTwoLongLatPoints(longitudes[i], latitudes[i], longitudes[j], latitudes[j]) + spherical_angle) %% 360#
				# Get lat-long coordinates of first possible site new continent:#
				new_continent_1 <- EndPoint(longitudes[i], latitudes[i], new_bearing_1, min_separation)[c("long", "lat")]#
				# Get lat-long coordinates of second possible site new continent:#
				new_continent_2 <- EndPoint(longitudes[i], latitudes[i], new_bearing_2, min_separation)[c("long", "lat")]#
				# Add two new spots to open spots list:#
				open_spots <- rbind(open_spots, rbind(unlist(new_continent_1), unlist(new_continent_2)))#
			}#
		}#
	}#
	# Ensure only unique open spots are included:#
	open_spots <- matrix(as.numeric(unlist(strsplit(unique(apply(open_spots, 1, paste, collapse="%%")), "%%"))), ncol=2, byrow=TRUE)#
	# Vector to store spots that are too close to (or already are occupied by) existing continents):#
	too_close <- vector(mode="numeric")#
	# For each open spot:#
	for(i in 1:nrow(open_spots)) {#
		# Get the distance from the ith open spot to all existing continents:#
		distance_to_existing <- One2ManyGreatCircleDistance(open_spots[i, 1], open_spots[i, 2], longitudes, latitudes)#
		# Isolate potential too short distances (need to check if just a floating point error before confirming):#
		distance_to_existing <- distance_to_existing[distance_to_existing < min_separation]#
		# If the ith open spot is potentially too close to an existing continent:#
		if(length(distance_to_existing) > 0) {#
			# For each potnetial too short distance::#
			for(j in length(distance_to_existing):1) {#
				# Exclude if within floating point error of the minimum allowed separation:#
				if(all.equal(distance_to_existing[j], min_separation) == TRUE) distance_to_existing <- distance_to_existing[-j]#
			}#
		}#
		# If the open spot is still too close to an existing continent add it to the list:#
		if(length(distance_to_existing) > 0) too_close <- c(too_close, i)#
	}#
	# If any open spots are too close to existing continents then exclude them:#
	if(length(too_close) > 0) open_spots <- open_spots[-too_close, ]#
	# Return open spots matrix (may have zero rows):#
	return(open_spots)#
}
OpenSpots(c(0, 1), c(0, 0), 111.132874953663, EarthRad = 6367.4447)
document()
OpenSpots(circles[, 1], circles[, 2], min_separation, EarthRad)
circles
# Check N_continents at least 1 and is an integer (divisble by one:#
	if(N_continents %% 1 != 0 || N_continents < 1) stop("ERROR: Number of contientns must be a positive integer >= 1.")#
	# Check radius is less than or equal to pi * the radius of the Earth:#
	if(radius > (pi * EarthRad)) stop("ERROR: Radius must be less than pi * EarthRad (and much more if using multiple continents).")#
	# Check configuration option chosen is valid:#
	if(start_configuration != "random separate" && start_configuration != "random overlap" && start_configuration != "supercontinent" && start_configuration != "max separate") stop("ERROR: Starting configuration must be one of \"random separate\", \"random overlap\", \"supercontinent\", or \"max separate\".")#
	# Check squishiness is a proportion:#
	if(squishiness > 1 || squishiness < 0) stop("ERROR: Squishiness is proportional and must be between 0 and 1.")#
#
	# If starting dispersed and the number of continents is larger that 8 use random distribution instead#
	if(start_configuration == "max separate" && N_continents >= 9) {#
		cat("Using random separate configuration as number of continents is too large", "\n")#
		start_configuration <- "random separate"#
	}
# Establish minimum distance between continent centres (:#
			min_separation <- (1 - squishiness) * radius * 2#
			# Randomly assign starting longitude:#
			first_circle_long <- runif(1, min = -180, max = 180)#
			# Randomly assign starting latitude:#
			first_circle_lat <- runif(1, min = -90, max = 90)#
			# Create matrix to store circles:#
			circles <- matrix(c(first_circle_long, first_circle_lat), ncol=2, dimnames=list(c(), c("Longitude", "Latitude")))
# Find centre of second continnet by randomly drawing from the circle describing all points within minimum separation of the first continent:#
				second_circle <- EndPoint(slong = first_circle_long, slat = first_circle_lat, bearing = runif(1, min = 0, max = 360), distance = min_separation)#
				# Add second continent to circles matrix:#
				circles <- rbind(circles, c(second_circle$long, second_circle$lat))
N_continents > 2
OpenSpots(circles[, 1], circles[, 2], min_separation, EarthRad)
1:nrow(open_spots)
# Find open spots available for next continent:#
						open_spots <- OpenSpots(circles[, 1], circles[, 2], min_separation, EarthRad)
1:nrow(open_spots)
sample(1:nrow(open_spots))
sample(1:nrow(open_spots))[1]
open_spots[sample(1:nrow(open_spots))[1], ]
# Keep adding continents unless they all have starting points:#
					while(N_continents > nrow(circles)) {#
						# Find open spots available for next continent:#
						open_spots <- OpenSpots(circles[, 1], circles[, 2], min_separation, EarthRad)#
						# Error message if too many continents are requested:#
						if(nrow(open_spots) == 0) stop("ERROR: There is not enough space for all your continents! Try making them smaller or choosing fewer of them.")#
#
						# Randomly chose an open spot for the next continent and add to circles:#
						circles <- rbind(circles, open_spots[sample(1:nrow(open_spots))[1], ])#
					}
circles
document()
document()
document()
document()
document()
N_steps = 1000; organism_multiplier = 1; N_continents = 7; radius = 2000; start_configuration = "supercontinent"; squishiness = 0.25; stickiness = 0.95; continent_speed_mean = 5; continent_speed_sd = 2; organism_step_sd = 100; b = 0.1; d = 0.05; EarthRad = 6367.4447; polar = FALSE
# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)
# Start by picking continent start points:#
	for(i in 1:1000) continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)
StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)
StartingPoints(N_continents = 8, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)
StartingPoints(N_continents = 9, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)
StartingPoints(N_continents = 10, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)
StartingPoints(N_continents = 11, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)
StartingPoints(N_continents = 12, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)
StartingPoints(N_continents = 13, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)
StartingPoints(N_continents = 14, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)
StartingPoints(N_continents = 15, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)
StartingPoints(N_continents = 16, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)
StartingPoints(N_continents = 20, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)
StartingPoints(N_continents = 21, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)
StartingPoints(N_continents = 30, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)
StartingPoints(N_continents = 40, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)
StartingPoints(N_continents = 40, radius = 3000, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)
# Subfunction to find out which supercontinent a circle belongs to:#
	which_supercontinent <- function(cont, sprconts){#
		cont <- as.character(cont)#
		result <- which(unlist(lapply(lapply(lapply(strsplit(sprconts, "&"), match, cont), sort), length)) == 1)#
		return(result)#
	}#
	# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)#
# Are any continents joined at start?:#
#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
#
	# Get list of separate continents:#
	separate_continents <- HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
#
	# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
	touching_continents <- HowManySeparateContinents((radius * 2), continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
# Assign Euler poles to each separate continent:#
	# Randomly draw longitudes for each separated continent:#
	euler_pole_longitudes <- runif(length(separate_continents), -180, 180)#
	# Randomly draw latitudes for each separated continent:#
	euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
	# Ensure no latitude is directly at a pole (North or South) by redrawing if any are found:#
	if((sum(euler_pole_latitudes == 90) + sum(euler_pole_latitudes == -90)) > 0) euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
#
# Assign speeds to each separate continent:#
	# Create empty vector to store degrees per step (effectively the speed of movement) for each continent:#
	degrees_per_step <- vector(mode="numeric")#
	# For each separate continent:#
	for(i in 1:length(separate_continents)) {#
		# Get Greate Circle distances from Euler pole to each continent centre:#
		euler_GC_distances <- One2ManyGreatCircleDistance(euler_pole_longitudes[i], euler_pole_latitudes[i], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Longitude"], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Latitude"])#
		# Find GC distance to furthest continent (closest to euler pole "equator") in cluster (as speed will be assigned based on this):#
		furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
		# Randomly draw a continent speed:#
		continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# If a negative or zero speed is picked then redraw:#
		while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# Set degree change per step (effectively the speed):#
		degrees_per_step[i] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
	}#
#
	#starting information for the tree#
	dispersals <- matrix(nrow=0, ncol=5)#
	begin_cont <- ceiling(runif(1, 0, N_continents))#
	life_begins <- EndPoint(continent_starting_points[begin_cont, "Longitude"], continent_starting_points[begin_cont, "Latitude"], runif(1,0,360), runif(1,0,radius))#
	extra.rows <- matrix(NA,nrow=2,ncol= (N_steps * organism_multiplier) + 1)#
	organism_lat_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_long_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_lat_matrix[,1] <- life_begins$lat#
    organism_long_matrix[,1] <- life_begins$lon#
    rownames(organism_lat_matrix) <- rep(begin_cont, 2)#
    rownames(organism_long_matrix) <- rep(begin_cont, 2)#
    edge <- rbind(c(1, 2), c(1, 3)) # this is a starting edge matrix#
    edge.length <- rep(NA, 2)#
    stem.depth <- numeric(2)#
    alive <- rep(TRUE, 2) # marker for live lineages#
    ot <- 0; # time(step) at any point in the tree#
    next.node <- 4#
#
	# Now need to move them!#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	linked <- list()#
	linked[[1]] <- separate_continents#
	names(linked)[[1]] <- "1:1"#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	touching <- list()#
	touching[[1]] <- touching_continents#
#
	#Array to store the positions of every continent at each time step#
	position <- array(NA, c(N_continents, N_steps + 1, 2), c("continent", "timestep", "coordinate"))#
	position[,1,1] <- continent_starting_points[,"Longitude"]#
	position[,1,2] <- continent_starting_points[,"Latitude"]#
#
	temp_position<-matrix(nrow = N_continents, ncol=2)#
#
	progress <- seq(1, N_steps, floor(N_steps/50))#
	cat("Starting time steps \n")#
	cat("Progress \n")#
	cat("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n")#
#
	#for loops to move everything#
	for (t in 2:(N_steps + 1)) {#
		#cat(t, " ")#
		#distances apart before they move#
		starting_distances <- GreatCircleDistanceMatrix(position[,t-1,1], position[,t-1,2])#
#
		for (k in 1:N_continents) {#
			#find current longlat of the circle k#
			start_long <- position[k, t-1, 1]#
			start_lat <- position[k, t-1, 2]#
#
			#Identify which supercontinent, and therefore which element of the euler pole and speed vectors, the circle k belongs to#
			where <- which_supercontinent(k, tail(linked, n=1)[[1]])#
#
			#Find distance of circle from pole#
			distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where], lat2=euler_pole_latitudes[where], Warn = FALSE)#
			#Find bearing of circle from pole#
			init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where], euler_pole_latitudes[where], start_long, start_lat)#
#
			#Find the new bearing of circle from pole according to the speed specified#
			new_bearing <- (init_bearing + degrees_per_step[where]) %% 360#
#
			#Find the new location of the circle#
			new_loc <- EndPoint(euler_pole_longitudes[where], euler_pole_latitudes[where], new_bearing, distance)#
#
			#Add the new loction to the position matrix#
			temp_position[k,1] <- new_loc$long#
			temp_position[k,2] <- new_loc$lat#
#
		}#
#
		#Matrix of the distances between each continent in their new positions, before these are set#
		new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
		comp1 <- vector()#
		comp2 <- vector()#
#
		#Making a vector of whether any continents have collided and should be linked#
		collisions<-matrix(nrow=0, ncol=2)#
		for (q in 1:(N_continents-1)) {#
			for (p in (q+1):N_continents) {#
				comp1 <- all.equal(new_distances[p,q],starting_distances[p,q])#
				comp2 <- new_distances[p,q] <= min_separation#
				if (comp1 != TRUE && comp2 == TRUE) {#
					collisions<-rbind(collisions,c(p,q))#
				}#
			}#
		}#
#
		#Matrix of euler poles and speeds for each individual continent for moving the animals later#
		organism_mover <- matrix(nrow=N_continents, ncol= 3)#
			for (clump in 1:length(tail(linked, n=1)[[1]])) {#
				which_conts <- as.numeric(strsplit(tail(linked, n=1)[[1]][[clump]], "&")[[1]])#
				organism_mover[which_conts,1] <- rep(euler_pole_longitudes[clump],length(which_conts))#
				organism_mover[which_conts,2] <- rep(euler_pole_latitudes[clump],length(which_conts))#
				#This bit will get overwritten if there are collisions#
				organism_mover[which_conts,3] <- rep(degrees_per_step[clump],length(which_conts))#
			}#
#
		perm_collisions <- matrix(nrow=0, ncol=2)#
#
		# Moving continents back if there has only been one collision#
		while(nrow(collisions) > 0) {#
#
			# Set up vector to store proportional changes after collisions#
			proportion <- vector()#
#
			# Find out proportions to reduce to for all potential collisions#
			for (coll in 1:nrow(collisions)) {#
				cont_1 <- collisions[coll,1]#
				cont_2 <- collisions[coll,2]#
				where_1 <- which_supercontinent(cont_1, tail(linked, n=1)[[1]])#
				where_2 <- which_supercontinent(cont_2, tail(linked, n=1)[[1]])#
				continent_1_euler_longitude = euler_pole_longitudes[where_1]#
				continent_1_euler_latitude = euler_pole_latitudes[where_1]#
				continent_2_euler_longitude = euler_pole_longitudes[where_2]#
				continent_2_euler_latitude = euler_pole_latitudes[where_2]#
				continent_1_degrees_per_step = degrees_per_step[where_1]#
				continent_2_degrees_per_step = degrees_per_step[where_2]#
				proportion[coll] <- ColliderReverser(min_separation, position[cont_1, t-1, 1], position[cont_1, t-1, 2], temp_position[cont_1,1], temp_position[cont_1,2], position[cont_2, t-1, 1], position[cont_2, t-1, 2], temp_position[cont_2,1], temp_position[cont_2,2], continent_1_euler_longitude, continent_1_euler_latitude, continent_2_euler_longitude, continent_2_euler_latitude, continent_1_degrees_per_step, continent_2_degrees_per_step, EarthRad = 6367.4447, Warn = FALSE)#
			}#
#
			# Select proportion to move for first collision#
			first_collision <- match(min(proportion),proportion)#
#
			# Find the two continents that collided first#
			cont_involved <- sort(collisions[first_collision, ])#
#
			# Add to matrix of definite collisions that cannot be separated in the next step#
			perm_collisions <- rbind(perm_collisions, cont_involved)#
#
			# Move first clump back#
			head_of_collision_1 <- cont_involved[1]#
			where_1 <- which_supercontinent(head_of_collision_1, tail(linked, n=1)[[1]])#
#
			#Find the other continents that were attached to the collider#
			all_involved <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_1], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents in one of the clumps#
			for (rev in 1:length(all_involved)) {#
				cont_to_rev <- all_involved[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_1], lat2=euler_pole_latitudes[where_1], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], start_long, start_lat)#
#
				#degrees to add#
				addition <- proportion[first_collision] * degrees_per_step[where_1]#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <- (init_bearing + addition) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
#
				organism_mover[cont_to_rev,3] <- addition#
			}#
#
			#Move the second clump back#
			head_of_collision_2 <- cont_involved[2]#
			where_2 <- which_supercontinent(head_of_collision_2, tail(linked, n=1)[[1]])#
			all_involved_2 <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_2], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents the other clump#
			for (rev in 1:length(all_involved_2)) {#
				cont_to_rev <- all_involved_2[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_2], lat2=euler_pole_latitudes[where_2], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], start_long, start_lat)#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <-  (init_bearing + (proportion[first_collision] * degrees_per_step[where_2])) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
			}#
#
			#Recalculate the new distances#
			new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
			comp1 <- vector()#
			comp2 <- vector()#
#
			# Check whether any other collisions have still occurred#
			collisions <- matrix(nrow=0, ncol=2)#
			for (q in 1:(N_continents - 1)) {#
				for (p in (q+1):N_continents) {#
					comp1 <- all.equal(new_distances[p, q], starting_distances[p, q])#
					comp2 <- new_distances[p, q] <= min_separation#
					if (comp1 != TRUE && comp2 == TRUE) {#
						# If collision has not already been recorded:#
						if(length(sort(match(paste(sort(c(q, p)), collapse=""), apply(perm_collisions, 1, paste, collapse="")))) == 0) {#
							# Record collision:#
							collisions <- rbind(collisions, c(p, q))#
						}#
					}#
				}#
			}#
		}#
#
		# When it finishes while loop can now 'ossify' the positions and move to selecting separations#
		position[, t, 1] <- temp_position[, 1]#
		position[, t, 2] <- temp_position[, 2]#
#
# Finding out if anything gets separated#
		# How many separate continents are there now? (after collisions may have occurred):#
		separate_continents <- HowManySeparateContinents(min_separation, position[,t,1], position[,t,2])#
		# Make random uniform draws for each continental cluster:#
		separation_draws <- runif(length(grep("&", separate_continents)))#
		# Case if a separation occurs (drawn value is equal to or exceeds stickiness):#
		if(any(separation_draws >= stickiness)) {#
			# Get clusters of continents to split apart:#
			clusters_to_split <- separate_continents[grep("&", separate_continents)][which(separation_draws >= stickiness)]#
			# For each cluster to split apart:#
			for(i in 1:length(clusters_to_split)) {#
				# Get numbers of continents involved:#
				cluster_continent_numbers <- sort(strsplit(clusters_to_split[i], "&")[[1]])#
				# Get longitudes of continents in cluster:#
				cluster_longitudes <- position[as.numeric(cluster_continent_numbers), t, 1]#
#
				# Get latitudes of continents in cluster:#
				cluster_latitudes <- position[as.numeric(cluster_continent_numbers), t, 2]#
				# Make protected links an empty matrix:#
				cluster_protected_links <- matrix(nrow = 0, ncol = 2)#
				# If there are recent collisions (that will potentially need to be excluded from new splits):#
				if(length(perm_collisions) > 0) {#
					# For each new collision:#
					for(j in 1:nrow(perm_collisions)) {#
						# If new collision occurs within the cluster:#
						if(all(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers) == as.character(perm_collisions[j, ]))) {#
							# Add new collision to protected links list:#
							cluster_protected_links <- rbind(cluster_protected_links, perm_collisions[j, ])#
						}#
					}#
#
				}#
				# Get splits (new clusters) of separated cluster:#
				splits <- ContinentSplitter(min_separation, cluster_longitudes, cluster_latitudes, cluster_continent_numbers, cluster_protected_links, EarthRad)#
				# Update separate continents vector:#
				separate_continents <- sort(c(separate_continents[-match(clusters_to_split[i], separate_continents)], splits))#
			}#
		}#
#
# Now change the Euler poles and speeds#
		# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
		touching_continents <- HowManySeparateContinents((radius * 2), position[,t,1], position[,t,2])#
		if (paste(sort(touching_continents), collapse="") != paste(sort(tail(touching,n=1)[[1]]), collapse="")) {#
			touching <- c(touching, list(touching_continents))#
		}#
#
		# If the continental clustering has changed:#
		if (paste(sort(separate_continents), collapse="") != paste(sort(tail(linked,n=1)[[1]]), collapse="")) {#
			# Add new continental configuration to linked list#
			linked <- c(linked, list(separate_continents))#
#
			# Update time step for previous continental configuration:#
			names(linked)[(length(linked) - 1)] <- paste(strsplit(names(linked[(length(linked) - 1)]), ":")[[1]][1], ":", t - 1, sep="")#
			# Add time step to new continental configuration:#
			names(linked)[length(linked)] <- paste(t, ":", t, sep="")#
			# Select continents that are different to previous time step#
			toKeep <- c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]])[duplicated(c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]]))]#
#
			#Vectors for new poles and speeds#
			new_euler_latitudes <- rep(NA, length(separate_continents))#
			new_euler_longitudes <- rep(NA, length(separate_continents))#
			new_degrees_per_step <- rep(NA, length(separate_continents))#
#
			if (length(toKeep) != 0){#
				#Inherit previous poles and speeds for those clumps that remain the same#
				for (y in 1:length(toKeep)) {#
					new_euler_longitudes[match(toKeep[y],separate_continents)]<- euler_pole_longitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_euler_latitudes[match(toKeep[y],separate_continents)]<- euler_pole_latitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_degrees_per_step[match(toKeep[y],separate_continents)]<- degrees_per_step[match(toKeep[y],tail(linked, n=2)[[1]])]#
				}#
			}#
#
			# Make new Euler poles#
			new_euler_longitudes[is.na(new_euler_longitudes)]<- runif((length(separate_continents)-length(toKeep)), -180, 180)#
#
			changed_euler_latitudes<- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			while((sum(changed_euler_latitudes == 90) + sum(changed_euler_latitudes == -90)) > 0) changed_euler_latitudes <- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			new_euler_latitudes[is.na(new_euler_latitudes)] <- changed_euler_latitudes#
#
			# Get Great Circle distances from Euler pole to each continent centre:#
			for (l in 1:(length(separate_continents)-length(toKeep))) {#
				# Find the first NA to fill in:#
				changer <- match(NA, new_degrees_per_step)#
				#Find the contients that are in the clump whose speed is going to change#
				rows <- as.numeric(unlist(strsplit(separate_continents[changer], "&")))#
				#Find the new euler pole for that clump#
				euler_long <- new_euler_longitudes[changer]#
				euler_lat <- new_euler_latitudes[changer]#
				#Find the distances of each of the continents in the clump from their new euler pole#
				euler_GC_distances <- One2ManyGreatCircleDistance(euler_long, euler_lat, position[rows, t, 1], position[rows, t, 2])#
				#Find which of those is closest to the equator#
				furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
				# Randomly draw a continent speed:#
				continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# If a negative or zero speed is picked then redraw:#
				while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# Set degree change per step (effectively the speed):#
				new_degrees_per_step[changer] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
			}#
			euler_pole_longitudes <- new_euler_longitudes#
			euler_pole_latitudes <- new_euler_latitudes#
			degrees_per_step <- new_degrees_per_step#
		}#
#
#Need to add in the tree bit#
		#Move the animals with the continents#
		for (cont in 1:N_continents) {#
			#Find the rows that are in the continent of focus#
			moving <- which(rownames(organism_long_matrix)==cont)#
#
			if (length(moving)==0) {#
				next #
			} else {#
				#Find out how many degrees around the euler pole that continent went#
				organism_degrees <- organism_mover[cont,3]#
				#loops through all the organisms that are currently living#
				for (organism in 1:length(moving)) {#
					organism_row <- moving[organism]#
					if (is.na(organism_long_matrix[organism_row, ot + 1])) {#
						next#
					} else {#
						first_long <- organism_long_matrix[organism_row, ot + 1]#
						first_lat <- organism_lat_matrix[organism_row, ot + 1]#
						organism_distance <- GreatCircleDistanceFromLongLat(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						organism_bearing <- BearingBetweenTwoLongLatPoints(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						new_organism_bearing <- (organism_bearing + organism_degrees) %% 360#
						new_organism_loc <- EndPoint(organism_mover[cont,1], organism_mover[cont,2], new_organism_bearing, organism_distance)#
						organism_long_matrix[organism_row, ot + 1] <- new_organism_loc$long#
    					organism_lat_matrix[organism_row, ot + 1] <- new_organism_loc$lat#
					}#
				}#
			}#
		}#
		for (f in 1:organism_multiplier) {#
            if (sum(alive) == 0) stop("METEOR IMPACT!! EVERYTHING HAS GONE EXTINCT! AAAAHHHHHH!!!")#
            dt<-1#
            ot <- ot + dt#
            for (m in 1:nrow(organism_lat_matrix)) {#
                if (alive[m]) {#
                    starting<-c(organism_lat_matrix[m,ot],organism_long_matrix[m,ot])#
                    moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd))) #generates a random walk step and calculates new position#
                    on_cont <- as.numeric(rownames(organism_lat_matrix)[m])#
                    friends <- as.numeric(strsplit(tail(touching, n=1)[[1]][which_supercontinent(on_cont, tail(touching, n=1)[[1]])], "&")[[1]])#
                    dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    if (length(friends) > 1) {#
                    	all_dist <- vector(length = length(friends))#
                    	for (g in 1:length(friends)) {#
                    		all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    	}#
                    	while (min(all_dist) > radius) {#
                    		moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		temp_all_dist <- vector(length = length(friends))#
                    		for (g in 1:length(friends)) {#
                    			temp_all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    		}#
                    		all_dist <- temp_all_dist#
                    	}#
                    	new_cont <- friends[which(all_dist == min(all_dist))] #
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                    	rownames(organism_long_matrix)[m] <- new_cont#
                    	rownames(organism_lat_matrix)[m] <- new_cont#
                    	if(new_cont != on_cont) {#
                    		dispersals <- rbind(dispersals, c(on_cont, new_cont, m, t, ot+1))#
                    	}#
                    } else {#
                    	while (dist_from_center >= radius) {#
                    		moveto <- EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    	}#
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                	}#
                }#
            }#
#
            r <- runif(1)#
            if (r <= b/(b + d)) { ###4 #this creates a bifucation in the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                e <- matrix(edge[alive,], ncol = 2)#
                parent <- e[random_lineage,2]#
                x <- which(edge[,2] == parent)#
                new.rows.lat <- new.rows.long <- extra.rows#
                new.rows.lat[, ot+1] <- organism_lat_matrix[x, ot+1] #updates the long and lat matricies with new coordiantes for each lineage#
                new.rows.long[, ot+1] <- organism_long_matrix[x, ot+1]#
                rownames(new.rows.lat) <- rep(rownames(organism_lat_matrix)[x],2)#
                rownames(new.rows.long) <- rep(rownames(organism_long_matrix)[x],2)#
                organism_lat_matrix <- rbind(organism_lat_matrix,new.rows.lat)#
                organism_long_matrix <- rbind(organism_long_matrix,new.rows.long)#
                alive[alive][random_lineage] <- FALSE#
                edge <- rbind(edge, c(parent, next.node), c(parent, next.node + 1))#
                next.node <- next.node + 2#
                alive <- c(alive, TRUE, TRUE)#
                stem.depth <- c(stem.depth, ot, ot)#
                edge.length[x] <- ot - stem.depth[x]#
                edge.length<-c(edge.length, NA, NA)#
            } else {###4 This terminates one of the current lineages on the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                edge.length[alive][random_lineage] <- ot - stem.depth[alive][random_lineage]#
                alive[alive][random_lineage] <- FALSE#
            }###4#
        }#1A#
        if (any(progress == t)) {#
        	cat("- ")#
        }#
    }
linked
stickiness = 1
# Subfunction to find out which supercontinent a circle belongs to:#
	which_supercontinent <- function(cont, sprconts){#
		cont <- as.character(cont)#
		result <- which(unlist(lapply(lapply(lapply(strsplit(sprconts, "&"), match, cont), sort), length)) == 1)#
		return(result)#
	}#
	# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)#
# Are any continents joined at start?:#
#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
#
	# Get list of separate continents:#
	separate_continents <- HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
#
	# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
	touching_continents <- HowManySeparateContinents((radius * 2), continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
# Assign Euler poles to each separate continent:#
	# Randomly draw longitudes for each separated continent:#
	euler_pole_longitudes <- runif(length(separate_continents), -180, 180)#
	# Randomly draw latitudes for each separated continent:#
	euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
	# Ensure no latitude is directly at a pole (North or South) by redrawing if any are found:#
	if((sum(euler_pole_latitudes == 90) + sum(euler_pole_latitudes == -90)) > 0) euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
#
# Assign speeds to each separate continent:#
	# Create empty vector to store degrees per step (effectively the speed of movement) for each continent:#
	degrees_per_step <- vector(mode="numeric")#
	# For each separate continent:#
	for(i in 1:length(separate_continents)) {#
		# Get Greate Circle distances from Euler pole to each continent centre:#
		euler_GC_distances <- One2ManyGreatCircleDistance(euler_pole_longitudes[i], euler_pole_latitudes[i], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Longitude"], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Latitude"])#
		# Find GC distance to furthest continent (closest to euler pole "equator") in cluster (as speed will be assigned based on this):#
		furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
		# Randomly draw a continent speed:#
		continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# If a negative or zero speed is picked then redraw:#
		while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# Set degree change per step (effectively the speed):#
		degrees_per_step[i] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
	}#
#
	#starting information for the tree#
	dispersals <- matrix(nrow=0, ncol=5)#
	begin_cont <- ceiling(runif(1, 0, N_continents))#
	life_begins <- EndPoint(continent_starting_points[begin_cont, "Longitude"], continent_starting_points[begin_cont, "Latitude"], runif(1,0,360), runif(1,0,radius))#
	extra.rows <- matrix(NA,nrow=2,ncol= (N_steps * organism_multiplier) + 1)#
	organism_lat_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_long_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_lat_matrix[,1] <- life_begins$lat#
    organism_long_matrix[,1] <- life_begins$lon#
    rownames(organism_lat_matrix) <- rep(begin_cont, 2)#
    rownames(organism_long_matrix) <- rep(begin_cont, 2)#
    edge <- rbind(c(1, 2), c(1, 3)) # this is a starting edge matrix#
    edge.length <- rep(NA, 2)#
    stem.depth <- numeric(2)#
    alive <- rep(TRUE, 2) # marker for live lineages#
    ot <- 0; # time(step) at any point in the tree#
    next.node <- 4#
#
	# Now need to move them!#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	linked <- list()#
	linked[[1]] <- separate_continents#
	names(linked)[[1]] <- "1:1"#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	touching <- list()#
	touching[[1]] <- touching_continents#
#
	#Array to store the positions of every continent at each time step#
	position <- array(NA, c(N_continents, N_steps + 1, 2), c("continent", "timestep", "coordinate"))#
	position[,1,1] <- continent_starting_points[,"Longitude"]#
	position[,1,2] <- continent_starting_points[,"Latitude"]#
#
	temp_position<-matrix(nrow = N_continents, ncol=2)#
#
	progress <- seq(1, N_steps, floor(N_steps/50))#
	cat("Starting time steps \n")#
	cat("Progress \n")#
	cat("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n")#
#
	#for loops to move everything#
	for (t in 2:(N_steps + 1)) {#
		#cat(t, " ")#
		#distances apart before they move#
		starting_distances <- GreatCircleDistanceMatrix(position[,t-1,1], position[,t-1,2])#
#
		for (k in 1:N_continents) {#
			#find current longlat of the circle k#
			start_long <- position[k, t-1, 1]#
			start_lat <- position[k, t-1, 2]#
#
			#Identify which supercontinent, and therefore which element of the euler pole and speed vectors, the circle k belongs to#
			where <- which_supercontinent(k, tail(linked, n=1)[[1]])#
#
			#Find distance of circle from pole#
			distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where], lat2=euler_pole_latitudes[where], Warn = FALSE)#
			#Find bearing of circle from pole#
			init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where], euler_pole_latitudes[where], start_long, start_lat)#
#
			#Find the new bearing of circle from pole according to the speed specified#
			new_bearing <- (init_bearing + degrees_per_step[where]) %% 360#
#
			#Find the new location of the circle#
			new_loc <- EndPoint(euler_pole_longitudes[where], euler_pole_latitudes[where], new_bearing, distance)#
#
			#Add the new loction to the position matrix#
			temp_position[k,1] <- new_loc$long#
			temp_position[k,2] <- new_loc$lat#
#
		}#
#
		#Matrix of the distances between each continent in their new positions, before these are set#
		new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
		comp1 <- vector()#
		comp2 <- vector()#
#
		#Making a vector of whether any continents have collided and should be linked#
		collisions<-matrix(nrow=0, ncol=2)#
		for (q in 1:(N_continents-1)) {#
			for (p in (q+1):N_continents) {#
				comp1 <- all.equal(new_distances[p,q],starting_distances[p,q])#
				comp2 <- new_distances[p,q] <= min_separation#
				if (comp1 != TRUE && comp2 == TRUE) {#
					collisions<-rbind(collisions,c(p,q))#
				}#
			}#
		}#
#
		#Matrix of euler poles and speeds for each individual continent for moving the animals later#
		organism_mover <- matrix(nrow=N_continents, ncol= 3)#
			for (clump in 1:length(tail(linked, n=1)[[1]])) {#
				which_conts <- as.numeric(strsplit(tail(linked, n=1)[[1]][[clump]], "&")[[1]])#
				organism_mover[which_conts,1] <- rep(euler_pole_longitudes[clump],length(which_conts))#
				organism_mover[which_conts,2] <- rep(euler_pole_latitudes[clump],length(which_conts))#
				#This bit will get overwritten if there are collisions#
				organism_mover[which_conts,3] <- rep(degrees_per_step[clump],length(which_conts))#
			}#
#
		perm_collisions <- matrix(nrow=0, ncol=2)#
#
		# Moving continents back if there has only been one collision#
		while(nrow(collisions) > 0) {#
#
			# Set up vector to store proportional changes after collisions#
			proportion <- vector()#
#
			# Find out proportions to reduce to for all potential collisions#
			for (coll in 1:nrow(collisions)) {#
				cont_1 <- collisions[coll,1]#
				cont_2 <- collisions[coll,2]#
				where_1 <- which_supercontinent(cont_1, tail(linked, n=1)[[1]])#
				where_2 <- which_supercontinent(cont_2, tail(linked, n=1)[[1]])#
				continent_1_euler_longitude = euler_pole_longitudes[where_1]#
				continent_1_euler_latitude = euler_pole_latitudes[where_1]#
				continent_2_euler_longitude = euler_pole_longitudes[where_2]#
				continent_2_euler_latitude = euler_pole_latitudes[where_2]#
				continent_1_degrees_per_step = degrees_per_step[where_1]#
				continent_2_degrees_per_step = degrees_per_step[where_2]#
				proportion[coll] <- ColliderReverser(min_separation, position[cont_1, t-1, 1], position[cont_1, t-1, 2], temp_position[cont_1,1], temp_position[cont_1,2], position[cont_2, t-1, 1], position[cont_2, t-1, 2], temp_position[cont_2,1], temp_position[cont_2,2], continent_1_euler_longitude, continent_1_euler_latitude, continent_2_euler_longitude, continent_2_euler_latitude, continent_1_degrees_per_step, continent_2_degrees_per_step, EarthRad = 6367.4447, Warn = FALSE)#
			}#
#
			# Select proportion to move for first collision#
			first_collision <- match(min(proportion),proportion)#
#
			# Find the two continents that collided first#
			cont_involved <- sort(collisions[first_collision, ])#
#
			# Add to matrix of definite collisions that cannot be separated in the next step#
			perm_collisions <- rbind(perm_collisions, cont_involved)#
#
			# Move first clump back#
			head_of_collision_1 <- cont_involved[1]#
			where_1 <- which_supercontinent(head_of_collision_1, tail(linked, n=1)[[1]])#
#
			#Find the other continents that were attached to the collider#
			all_involved <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_1], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents in one of the clumps#
			for (rev in 1:length(all_involved)) {#
				cont_to_rev <- all_involved[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_1], lat2=euler_pole_latitudes[where_1], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], start_long, start_lat)#
#
				#degrees to add#
				addition <- proportion[first_collision] * degrees_per_step[where_1]#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <- (init_bearing + addition) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
#
				organism_mover[cont_to_rev,3] <- addition#
			}#
#
			#Move the second clump back#
			head_of_collision_2 <- cont_involved[2]#
			where_2 <- which_supercontinent(head_of_collision_2, tail(linked, n=1)[[1]])#
			all_involved_2 <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_2], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents the other clump#
			for (rev in 1:length(all_involved_2)) {#
				cont_to_rev <- all_involved_2[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_2], lat2=euler_pole_latitudes[where_2], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], start_long, start_lat)#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <-  (init_bearing + (proportion[first_collision] * degrees_per_step[where_2])) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
			}#
#
			#Recalculate the new distances#
			new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
			comp1 <- vector()#
			comp2 <- vector()#
#
			# Check whether any other collisions have still occurred#
			collisions <- matrix(nrow=0, ncol=2)#
			for (q in 1:(N_continents - 1)) {#
				for (p in (q+1):N_continents) {#
					comp1 <- all.equal(new_distances[p, q], starting_distances[p, q])#
					comp2 <- new_distances[p, q] <= min_separation#
					if (comp1 != TRUE && comp2 == TRUE) {#
						# If collision has not already been recorded:#
						if(length(sort(match(paste(sort(c(q, p)), collapse=""), apply(perm_collisions, 1, paste, collapse="")))) == 0) {#
							# Record collision:#
							collisions <- rbind(collisions, c(p, q))#
						}#
					}#
				}#
			}#
		}#
#
		# When it finishes while loop can now 'ossify' the positions and move to selecting separations#
		position[, t, 1] <- temp_position[, 1]#
		position[, t, 2] <- temp_position[, 2]#
#
# Finding out if anything gets separated#
		# How many separate continents are there now? (after collisions may have occurred):#
		separate_continents <- HowManySeparateContinents(min_separation, position[,t,1], position[,t,2])#
		# Make random uniform draws for each continental cluster:#
		separation_draws <- runif(length(grep("&", separate_continents)))#
		# Case if a separation occurs (drawn value is equal to or exceeds stickiness):#
		if(any(separation_draws >= stickiness)) {#
			# Get clusters of continents to split apart:#
			clusters_to_split <- separate_continents[grep("&", separate_continents)][which(separation_draws >= stickiness)]#
			# For each cluster to split apart:#
			for(i in 1:length(clusters_to_split)) {#
				# Get numbers of continents involved:#
				cluster_continent_numbers <- sort(strsplit(clusters_to_split[i], "&")[[1]])#
				# Get longitudes of continents in cluster:#
				cluster_longitudes <- position[as.numeric(cluster_continent_numbers), t, 1]#
#
				# Get latitudes of continents in cluster:#
				cluster_latitudes <- position[as.numeric(cluster_continent_numbers), t, 2]#
				# Make protected links an empty matrix:#
				cluster_protected_links <- matrix(nrow = 0, ncol = 2)#
				# If there are recent collisions (that will potentially need to be excluded from new splits):#
				if(length(perm_collisions) > 0) {#
					# For each new collision:#
					for(j in 1:nrow(perm_collisions)) {#
						# If new collision occurs within the cluster:#
						if(all(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers) == as.character(perm_collisions[j, ]))) {#
							# Add new collision to protected links list:#
							cluster_protected_links <- rbind(cluster_protected_links, perm_collisions[j, ])#
						}#
					}#
#
				}#
				# Get splits (new clusters) of separated cluster:#
				splits <- ContinentSplitter(min_separation, cluster_longitudes, cluster_latitudes, cluster_continent_numbers, cluster_protected_links, EarthRad)#
				# Update separate continents vector:#
				separate_continents <- sort(c(separate_continents[-match(clusters_to_split[i], separate_continents)], splits))#
			}#
		}#
#
# Now change the Euler poles and speeds#
		# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
		touching_continents <- HowManySeparateContinents((radius * 2), position[,t,1], position[,t,2])#
		if (paste(sort(touching_continents), collapse="") != paste(sort(tail(touching,n=1)[[1]]), collapse="")) {#
			touching <- c(touching, list(touching_continents))#
		}#
#
		# If the continental clustering has changed:#
		if (paste(sort(separate_continents), collapse="") != paste(sort(tail(linked,n=1)[[1]]), collapse="")) {#
			# Add new continental configuration to linked list#
			linked <- c(linked, list(separate_continents))#
#
			# Update time step for previous continental configuration:#
			names(linked)[(length(linked) - 1)] <- paste(strsplit(names(linked[(length(linked) - 1)]), ":")[[1]][1], ":", t - 1, sep="")#
			# Add time step to new continental configuration:#
			names(linked)[length(linked)] <- paste(t, ":", t, sep="")#
			# Select continents that are different to previous time step#
			toKeep <- c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]])[duplicated(c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]]))]#
#
			#Vectors for new poles and speeds#
			new_euler_latitudes <- rep(NA, length(separate_continents))#
			new_euler_longitudes <- rep(NA, length(separate_continents))#
			new_degrees_per_step <- rep(NA, length(separate_continents))#
#
			if (length(toKeep) != 0){#
				#Inherit previous poles and speeds for those clumps that remain the same#
				for (y in 1:length(toKeep)) {#
					new_euler_longitudes[match(toKeep[y],separate_continents)]<- euler_pole_longitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_euler_latitudes[match(toKeep[y],separate_continents)]<- euler_pole_latitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_degrees_per_step[match(toKeep[y],separate_continents)]<- degrees_per_step[match(toKeep[y],tail(linked, n=2)[[1]])]#
				}#
			}#
#
			# Make new Euler poles#
			new_euler_longitudes[is.na(new_euler_longitudes)]<- runif((length(separate_continents)-length(toKeep)), -180, 180)#
#
			changed_euler_latitudes<- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			while((sum(changed_euler_latitudes == 90) + sum(changed_euler_latitudes == -90)) > 0) changed_euler_latitudes <- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			new_euler_latitudes[is.na(new_euler_latitudes)] <- changed_euler_latitudes#
#
			# Get Great Circle distances from Euler pole to each continent centre:#
			for (l in 1:(length(separate_continents)-length(toKeep))) {#
				# Find the first NA to fill in:#
				changer <- match(NA, new_degrees_per_step)#
				#Find the contients that are in the clump whose speed is going to change#
				rows <- as.numeric(unlist(strsplit(separate_continents[changer], "&")))#
				#Find the new euler pole for that clump#
				euler_long <- new_euler_longitudes[changer]#
				euler_lat <- new_euler_latitudes[changer]#
				#Find the distances of each of the continents in the clump from their new euler pole#
				euler_GC_distances <- One2ManyGreatCircleDistance(euler_long, euler_lat, position[rows, t, 1], position[rows, t, 2])#
				#Find which of those is closest to the equator#
				furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
				# Randomly draw a continent speed:#
				continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# If a negative or zero speed is picked then redraw:#
				while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# Set degree change per step (effectively the speed):#
				new_degrees_per_step[changer] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
			}#
			euler_pole_longitudes <- new_euler_longitudes#
			euler_pole_latitudes <- new_euler_latitudes#
			degrees_per_step <- new_degrees_per_step#
		}#
#
#Need to add in the tree bit#
		#Move the animals with the continents#
		for (cont in 1:N_continents) {#
			#Find the rows that are in the continent of focus#
			moving <- which(rownames(organism_long_matrix)==cont)#
#
			if (length(moving)==0) {#
				next #
			} else {#
				#Find out how many degrees around the euler pole that continent went#
				organism_degrees <- organism_mover[cont,3]#
				#loops through all the organisms that are currently living#
				for (organism in 1:length(moving)) {#
					organism_row <- moving[organism]#
					if (is.na(organism_long_matrix[organism_row, ot + 1])) {#
						next#
					} else {#
						first_long <- organism_long_matrix[organism_row, ot + 1]#
						first_lat <- organism_lat_matrix[organism_row, ot + 1]#
						organism_distance <- GreatCircleDistanceFromLongLat(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						organism_bearing <- BearingBetweenTwoLongLatPoints(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						new_organism_bearing <- (organism_bearing + organism_degrees) %% 360#
						new_organism_loc <- EndPoint(organism_mover[cont,1], organism_mover[cont,2], new_organism_bearing, organism_distance)#
						organism_long_matrix[organism_row, ot + 1] <- new_organism_loc$long#
    					organism_lat_matrix[organism_row, ot + 1] <- new_organism_loc$lat#
					}#
				}#
			}#
		}#
		for (f in 1:organism_multiplier) {#
            if (sum(alive) == 0) stop("METEOR IMPACT!! EVERYTHING HAS GONE EXTINCT! AAAAHHHHHH!!!")#
            dt<-1#
            ot <- ot + dt#
            for (m in 1:nrow(organism_lat_matrix)) {#
                if (alive[m]) {#
                    starting<-c(organism_lat_matrix[m,ot],organism_long_matrix[m,ot])#
                    moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd))) #generates a random walk step and calculates new position#
                    on_cont <- as.numeric(rownames(organism_lat_matrix)[m])#
                    friends <- as.numeric(strsplit(tail(touching, n=1)[[1]][which_supercontinent(on_cont, tail(touching, n=1)[[1]])], "&")[[1]])#
                    dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    if (length(friends) > 1) {#
                    	all_dist <- vector(length = length(friends))#
                    	for (g in 1:length(friends)) {#
                    		all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    	}#
                    	while (min(all_dist) > radius) {#
                    		moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		temp_all_dist <- vector(length = length(friends))#
                    		for (g in 1:length(friends)) {#
                    			temp_all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    		}#
                    		all_dist <- temp_all_dist#
                    	}#
                    	new_cont <- friends[which(all_dist == min(all_dist))] #
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                    	rownames(organism_long_matrix)[m] <- new_cont#
                    	rownames(organism_lat_matrix)[m] <- new_cont#
                    	if(new_cont != on_cont) {#
                    		dispersals <- rbind(dispersals, c(on_cont, new_cont, m, t, ot+1))#
                    	}#
                    } else {#
                    	while (dist_from_center >= radius) {#
                    		moveto <- EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    	}#
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                	}#
                }#
            }#
#
            r <- runif(1)#
            if (r <= b/(b + d)) { ###4 #this creates a bifucation in the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                e <- matrix(edge[alive,], ncol = 2)#
                parent <- e[random_lineage,2]#
                x <- which(edge[,2] == parent)#
                new.rows.lat <- new.rows.long <- extra.rows#
                new.rows.lat[, ot+1] <- organism_lat_matrix[x, ot+1] #updates the long and lat matricies with new coordiantes for each lineage#
                new.rows.long[, ot+1] <- organism_long_matrix[x, ot+1]#
                rownames(new.rows.lat) <- rep(rownames(organism_lat_matrix)[x],2)#
                rownames(new.rows.long) <- rep(rownames(organism_long_matrix)[x],2)#
                organism_lat_matrix <- rbind(organism_lat_matrix,new.rows.lat)#
                organism_long_matrix <- rbind(organism_long_matrix,new.rows.long)#
                alive[alive][random_lineage] <- FALSE#
                edge <- rbind(edge, c(parent, next.node), c(parent, next.node + 1))#
                next.node <- next.node + 2#
                alive <- c(alive, TRUE, TRUE)#
                stem.depth <- c(stem.depth, ot, ot)#
                edge.length[x] <- ot - stem.depth[x]#
                edge.length<-c(edge.length, NA, NA)#
            } else {###4 This terminates one of the current lineages on the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                edge.length[alive][random_lineage] <- ot - stem.depth[alive][random_lineage]#
                alive[alive][random_lineage] <- FALSE#
            }###4#
        }#1A#
        if (any(progress == t)) {#
        	cat("- ")#
        }#
    }
# Subfunction to find out which supercontinent a circle belongs to:#
	which_supercontinent <- function(cont, sprconts){#
		cont <- as.character(cont)#
		result <- which(unlist(lapply(lapply(lapply(strsplit(sprconts, "&"), match, cont), sort), length)) == 1)#
		return(result)#
	}#
	# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)#
# Are any continents joined at start?:#
#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
#
	# Get list of separate continents:#
	separate_continents <- HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
#
	# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
	touching_continents <- HowManySeparateContinents((radius * 2), continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
# Assign Euler poles to each separate continent:#
	# Randomly draw longitudes for each separated continent:#
	euler_pole_longitudes <- runif(length(separate_continents), -180, 180)#
	# Randomly draw latitudes for each separated continent:#
	euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
	# Ensure no latitude is directly at a pole (North or South) by redrawing if any are found:#
	if((sum(euler_pole_latitudes == 90) + sum(euler_pole_latitudes == -90)) > 0) euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
#
# Assign speeds to each separate continent:#
	# Create empty vector to store degrees per step (effectively the speed of movement) for each continent:#
	degrees_per_step <- vector(mode="numeric")#
	# For each separate continent:#
	for(i in 1:length(separate_continents)) {#
		# Get Greate Circle distances from Euler pole to each continent centre:#
		euler_GC_distances <- One2ManyGreatCircleDistance(euler_pole_longitudes[i], euler_pole_latitudes[i], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Longitude"], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Latitude"])#
		# Find GC distance to furthest continent (closest to euler pole "equator") in cluster (as speed will be assigned based on this):#
		furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
		# Randomly draw a continent speed:#
		continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# If a negative or zero speed is picked then redraw:#
		while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# Set degree change per step (effectively the speed):#
		degrees_per_step[i] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
	}#
#
	#starting information for the tree#
	dispersals <- matrix(nrow=0, ncol=5)#
	begin_cont <- ceiling(runif(1, 0, N_continents))#
	life_begins <- EndPoint(continent_starting_points[begin_cont, "Longitude"], continent_starting_points[begin_cont, "Latitude"], runif(1,0,360), runif(1,0,radius))#
	extra.rows <- matrix(NA,nrow=2,ncol= (N_steps * organism_multiplier) + 1)#
	organism_lat_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_long_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_lat_matrix[,1] <- life_begins$lat#
    organism_long_matrix[,1] <- life_begins$lon#
    rownames(organism_lat_matrix) <- rep(begin_cont, 2)#
    rownames(organism_long_matrix) <- rep(begin_cont, 2)#
    edge <- rbind(c(1, 2), c(1, 3)) # this is a starting edge matrix#
    edge.length <- rep(NA, 2)#
    stem.depth <- numeric(2)#
    alive <- rep(TRUE, 2) # marker for live lineages#
    ot <- 0; # time(step) at any point in the tree#
    next.node <- 4#
#
	# Now need to move them!#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	linked <- list()#
	linked[[1]] <- separate_continents#
	names(linked)[[1]] <- "1:1"#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	touching <- list()#
	touching[[1]] <- touching_continents#
#
	#Array to store the positions of every continent at each time step#
	position <- array(NA, c(N_continents, N_steps + 1, 2), c("continent", "timestep", "coordinate"))#
	position[,1,1] <- continent_starting_points[,"Longitude"]#
	position[,1,2] <- continent_starting_points[,"Latitude"]#
#
	temp_position<-matrix(nrow = N_continents, ncol=2)#
#
	progress <- seq(1, N_steps, floor(N_steps/50))#
	cat("Starting time steps \n")#
	cat("Progress \n")#
	cat("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n")#
#
	#for loops to move everything#
	for (t in 2:(N_steps + 1)) {#
		#cat(t, " ")#
		#distances apart before they move#
		starting_distances <- GreatCircleDistanceMatrix(position[,t-1,1], position[,t-1,2])#
#
		for (k in 1:N_continents) {#
			#find current longlat of the circle k#
			start_long <- position[k, t-1, 1]#
			start_lat <- position[k, t-1, 2]#
#
			#Identify which supercontinent, and therefore which element of the euler pole and speed vectors, the circle k belongs to#
			where <- which_supercontinent(k, tail(linked, n=1)[[1]])#
#
			#Find distance of circle from pole#
			distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where], lat2=euler_pole_latitudes[where], Warn = FALSE)#
			#Find bearing of circle from pole#
			init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where], euler_pole_latitudes[where], start_long, start_lat)#
#
			#Find the new bearing of circle from pole according to the speed specified#
			new_bearing <- (init_bearing + degrees_per_step[where]) %% 360#
#
			#Find the new location of the circle#
			new_loc <- EndPoint(euler_pole_longitudes[where], euler_pole_latitudes[where], new_bearing, distance)#
#
			#Add the new loction to the position matrix#
			temp_position[k,1] <- new_loc$long#
			temp_position[k,2] <- new_loc$lat#
#
		}#
#
		#Matrix of the distances between each continent in their new positions, before these are set#
		new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
		comp1 <- vector()#
		comp2 <- vector()#
#
		#Making a vector of whether any continents have collided and should be linked#
		collisions<-matrix(nrow=0, ncol=2)#
		for (q in 1:(N_continents-1)) {#
			for (p in (q+1):N_continents) {#
				comp1 <- all.equal(new_distances[p,q],starting_distances[p,q])#
				comp2 <- new_distances[p,q] <= min_separation#
				if (comp1 != TRUE && comp2 == TRUE) {#
					collisions<-rbind(collisions,c(p,q))#
				}#
			}#
		}#
#
		#Matrix of euler poles and speeds for each individual continent for moving the animals later#
		organism_mover <- matrix(nrow=N_continents, ncol= 3)#
			for (clump in 1:length(tail(linked, n=1)[[1]])) {#
				which_conts <- as.numeric(strsplit(tail(linked, n=1)[[1]][[clump]], "&")[[1]])#
				organism_mover[which_conts,1] <- rep(euler_pole_longitudes[clump],length(which_conts))#
				organism_mover[which_conts,2] <- rep(euler_pole_latitudes[clump],length(which_conts))#
				#This bit will get overwritten if there are collisions#
				organism_mover[which_conts,3] <- rep(degrees_per_step[clump],length(which_conts))#
			}#
#
		perm_collisions <- matrix(nrow=0, ncol=2)#
#
		# Moving continents back if there has only been one collision#
		while(nrow(collisions) > 0) {#
#
			# Set up vector to store proportional changes after collisions#
			proportion <- vector()#
#
			# Find out proportions to reduce to for all potential collisions#
			for (coll in 1:nrow(collisions)) {#
				cont_1 <- collisions[coll,1]#
				cont_2 <- collisions[coll,2]#
				where_1 <- which_supercontinent(cont_1, tail(linked, n=1)[[1]])#
				where_2 <- which_supercontinent(cont_2, tail(linked, n=1)[[1]])#
				continent_1_euler_longitude = euler_pole_longitudes[where_1]#
				continent_1_euler_latitude = euler_pole_latitudes[where_1]#
				continent_2_euler_longitude = euler_pole_longitudes[where_2]#
				continent_2_euler_latitude = euler_pole_latitudes[where_2]#
				continent_1_degrees_per_step = degrees_per_step[where_1]#
				continent_2_degrees_per_step = degrees_per_step[where_2]#
				proportion[coll] <- ColliderReverser(min_separation, position[cont_1, t-1, 1], position[cont_1, t-1, 2], temp_position[cont_1,1], temp_position[cont_1,2], position[cont_2, t-1, 1], position[cont_2, t-1, 2], temp_position[cont_2,1], temp_position[cont_2,2], continent_1_euler_longitude, continent_1_euler_latitude, continent_2_euler_longitude, continent_2_euler_latitude, continent_1_degrees_per_step, continent_2_degrees_per_step, EarthRad = 6367.4447, Warn = FALSE)#
			}#
#
			# Select proportion to move for first collision#
			first_collision <- match(min(proportion),proportion)#
#
			# Find the two continents that collided first#
			cont_involved <- sort(collisions[first_collision, ])#
#
			# Add to matrix of definite collisions that cannot be separated in the next step#
			perm_collisions <- rbind(perm_collisions, cont_involved)#
#
			# Move first clump back#
			head_of_collision_1 <- cont_involved[1]#
			where_1 <- which_supercontinent(head_of_collision_1, tail(linked, n=1)[[1]])#
#
			#Find the other continents that were attached to the collider#
			all_involved <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_1], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents in one of the clumps#
			for (rev in 1:length(all_involved)) {#
				cont_to_rev <- all_involved[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_1], lat2=euler_pole_latitudes[where_1], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], start_long, start_lat)#
#
				#degrees to add#
				addition <- proportion[first_collision] * degrees_per_step[where_1]#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <- (init_bearing + addition) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
#
				organism_mover[cont_to_rev,3] <- addition#
			}#
#
			#Move the second clump back#
			head_of_collision_2 <- cont_involved[2]#
			where_2 <- which_supercontinent(head_of_collision_2, tail(linked, n=1)[[1]])#
			all_involved_2 <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_2], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents the other clump#
			for (rev in 1:length(all_involved_2)) {#
				cont_to_rev <- all_involved_2[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_2], lat2=euler_pole_latitudes[where_2], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], start_long, start_lat)#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <-  (init_bearing + (proportion[first_collision] * degrees_per_step[where_2])) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
			}#
#
			#Recalculate the new distances#
			new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
			comp1 <- vector()#
			comp2 <- vector()#
#
			# Check whether any other collisions have still occurred#
			collisions <- matrix(nrow=0, ncol=2)#
			for (q in 1:(N_continents - 1)) {#
				for (p in (q+1):N_continents) {#
					comp1 <- all.equal(new_distances[p, q], starting_distances[p, q])#
					comp2 <- new_distances[p, q] <= min_separation#
					if (comp1 != TRUE && comp2 == TRUE) {#
						# If collision has not already been recorded:#
						if(length(sort(match(paste(sort(c(q, p)), collapse=""), apply(perm_collisions, 1, paste, collapse="")))) == 0) {#
							# Record collision:#
							collisions <- rbind(collisions, c(p, q))#
						}#
					}#
				}#
			}#
		}#
#
		# When it finishes while loop can now 'ossify' the positions and move to selecting separations#
		position[, t, 1] <- temp_position[, 1]#
		position[, t, 2] <- temp_position[, 2]#
#
# Finding out if anything gets separated#
		# How many separate continents are there now? (after collisions may have occurred):#
		separate_continents <- HowManySeparateContinents(min_separation, position[,t,1], position[,t,2])#
		# Make random uniform draws for each continental cluster:#
		separation_draws <- runif(length(grep("&", separate_continents)))#
		# Case if a separation occurs (drawn value is equal to or exceeds stickiness):#
		if(any(separation_draws >= stickiness)) {#
			# Get clusters of continents to split apart:#
			clusters_to_split <- separate_continents[grep("&", separate_continents)][which(separation_draws >= stickiness)]#
			# For each cluster to split apart:#
			for(i in 1:length(clusters_to_split)) {#
				# Get numbers of continents involved:#
				cluster_continent_numbers <- sort(strsplit(clusters_to_split[i], "&")[[1]])#
				# Get longitudes of continents in cluster:#
				cluster_longitudes <- position[as.numeric(cluster_continent_numbers), t, 1]#
#
				# Get latitudes of continents in cluster:#
				cluster_latitudes <- position[as.numeric(cluster_continent_numbers), t, 2]#
				# Make protected links an empty matrix:#
				cluster_protected_links <- matrix(nrow = 0, ncol = 2)#
				# If there are recent collisions (that will potentially need to be excluded from new splits):#
				if(length(perm_collisions) > 0) {#
					# For each new collision:#
					for(j in 1:nrow(perm_collisions)) {#
						# If new collision occurs within the cluster:#
						if(all(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers) == as.character(perm_collisions[j, ]))) {#
							# Add new collision to protected links list:#
							cluster_protected_links <- rbind(cluster_protected_links, perm_collisions[j, ])#
						}#
					}#
#
				}#
				# Get splits (new clusters) of separated cluster:#
				splits <- ContinentSplitter(min_separation, cluster_longitudes, cluster_latitudes, cluster_continent_numbers, cluster_protected_links, EarthRad)#
				# Update separate continents vector:#
				separate_continents <- sort(c(separate_continents[-match(clusters_to_split[i], separate_continents)], splits))#
			}#
		}#
#
# Now change the Euler poles and speeds#
		# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
		touching_continents <- HowManySeparateContinents((radius * 2), position[,t,1], position[,t,2])#
		if (paste(sort(touching_continents), collapse="") != paste(sort(tail(touching,n=1)[[1]]), collapse="")) {#
			touching <- c(touching, list(touching_continents))#
		}#
#
		# If the continental clustering has changed:#
		if (paste(sort(separate_continents), collapse="") != paste(sort(tail(linked,n=1)[[1]]), collapse="")) {#
			# Add new continental configuration to linked list#
			linked <- c(linked, list(separate_continents))#
#
			# Update time step for previous continental configuration:#
			names(linked)[(length(linked) - 1)] <- paste(strsplit(names(linked[(length(linked) - 1)]), ":")[[1]][1], ":", t - 1, sep="")#
			# Add time step to new continental configuration:#
			names(linked)[length(linked)] <- paste(t, ":", t, sep="")#
			# Select continents that are different to previous time step#
			toKeep <- c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]])[duplicated(c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]]))]#
#
			#Vectors for new poles and speeds#
			new_euler_latitudes <- rep(NA, length(separate_continents))#
			new_euler_longitudes <- rep(NA, length(separate_continents))#
			new_degrees_per_step <- rep(NA, length(separate_continents))#
#
			if (length(toKeep) != 0){#
				#Inherit previous poles and speeds for those clumps that remain the same#
				for (y in 1:length(toKeep)) {#
					new_euler_longitudes[match(toKeep[y],separate_continents)]<- euler_pole_longitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_euler_latitudes[match(toKeep[y],separate_continents)]<- euler_pole_latitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_degrees_per_step[match(toKeep[y],separate_continents)]<- degrees_per_step[match(toKeep[y],tail(linked, n=2)[[1]])]#
				}#
			}#
#
			# Make new Euler poles#
			new_euler_longitudes[is.na(new_euler_longitudes)]<- runif((length(separate_continents)-length(toKeep)), -180, 180)#
#
			changed_euler_latitudes<- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			while((sum(changed_euler_latitudes == 90) + sum(changed_euler_latitudes == -90)) > 0) changed_euler_latitudes <- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			new_euler_latitudes[is.na(new_euler_latitudes)] <- changed_euler_latitudes#
#
			# Get Great Circle distances from Euler pole to each continent centre:#
			for (l in 1:(length(separate_continents)-length(toKeep))) {#
				# Find the first NA to fill in:#
				changer <- match(NA, new_degrees_per_step)#
				#Find the contients that are in the clump whose speed is going to change#
				rows <- as.numeric(unlist(strsplit(separate_continents[changer], "&")))#
				#Find the new euler pole for that clump#
				euler_long <- new_euler_longitudes[changer]#
				euler_lat <- new_euler_latitudes[changer]#
				#Find the distances of each of the continents in the clump from their new euler pole#
				euler_GC_distances <- One2ManyGreatCircleDistance(euler_long, euler_lat, position[rows, t, 1], position[rows, t, 2])#
				#Find which of those is closest to the equator#
				furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
				# Randomly draw a continent speed:#
				continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# If a negative or zero speed is picked then redraw:#
				while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# Set degree change per step (effectively the speed):#
				new_degrees_per_step[changer] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
			}#
			euler_pole_longitudes <- new_euler_longitudes#
			euler_pole_latitudes <- new_euler_latitudes#
			degrees_per_step <- new_degrees_per_step#
		}#
#
#Need to add in the tree bit#
		#Move the animals with the continents#
		for (cont in 1:N_continents) {#
			#Find the rows that are in the continent of focus#
			moving <- which(rownames(organism_long_matrix)==cont)#
#
			if (length(moving)==0) {#
				next #
			} else {#
				#Find out how many degrees around the euler pole that continent went#
				organism_degrees <- organism_mover[cont,3]#
				#loops through all the organisms that are currently living#
				for (organism in 1:length(moving)) {#
					organism_row <- moving[organism]#
					if (is.na(organism_long_matrix[organism_row, ot + 1])) {#
						next#
					} else {#
						first_long <- organism_long_matrix[organism_row, ot + 1]#
						first_lat <- organism_lat_matrix[organism_row, ot + 1]#
						organism_distance <- GreatCircleDistanceFromLongLat(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						organism_bearing <- BearingBetweenTwoLongLatPoints(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						new_organism_bearing <- (organism_bearing + organism_degrees) %% 360#
						new_organism_loc <- EndPoint(organism_mover[cont,1], organism_mover[cont,2], new_organism_bearing, organism_distance)#
						organism_long_matrix[organism_row, ot + 1] <- new_organism_loc$long#
    					organism_lat_matrix[organism_row, ot + 1] <- new_organism_loc$lat#
					}#
				}#
			}#
		}#
		for (f in 1:organism_multiplier) {#
            if (sum(alive) == 0) stop("METEOR IMPACT!! EVERYTHING HAS GONE EXTINCT! AAAAHHHHHH!!!")#
            dt<-1#
            ot <- ot + dt#
            for (m in 1:nrow(organism_lat_matrix)) {#
                if (alive[m]) {#
                    starting<-c(organism_lat_matrix[m,ot],organism_long_matrix[m,ot])#
                    moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd))) #generates a random walk step and calculates new position#
                    on_cont <- as.numeric(rownames(organism_lat_matrix)[m])#
                    friends <- as.numeric(strsplit(tail(touching, n=1)[[1]][which_supercontinent(on_cont, tail(touching, n=1)[[1]])], "&")[[1]])#
                    dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    if (length(friends) > 1) {#
                    	all_dist <- vector(length = length(friends))#
                    	for (g in 1:length(friends)) {#
                    		all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    	}#
                    	while (min(all_dist) > radius) {#
                    		moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		temp_all_dist <- vector(length = length(friends))#
                    		for (g in 1:length(friends)) {#
                    			temp_all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    		}#
                    		all_dist <- temp_all_dist#
                    	}#
                    	new_cont <- friends[which(all_dist == min(all_dist))] #
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                    	rownames(organism_long_matrix)[m] <- new_cont#
                    	rownames(organism_lat_matrix)[m] <- new_cont#
                    	if(new_cont != on_cont) {#
                    		dispersals <- rbind(dispersals, c(on_cont, new_cont, m, t, ot+1))#
                    	}#
                    } else {#
                    	while (dist_from_center >= radius) {#
                    		moveto <- EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    	}#
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                	}#
                }#
            }#
#
            r <- runif(1)#
            if (r <= b/(b + d)) { ###4 #this creates a bifucation in the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                e <- matrix(edge[alive,], ncol = 2)#
                parent <- e[random_lineage,2]#
                x <- which(edge[,2] == parent)#
                new.rows.lat <- new.rows.long <- extra.rows#
                new.rows.lat[, ot+1] <- organism_lat_matrix[x, ot+1] #updates the long and lat matricies with new coordiantes for each lineage#
                new.rows.long[, ot+1] <- organism_long_matrix[x, ot+1]#
                rownames(new.rows.lat) <- rep(rownames(organism_lat_matrix)[x],2)#
                rownames(new.rows.long) <- rep(rownames(organism_long_matrix)[x],2)#
                organism_lat_matrix <- rbind(organism_lat_matrix,new.rows.lat)#
                organism_long_matrix <- rbind(organism_long_matrix,new.rows.long)#
                alive[alive][random_lineage] <- FALSE#
                edge <- rbind(edge, c(parent, next.node), c(parent, next.node + 1))#
                next.node <- next.node + 2#
                alive <- c(alive, TRUE, TRUE)#
                stem.depth <- c(stem.depth, ot, ot)#
                edge.length[x] <- ot - stem.depth[x]#
                edge.length<-c(edge.length, NA, NA)#
            } else {###4 This terminates one of the current lineages on the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                edge.length[alive][random_lineage] <- ot - stem.depth[alive][random_lineage]#
                alive[alive][random_lineage] <- FALSE#
            }###4#
        }#1A#
        if (any(progress == t)) {#
        	cat("- ")#
        }#
    }
linked
stickiness <- 0.95
# Subfunction to find out which supercontinent a circle belongs to:#
	which_supercontinent <- function(cont, sprconts){#
		cont <- as.character(cont)#
		result <- which(unlist(lapply(lapply(lapply(strsplit(sprconts, "&"), match, cont), sort), length)) == 1)#
		return(result)#
	}#
	# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)#
# Are any continents joined at start?:#
#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
#
	# Get list of separate continents:#
	separate_continents <- HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
#
	# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
	touching_continents <- HowManySeparateContinents((radius * 2), continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
# Assign Euler poles to each separate continent:#
	# Randomly draw longitudes for each separated continent:#
	euler_pole_longitudes <- runif(length(separate_continents), -180, 180)#
	# Randomly draw latitudes for each separated continent:#
	euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
	# Ensure no latitude is directly at a pole (North or South) by redrawing if any are found:#
	if((sum(euler_pole_latitudes == 90) + sum(euler_pole_latitudes == -90)) > 0) euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
#
# Assign speeds to each separate continent:#
	# Create empty vector to store degrees per step (effectively the speed of movement) for each continent:#
	degrees_per_step <- vector(mode="numeric")#
	# For each separate continent:#
	for(i in 1:length(separate_continents)) {#
		# Get Greate Circle distances from Euler pole to each continent centre:#
		euler_GC_distances <- One2ManyGreatCircleDistance(euler_pole_longitudes[i], euler_pole_latitudes[i], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Longitude"], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Latitude"])#
		# Find GC distance to furthest continent (closest to euler pole "equator") in cluster (as speed will be assigned based on this):#
		furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
		# Randomly draw a continent speed:#
		continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# If a negative or zero speed is picked then redraw:#
		while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# Set degree change per step (effectively the speed):#
		degrees_per_step[i] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
	}#
#
	#starting information for the tree#
	dispersals <- matrix(nrow=0, ncol=5)#
	begin_cont <- ceiling(runif(1, 0, N_continents))#
	life_begins <- EndPoint(continent_starting_points[begin_cont, "Longitude"], continent_starting_points[begin_cont, "Latitude"], runif(1,0,360), runif(1,0,radius))#
	extra.rows <- matrix(NA,nrow=2,ncol= (N_steps * organism_multiplier) + 1)#
	organism_lat_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_long_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_lat_matrix[,1] <- life_begins$lat#
    organism_long_matrix[,1] <- life_begins$lon#
    rownames(organism_lat_matrix) <- rep(begin_cont, 2)#
    rownames(organism_long_matrix) <- rep(begin_cont, 2)#
    edge <- rbind(c(1, 2), c(1, 3)) # this is a starting edge matrix#
    edge.length <- rep(NA, 2)#
    stem.depth <- numeric(2)#
    alive <- rep(TRUE, 2) # marker for live lineages#
    ot <- 0; # time(step) at any point in the tree#
    next.node <- 4#
#
	# Now need to move them!#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	linked <- list()#
	linked[[1]] <- separate_continents#
	names(linked)[[1]] <- "1:1"#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	touching <- list()#
	touching[[1]] <- touching_continents#
#
	#Array to store the positions of every continent at each time step#
	position <- array(NA, c(N_continents, N_steps + 1, 2), c("continent", "timestep", "coordinate"))#
	position[,1,1] <- continent_starting_points[,"Longitude"]#
	position[,1,2] <- continent_starting_points[,"Latitude"]#
#
	temp_position<-matrix(nrow = N_continents, ncol=2)#
#
	progress <- seq(1, N_steps, floor(N_steps/50))#
	cat("Starting time steps \n")#
	cat("Progress \n")#
	cat("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n")#
#
	#for loops to move everything#
	for (t in 2:(N_steps + 1)) {#
		#cat(t, " ")#
		#distances apart before they move#
		starting_distances <- GreatCircleDistanceMatrix(position[,t-1,1], position[,t-1,2])#
#
		for (k in 1:N_continents) {#
			#find current longlat of the circle k#
			start_long <- position[k, t-1, 1]#
			start_lat <- position[k, t-1, 2]#
#
			#Identify which supercontinent, and therefore which element of the euler pole and speed vectors, the circle k belongs to#
			where <- which_supercontinent(k, tail(linked, n=1)[[1]])#
#
			#Find distance of circle from pole#
			distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where], lat2=euler_pole_latitudes[where], Warn = FALSE)#
			#Find bearing of circle from pole#
			init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where], euler_pole_latitudes[where], start_long, start_lat)#
#
			#Find the new bearing of circle from pole according to the speed specified#
			new_bearing <- (init_bearing + degrees_per_step[where]) %% 360#
#
			#Find the new location of the circle#
			new_loc <- EndPoint(euler_pole_longitudes[where], euler_pole_latitudes[where], new_bearing, distance)#
#
			#Add the new loction to the position matrix#
			temp_position[k,1] <- new_loc$long#
			temp_position[k,2] <- new_loc$lat#
#
		}#
#
		#Matrix of the distances between each continent in their new positions, before these are set#
		new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
		comp1 <- vector()#
		comp2 <- vector()#
#
		#Making a vector of whether any continents have collided and should be linked#
		collisions<-matrix(nrow=0, ncol=2)#
		for (q in 1:(N_continents-1)) {#
			for (p in (q+1):N_continents) {#
				comp1 <- all.equal(new_distances[p,q],starting_distances[p,q])#
				comp2 <- new_distances[p,q] <= min_separation#
				if (comp1 != TRUE && comp2 == TRUE) {#
					collisions<-rbind(collisions,c(p,q))#
				}#
			}#
		}#
#
		#Matrix of euler poles and speeds for each individual continent for moving the animals later#
		organism_mover <- matrix(nrow=N_continents, ncol= 3)#
			for (clump in 1:length(tail(linked, n=1)[[1]])) {#
				which_conts <- as.numeric(strsplit(tail(linked, n=1)[[1]][[clump]], "&")[[1]])#
				organism_mover[which_conts,1] <- rep(euler_pole_longitudes[clump],length(which_conts))#
				organism_mover[which_conts,2] <- rep(euler_pole_latitudes[clump],length(which_conts))#
				#This bit will get overwritten if there are collisions#
				organism_mover[which_conts,3] <- rep(degrees_per_step[clump],length(which_conts))#
			}#
#
		perm_collisions <- matrix(nrow=0, ncol=2)#
#
		# Moving continents back if there has only been one collision#
		while(nrow(collisions) > 0) {#
#
			# Set up vector to store proportional changes after collisions#
			proportion <- vector()#
#
			# Find out proportions to reduce to for all potential collisions#
			for (coll in 1:nrow(collisions)) {#
				cont_1 <- collisions[coll,1]#
				cont_2 <- collisions[coll,2]#
				where_1 <- which_supercontinent(cont_1, tail(linked, n=1)[[1]])#
				where_2 <- which_supercontinent(cont_2, tail(linked, n=1)[[1]])#
				continent_1_euler_longitude = euler_pole_longitudes[where_1]#
				continent_1_euler_latitude = euler_pole_latitudes[where_1]#
				continent_2_euler_longitude = euler_pole_longitudes[where_2]#
				continent_2_euler_latitude = euler_pole_latitudes[where_2]#
				continent_1_degrees_per_step = degrees_per_step[where_1]#
				continent_2_degrees_per_step = degrees_per_step[where_2]#
				proportion[coll] <- ColliderReverser(min_separation, position[cont_1, t-1, 1], position[cont_1, t-1, 2], temp_position[cont_1,1], temp_position[cont_1,2], position[cont_2, t-1, 1], position[cont_2, t-1, 2], temp_position[cont_2,1], temp_position[cont_2,2], continent_1_euler_longitude, continent_1_euler_latitude, continent_2_euler_longitude, continent_2_euler_latitude, continent_1_degrees_per_step, continent_2_degrees_per_step, EarthRad = 6367.4447, Warn = FALSE)#
			}#
#
			# Select proportion to move for first collision#
			first_collision <- match(min(proportion),proportion)#
#
			# Find the two continents that collided first#
			cont_involved <- sort(collisions[first_collision, ])#
#
			# Add to matrix of definite collisions that cannot be separated in the next step#
			perm_collisions <- rbind(perm_collisions, cont_involved)#
#
			# Move first clump back#
			head_of_collision_1 <- cont_involved[1]#
			where_1 <- which_supercontinent(head_of_collision_1, tail(linked, n=1)[[1]])#
#
			#Find the other continents that were attached to the collider#
			all_involved <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_1], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents in one of the clumps#
			for (rev in 1:length(all_involved)) {#
				cont_to_rev <- all_involved[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_1], lat2=euler_pole_latitudes[where_1], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], start_long, start_lat)#
#
				#degrees to add#
				addition <- proportion[first_collision] * degrees_per_step[where_1]#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <- (init_bearing + addition) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
#
				organism_mover[cont_to_rev,3] <- addition#
			}#
#
			#Move the second clump back#
			head_of_collision_2 <- cont_involved[2]#
			where_2 <- which_supercontinent(head_of_collision_2, tail(linked, n=1)[[1]])#
			all_involved_2 <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_2], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents the other clump#
			for (rev in 1:length(all_involved_2)) {#
				cont_to_rev <- all_involved_2[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_2], lat2=euler_pole_latitudes[where_2], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], start_long, start_lat)#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <-  (init_bearing + (proportion[first_collision] * degrees_per_step[where_2])) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
			}#
#
			#Recalculate the new distances#
			new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
			comp1 <- vector()#
			comp2 <- vector()#
#
			# Check whether any other collisions have still occurred#
			collisions <- matrix(nrow=0, ncol=2)#
			for (q in 1:(N_continents - 1)) {#
				for (p in (q+1):N_continents) {#
					comp1 <- all.equal(new_distances[p, q], starting_distances[p, q])#
					comp2 <- new_distances[p, q] <= min_separation#
					if (comp1 != TRUE && comp2 == TRUE) {#
						# If collision has not already been recorded:#
						if(length(sort(match(paste(sort(c(q, p)), collapse=""), apply(perm_collisions, 1, paste, collapse="")))) == 0) {#
							# Record collision:#
							collisions <- rbind(collisions, c(p, q))#
						}#
					}#
				}#
			}#
		}#
#
		# When it finishes while loop can now 'ossify' the positions and move to selecting separations#
		position[, t, 1] <- temp_position[, 1]#
		position[, t, 2] <- temp_position[, 2]#
#
# Finding out if anything gets separated#
		# How many separate continents are there now? (after collisions may have occurred):#
		separate_continents <- HowManySeparateContinents(min_separation, position[,t,1], position[,t,2])#
		# Make random uniform draws for each continental cluster:#
		separation_draws <- runif(length(grep("&", separate_continents)))#
		# Case if a separation occurs (drawn value is equal to or exceeds stickiness):#
		if(any(separation_draws >= stickiness)) {#
			# Get clusters of continents to split apart:#
			clusters_to_split <- separate_continents[grep("&", separate_continents)][which(separation_draws >= stickiness)]#
			# For each cluster to split apart:#
			for(i in 1:length(clusters_to_split)) {#
				# Get numbers of continents involved:#
				cluster_continent_numbers <- sort(strsplit(clusters_to_split[i], "&")[[1]])#
				# Get longitudes of continents in cluster:#
				cluster_longitudes <- position[as.numeric(cluster_continent_numbers), t, 1]#
#
				# Get latitudes of continents in cluster:#
				cluster_latitudes <- position[as.numeric(cluster_continent_numbers), t, 2]#
				# Make protected links an empty matrix:#
				cluster_protected_links <- matrix(nrow = 0, ncol = 2)#
				# If there are recent collisions (that will potentially need to be excluded from new splits):#
				if(length(perm_collisions) > 0) {#
					# For each new collision:#
					for(j in 1:nrow(perm_collisions)) {#
						# If new collision occurs within the cluster:#
						if(all(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers) == as.character(perm_collisions[j, ]))) {#
							# Add new collision to protected links list:#
							cluster_protected_links <- rbind(cluster_protected_links, perm_collisions[j, ])#
						}#
					}#
#
				}#
				# Get splits (new clusters) of separated cluster:#
				splits <- ContinentSplitter(min_separation, cluster_longitudes, cluster_latitudes, cluster_continent_numbers, cluster_protected_links, EarthRad)#
				# Update separate continents vector:#
				separate_continents <- sort(c(separate_continents[-match(clusters_to_split[i], separate_continents)], splits))#
			}#
		}#
#
# Now change the Euler poles and speeds#
		# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
		touching_continents <- HowManySeparateContinents((radius * 2), position[,t,1], position[,t,2])#
		if (paste(sort(touching_continents), collapse="") != paste(sort(tail(touching,n=1)[[1]]), collapse="")) {#
			touching <- c(touching, list(touching_continents))#
		}#
#
		# If the continental clustering has changed:#
		if (paste(sort(separate_continents), collapse="") != paste(sort(tail(linked,n=1)[[1]]), collapse="")) {#
			# Add new continental configuration to linked list#
			linked <- c(linked, list(separate_continents))#
#
			# Update time step for previous continental configuration:#
			names(linked)[(length(linked) - 1)] <- paste(strsplit(names(linked[(length(linked) - 1)]), ":")[[1]][1], ":", t - 1, sep="")#
			# Add time step to new continental configuration:#
			names(linked)[length(linked)] <- paste(t, ":", t, sep="")#
			# Select continents that are different to previous time step#
			toKeep <- c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]])[duplicated(c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]]))]#
#
			#Vectors for new poles and speeds#
			new_euler_latitudes <- rep(NA, length(separate_continents))#
			new_euler_longitudes <- rep(NA, length(separate_continents))#
			new_degrees_per_step <- rep(NA, length(separate_continents))#
#
			if (length(toKeep) != 0){#
				#Inherit previous poles and speeds for those clumps that remain the same#
				for (y in 1:length(toKeep)) {#
					new_euler_longitudes[match(toKeep[y],separate_continents)]<- euler_pole_longitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_euler_latitudes[match(toKeep[y],separate_continents)]<- euler_pole_latitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_degrees_per_step[match(toKeep[y],separate_continents)]<- degrees_per_step[match(toKeep[y],tail(linked, n=2)[[1]])]#
				}#
			}#
#
			# Make new Euler poles#
			new_euler_longitudes[is.na(new_euler_longitudes)]<- runif((length(separate_continents)-length(toKeep)), -180, 180)#
#
			changed_euler_latitudes<- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			while((sum(changed_euler_latitudes == 90) + sum(changed_euler_latitudes == -90)) > 0) changed_euler_latitudes <- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			new_euler_latitudes[is.na(new_euler_latitudes)] <- changed_euler_latitudes#
#
			# Get Great Circle distances from Euler pole to each continent centre:#
			for (l in 1:(length(separate_continents)-length(toKeep))) {#
				# Find the first NA to fill in:#
				changer <- match(NA, new_degrees_per_step)#
				#Find the contients that are in the clump whose speed is going to change#
				rows <- as.numeric(unlist(strsplit(separate_continents[changer], "&")))#
				#Find the new euler pole for that clump#
				euler_long <- new_euler_longitudes[changer]#
				euler_lat <- new_euler_latitudes[changer]#
				#Find the distances of each of the continents in the clump from their new euler pole#
				euler_GC_distances <- One2ManyGreatCircleDistance(euler_long, euler_lat, position[rows, t, 1], position[rows, t, 2])#
				#Find which of those is closest to the equator#
				furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
				# Randomly draw a continent speed:#
				continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# If a negative or zero speed is picked then redraw:#
				while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# Set degree change per step (effectively the speed):#
				new_degrees_per_step[changer] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
			}#
			euler_pole_longitudes <- new_euler_longitudes#
			euler_pole_latitudes <- new_euler_latitudes#
			degrees_per_step <- new_degrees_per_step#
		}#
#
#Need to add in the tree bit#
		#Move the animals with the continents#
		for (cont in 1:N_continents) {#
			#Find the rows that are in the continent of focus#
			moving <- which(rownames(organism_long_matrix)==cont)#
#
			if (length(moving)==0) {#
				next #
			} else {#
				#Find out how many degrees around the euler pole that continent went#
				organism_degrees <- organism_mover[cont,3]#
				#loops through all the organisms that are currently living#
				for (organism in 1:length(moving)) {#
					organism_row <- moving[organism]#
					if (is.na(organism_long_matrix[organism_row, ot + 1])) {#
						next#
					} else {#
						first_long <- organism_long_matrix[organism_row, ot + 1]#
						first_lat <- organism_lat_matrix[organism_row, ot + 1]#
						organism_distance <- GreatCircleDistanceFromLongLat(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						organism_bearing <- BearingBetweenTwoLongLatPoints(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						new_organism_bearing <- (organism_bearing + organism_degrees) %% 360#
						new_organism_loc <- EndPoint(organism_mover[cont,1], organism_mover[cont,2], new_organism_bearing, organism_distance)#
						organism_long_matrix[organism_row, ot + 1] <- new_organism_loc$long#
    					organism_lat_matrix[organism_row, ot + 1] <- new_organism_loc$lat#
					}#
				}#
			}#
		}#
		for (f in 1:organism_multiplier) {#
            if (sum(alive) == 0) stop("METEOR IMPACT!! EVERYTHING HAS GONE EXTINCT! AAAAHHHHHH!!!")#
            dt<-1#
            ot <- ot + dt#
            for (m in 1:nrow(organism_lat_matrix)) {#
                if (alive[m]) {#
                    starting<-c(organism_lat_matrix[m,ot],organism_long_matrix[m,ot])#
                    moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd))) #generates a random walk step and calculates new position#
                    on_cont <- as.numeric(rownames(organism_lat_matrix)[m])#
                    friends <- as.numeric(strsplit(tail(touching, n=1)[[1]][which_supercontinent(on_cont, tail(touching, n=1)[[1]])], "&")[[1]])#
                    dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    if (length(friends) > 1) {#
                    	all_dist <- vector(length = length(friends))#
                    	for (g in 1:length(friends)) {#
                    		all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    	}#
                    	while (min(all_dist) > radius) {#
                    		moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		temp_all_dist <- vector(length = length(friends))#
                    		for (g in 1:length(friends)) {#
                    			temp_all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    		}#
                    		all_dist <- temp_all_dist#
                    	}#
                    	new_cont <- friends[which(all_dist == min(all_dist))] #
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                    	rownames(organism_long_matrix)[m] <- new_cont#
                    	rownames(organism_lat_matrix)[m] <- new_cont#
                    	if(new_cont != on_cont) {#
                    		dispersals <- rbind(dispersals, c(on_cont, new_cont, m, t, ot+1))#
                    	}#
                    } else {#
                    	while (dist_from_center >= radius) {#
                    		moveto <- EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    	}#
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                	}#
                }#
            }#
#
            r <- runif(1)#
            if (r <= b/(b + d)) { ###4 #this creates a bifucation in the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                e <- matrix(edge[alive,], ncol = 2)#
                parent <- e[random_lineage,2]#
                x <- which(edge[,2] == parent)#
                new.rows.lat <- new.rows.long <- extra.rows#
                new.rows.lat[, ot+1] <- organism_lat_matrix[x, ot+1] #updates the long and lat matricies with new coordiantes for each lineage#
                new.rows.long[, ot+1] <- organism_long_matrix[x, ot+1]#
                rownames(new.rows.lat) <- rep(rownames(organism_lat_matrix)[x],2)#
                rownames(new.rows.long) <- rep(rownames(organism_long_matrix)[x],2)#
                organism_lat_matrix <- rbind(organism_lat_matrix,new.rows.lat)#
                organism_long_matrix <- rbind(organism_long_matrix,new.rows.long)#
                alive[alive][random_lineage] <- FALSE#
                edge <- rbind(edge, c(parent, next.node), c(parent, next.node + 1))#
                next.node <- next.node + 2#
                alive <- c(alive, TRUE, TRUE)#
                stem.depth <- c(stem.depth, ot, ot)#
                edge.length[x] <- ot - stem.depth[x]#
                edge.length<-c(edge.length, NA, NA)#
            } else {###4 This terminates one of the current lineages on the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                edge.length[alive][random_lineage] <- ot - stem.depth[alive][random_lineage]#
                alive[alive][random_lineage] <- FALSE#
            }###4#
        }#1A#
        if (any(progress == t)) {#
        	cat("- ")#
        }#
    }
linked
position[,,1]
position[,20,1]
GreatCircleDistanceMatrix(position[,20,1], position[,20,2])
tempo_position
temp_position
GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])
starting_distances
lower.tri(starting_distances)
starting_distances[lower.tri(starting_distances)]
sort(starting_distances[lower.tri(starting_distances)])
linked
for (k in 1:N_continents) {
}
#find current longlat of the circle k#
			start_long <- position[k, t-1, 1]#
			start_lat <- position[k, t-1, 2]
start_long
#Identify which supercontinent, and therefore which element of the euler pole and speed vectors, the circle k belongs to#
			where <- which_supercontinent(k, tail(linked, n=1)[[1]])
where
#distances apart before they move#
		starting_distances <- GreatCircleDistanceMatrix(position[,t-1,1], position[,t-1,2])#
#
		for (k in 1:N_continents) {#
			#find current longlat of the circle k#
			start_long <- position[k, t-1, 1]#
			start_lat <- position[k, t-1, 2]#
#
			#Identify which supercontinent, and therefore which element of the euler pole and speed vectors, the circle k belongs to#
			where <- which_supercontinent(k, tail(linked, n=1)[[1]])#
#
			#Find distance of circle from pole#
			distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where], lat2=euler_pole_latitudes[where], Warn = FALSE)#
			#Find bearing of circle from pole#
			init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where], euler_pole_latitudes[where], start_long, start_lat)#
#
			#Find the new bearing of circle from pole according to the speed specified#
			new_bearing <- (init_bearing + degrees_per_step[where]) %% 360#
#
			#Find the new location of the circle#
			new_loc <- EndPoint(euler_pole_longitudes[where], euler_pole_latitudes[where], new_bearing, distance)#
#
			#Add the new loction to the position matrix#
			temp_position[k,1] <- new_loc$long#
			temp_position[k,2] <- new_loc$lat#
#
		}
GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])
#Matrix of the distances between each continent in their new positions, before these are set#
		new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])
new_distances
comp1 <- vector()#
		comp2 <- vector()#
#
		#Making a vector of whether any continents have collided and should be linked#
		collisions<-matrix(nrow=0, ncol=2)#
		for (q in 1:(N_continents-1)) {#
			for (p in (q+1):N_continents) {#
				comp1 <- all.equal(new_distances[p,q],starting_distances[p,q])#
				comp2 <- new_distances[p,q] <= min_separation#
				if (comp1 != TRUE && comp2 == TRUE) {#
					collisions<-rbind(collisions,c(p,q))#
				}#
			}#
		}
collisions
#Matrix of euler poles and speeds for each individual continent for moving the animals later#
		organism_mover <- matrix(nrow=N_continents, ncol= 3)#
		for (clump in 1:length(tail(linked, n=1)[[1]])) {#
			which_conts <- as.numeric(strsplit(tail(linked, n=1)[[1]][[clump]], "&")[[1]])#
			organism_mover[which_conts,1] <- rep(euler_pole_longitudes[clump],length(which_conts))#
			organism_mover[which_conts,2] <- rep(euler_pole_latitudes[clump],length(which_conts))#
			#This bit will get overwritten if there are collisions#
			organism_mover[which_conts,3] <- rep(degrees_per_step[clump],length(which_conts))#
		}#
		perm_collisions <- matrix(nrow=0, ncol=2)
nrow(collisions) > 0
# Set up vector to store proportional changes after collisions#
			proportion <- vector()#
#
			# Find out proportions to reduce to for all potential collisions#
			for (coll in 1:nrow(collisions)) {#
				cont_1 <- collisions[coll,1]#
				cont_2 <- collisions[coll,2]#
				where_1 <- which_supercontinent(cont_1, tail(linked, n=1)[[1]])#
				where_2 <- which_supercontinent(cont_2, tail(linked, n=1)[[1]])#
				continent_1_euler_longitude = euler_pole_longitudes[where_1]#
				continent_1_euler_latitude = euler_pole_latitudes[where_1]#
				continent_2_euler_longitude = euler_pole_longitudes[where_2]#
				continent_2_euler_latitude = euler_pole_latitudes[where_2]#
				continent_1_degrees_per_step = degrees_per_step[where_1]#
				continent_2_degrees_per_step = degrees_per_step[where_2]#
				proportion[coll] <- ColliderReverser(min_separation, position[cont_1, t-1, 1], position[cont_1, t-1, 2], temp_position[cont_1,1], temp_position[cont_1,2], position[cont_2, t-1, 1], position[cont_2, t-1, 2], temp_position[cont_2,1], temp_position[cont_2,2], continent_1_euler_longitude, continent_1_euler_latitude, continent_2_euler_longitude, continent_2_euler_latitude, continent_1_degrees_per_step, continent_2_degrees_per_step, EarthRad = 6367.4447, Warn = FALSE)#
			}
proportion
where_1
ColliderReverser
min_separation
position[cont_1, t-1, 1]
position[cont_1, t, 1]
position[cont_1, t-1, 1]
CONT_!
cont_!
cont_1
ColliderReverser(min_separation, position[cont_1, t-1, 1], position[cont_1, t-1, 2], temp_position[cont_1,1], temp_position[cont_1,2], position[cont_2, t-1, 1], position[cont_2, t-1, 2], temp_position[cont_2,1], temp_position[cont_2,2], continent_1_euler_longitude, continent_1_euler_latitude, continent_2_euler_longitude, continent_2_euler_latitude, continent_1_degrees_per_step, continent_2_degrees_per_step, EarthRad = 6367.4447, Warn = FALSE)
ColliderReverser(min_separation, position[cont_1, t-1, 1], position[cont_1, t-1, 2], temp_position[cont_1,1], temp_position[cont_1,2], position[cont_2, t-1, 1], position[cont_2, t-1, 2], temp_position[cont_2,1], temp_position[cont_2,2], continent_1_euler_longitude, continent_1_euler_latitude, continent_2_euler_longitude, continent_2_euler_latitude, continent_1_degrees_per_step, continent_2_degrees_per_step, EarthRad = 6367.4447)
GreatCircleDistanceFromLongLat(position[cont_1, t-1, 1], position[cont_1, t-1, 2], position[cont_2, t-1, 1], position[cont_2, t-1, 2])
all.equal(GreatCircleDistanceFromLongLat(position[cont_1, t-1, 1], position[cont_1, t-1, 2], position[cont_2, t-1, 1], position[cont_2, t-1, 2]), min_separation)
continent_1_longitude_t0 <- position[cont_1, t-1, 1]#
continent_1_latitude_t0 <- position[cont_1, t-1, 2]#
continent_1_longitude_t1 <- temp_position[cont_1,1]#
continent_1_latitude_t1 <- temp_position[cont_1,2]#
continent_2_longitude_t0 <- position[cont_2, t-1, 1]#
continent_2_latitude_t0 <- position[cont_2, t-1, 2]#
continent_2_longitude_t1 <- temp_position[cont_2,1]#
continent_2_latitude_t1 <- temp_position[cont_2,2]
# Get t0 distance between continents for checks on input data:#
	t0_distance <- GreatCircleDistanceFromLongLat(continent_1_longitude_t0, continent_1_latitude_t0, continent_2_longitude_t0, continent_2_latitude_t0, Warn = FALSE)#
	# Get t1 distance between continents for checks on input data:#
	t1_distance <- GreatCircleDistanceFromLongLat(continent_1_longitude_t1, continent_1_latitude_t1, continent_2_longitude_t1, continent_2_latitude_t1, Warn = FALSE)
t0_distance
t1_distance
min_separation > t0_distance
all.equal(as.vector(min_separation), as.vector(t0_distance))
all.equal(as.vector(min_separation), as.vector(t0_distance)) != TRUE
all.equal(as.vector(min_separation), as.vector(t0_distance)) != TRUE && min_separation > t0_distance
all.equal(as.vector(min_separation), as.vector(t0_distance)) != TRUE && min_separation < t1_distance
check()
check()
install()
N_steps = 1000; organism_multiplier = 1; N_continents = 7; radius = 2000; start_configuration = "supercontinent"; squishiness = 0.25; stickiness = 0.95; continent_speed_mean = 5; continent_speed_sd = 2; organism_step_sd = 100; b = 0.1; d = 0.05; EarthRad = 6367.4447; polar = FALSE
# Subfunction to find out which supercontinent a circle belongs to:#
	which_supercontinent <- function(cont, sprconts){#
		cont <- as.character(cont)#
		result <- which(unlist(lapply(lapply(lapply(strsplit(sprconts, "&"), match, cont), sort), length)) == 1)#
		return(result)#
	}#
	# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)#
# Are any continents joined at start?:#
#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
#
	# Get list of separate continents:#
	separate_continents <- HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
#
	# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
	touching_continents <- HowManySeparateContinents((radius * 2), continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
# Assign Euler poles to each separate continent:#
	# Randomly draw longitudes for each separated continent:#
	euler_pole_longitudes <- runif(length(separate_continents), -180, 180)#
	# Randomly draw latitudes for each separated continent:#
	euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
	# Ensure no latitude is directly at a pole (North or South) by redrawing if any are found:#
	if((sum(euler_pole_latitudes == 90) + sum(euler_pole_latitudes == -90)) > 0) euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
#
# Assign speeds to each separate continent:#
	# Create empty vector to store degrees per step (effectively the speed of movement) for each continent:#
	degrees_per_step <- vector(mode="numeric")#
	# For each separate continent:#
	for(i in 1:length(separate_continents)) {#
		# Get Greate Circle distances from Euler pole to each continent centre:#
		euler_GC_distances <- One2ManyGreatCircleDistance(euler_pole_longitudes[i], euler_pole_latitudes[i], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Longitude"], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Latitude"])#
		# Find GC distance to furthest continent (closest to euler pole "equator") in cluster (as speed will be assigned based on this):#
		furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
		# Randomly draw a continent speed:#
		continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# If a negative or zero speed is picked then redraw:#
		while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# Set degree change per step (effectively the speed):#
		degrees_per_step[i] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
	}#
#
	#starting information for the tree#
	dispersals <- matrix(nrow=0, ncol=5)#
	begin_cont <- ceiling(runif(1, 0, N_continents))#
	life_begins <- EndPoint(continent_starting_points[begin_cont, "Longitude"], continent_starting_points[begin_cont, "Latitude"], runif(1,0,360), runif(1,0,radius))#
	extra.rows <- matrix(NA,nrow=2,ncol= (N_steps * organism_multiplier) + 1)#
	organism_lat_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_long_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_lat_matrix[,1] <- life_begins$lat#
    organism_long_matrix[,1] <- life_begins$lon#
    rownames(organism_lat_matrix) <- rep(begin_cont, 2)#
    rownames(organism_long_matrix) <- rep(begin_cont, 2)#
    edge <- rbind(c(1, 2), c(1, 3)) # this is a starting edge matrix#
    edge.length <- rep(NA, 2)#
    stem.depth <- numeric(2)#
    alive <- rep(TRUE, 2) # marker for live lineages#
    ot <- 0; # time(step) at any point in the tree#
    next.node <- 4#
#
	# Now need to move them!#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	linked <- list()#
	linked[[1]] <- separate_continents#
	names(linked)[[1]] <- "1:1"#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	touching <- list()#
	touching[[1]] <- touching_continents#
#
	#Array to store the positions of every continent at each time step#
	position <- array(NA, c(N_continents, N_steps + 1, 2), c("continent", "timestep", "coordinate"))#
	position[,1,1] <- continent_starting_points[,"Longitude"]#
	position[,1,2] <- continent_starting_points[,"Latitude"]#
#
	temp_position<-matrix(nrow = N_continents, ncol=2)#
#
	progress <- seq(1, N_steps, floor(N_steps/50))#
	cat("Starting time steps \n")#
	cat("Progress \n")#
	cat("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n")#
#
	#for loops to move everything#
	for (t in 2:(N_steps + 1)) {#
		#distances apart before they move#
		starting_distances <- GreatCircleDistanceMatrix(position[,t-1,1], position[,t-1,2])#
#
		for (k in 1:N_continents) {#
			#find current longlat of the circle k#
			start_long <- position[k, t-1, 1]#
			start_lat <- position[k, t-1, 2]#
#
			#Identify which supercontinent, and therefore which element of the euler pole and speed vectors, the circle k belongs to#
			where <- which_supercontinent(k, tail(linked, n=1)[[1]])#
#
			#Find distance of circle from pole#
			distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where], lat2=euler_pole_latitudes[where], Warn = FALSE)#
			#Find bearing of circle from pole#
			init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where], euler_pole_latitudes[where], start_long, start_lat)#
#
			#Find the new bearing of circle from pole according to the speed specified#
			new_bearing <- (init_bearing + degrees_per_step[where]) %% 360#
#
			#Find the new location of the circle#
			new_loc <- EndPoint(euler_pole_longitudes[where], euler_pole_latitudes[where], new_bearing, distance)#
#
			#Add the new loction to the position matrix#
			temp_position[k,1] <- new_loc$long#
			temp_position[k,2] <- new_loc$lat#
#
		}#
#
		#Matrix of the distances between each continent in their new positions, before these are set#
		new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
		comp1 <- vector()#
		comp2 <- vector()#
#
		#Making a vector of whether any continents have collided and should be linked#
		collisions<-matrix(nrow=0, ncol=2)#
		for (q in 1:(N_continents-1)) {#
			for (p in (q+1):N_continents) {#
				comp1 <- all.equal(new_distances[p,q],starting_distances[p,q])#
				comp2 <- new_distances[p,q] <= min_separation#
				if (comp1 != TRUE && comp2 == TRUE) {#
					collisions<-rbind(collisions,c(p,q))#
				}#
			}#
		}#
#
		#Matrix of euler poles and speeds for each individual continent for moving the animals later#
		organism_mover <- matrix(nrow=N_continents, ncol= 3)#
		for (clump in 1:length(tail(linked, n=1)[[1]])) {#
			which_conts <- as.numeric(strsplit(tail(linked, n=1)[[1]][[clump]], "&")[[1]])#
			organism_mover[which_conts,1] <- rep(euler_pole_longitudes[clump],length(which_conts))#
			organism_mover[which_conts,2] <- rep(euler_pole_latitudes[clump],length(which_conts))#
			#This bit will get overwritten if there are collisions#
			organism_mover[which_conts,3] <- rep(degrees_per_step[clump],length(which_conts))#
		}#
		perm_collisions <- matrix(nrow=0, ncol=2)#
#
		# Moving continents back if there has only been one collision#
		while(nrow(collisions) > 0) {#
#
			# Set up vector to store proportional changes after collisions#
			proportion <- vector()#
#
			# Find out proportions to reduce to for all potential collisions#
			for (coll in 1:nrow(collisions)) {#
				cont_1 <- collisions[coll,1]#
				cont_2 <- collisions[coll,2]#
				where_1 <- which_supercontinent(cont_1, tail(linked, n=1)[[1]])#
				where_2 <- which_supercontinent(cont_2, tail(linked, n=1)[[1]])#
				continent_1_euler_longitude = euler_pole_longitudes[where_1]#
				continent_1_euler_latitude = euler_pole_latitudes[where_1]#
				continent_2_euler_longitude = euler_pole_longitudes[where_2]#
				continent_2_euler_latitude = euler_pole_latitudes[where_2]#
				continent_1_degrees_per_step = degrees_per_step[where_1]#
				continent_2_degrees_per_step = degrees_per_step[where_2]#
				proportion[coll] <- ColliderReverser(min_separation, position[cont_1, t-1, 1], position[cont_1, t-1, 2], temp_position[cont_1,1], temp_position[cont_1,2], position[cont_2, t-1, 1], position[cont_2, t-1, 2], temp_position[cont_2,1], temp_position[cont_2,2], continent_1_euler_longitude, continent_1_euler_latitude, continent_2_euler_longitude, continent_2_euler_latitude, continent_1_degrees_per_step, continent_2_degrees_per_step, EarthRad = 6367.4447, Warn = FALSE)#
			}#
#
			# Select proportion to move for first collision#
			first_collision <- match(min(proportion),proportion)#
#
			# Find the two continents that collided first#
			cont_involved <- sort(collisions[first_collision, ])#
#
			# Add to matrix of definite collisions that cannot be separated in the next step#
			perm_collisions <- rbind(perm_collisions, cont_involved)#
#
			# Move first clump back#
			head_of_collision_1 <- cont_involved[1]#
			where_1 <- which_supercontinent(head_of_collision_1, tail(linked, n=1)[[1]])#
#
			#Find the other continents that were attached to the collider#
			all_involved <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_1], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents in one of the clumps#
			for (rev in 1:length(all_involved)) {#
				cont_to_rev <- all_involved[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_1], lat2=euler_pole_latitudes[where_1], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], start_long, start_lat)#
#
				#degrees to add#
				addition <- proportion[first_collision] * degrees_per_step[where_1]#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <- (init_bearing + addition) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
#
				organism_mover[cont_to_rev,3] <- addition#
			}#
#
			#Move the second clump back#
			head_of_collision_2 <- cont_involved[2]#
			where_2 <- which_supercontinent(head_of_collision_2, tail(linked, n=1)[[1]])#
			all_involved_2 <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_2], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents the other clump#
			for (rev in 1:length(all_involved_2)) {#
				cont_to_rev <- all_involved_2[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_2], lat2=euler_pole_latitudes[where_2], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], start_long, start_lat)#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <-  (init_bearing + (proportion[first_collision] * degrees_per_step[where_2])) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
			}#
#
			#Recalculate the new distances#
			new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
			comp1 <- vector()#
			comp2 <- vector()#
#
			# Check whether any other collisions have still occurred#
			collisions <- matrix(nrow=0, ncol=2)#
			for (q in 1:(N_continents - 1)) {#
				for (p in (q+1):N_continents) {#
					comp1 <- all.equal(new_distances[p, q], starting_distances[p, q])#
					comp2 <- new_distances[p, q] <= min_separation#
					if (comp1 != TRUE && comp2 == TRUE) {#
						# If collision has not already been recorded:#
						if(length(sort(match(paste(sort(c(q, p)), collapse=""), apply(perm_collisions, 1, paste, collapse="")))) == 0) {#
							# Record collision:#
							collisions <- rbind(collisions, c(p, q))#
						}#
					}#
				}#
			}#
		}#
#
		# When it finishes while loop can now 'ossify' the positions and move to selecting separations#
		position[, t, 1] <- temp_position[, 1]#
		position[, t, 2] <- temp_position[, 2]#
#
# Finding out if anything gets separated#
		# How many separate continents are there now? (after collisions may have occurred):#
		separate_continents <- HowManySeparateContinents(min_separation, position[,t,1], position[,t,2])#
		# Make random uniform draws for each continental cluster:#
		separation_draws <- runif(length(grep("&", separate_continents)))#
		# Case if a separation occurs (drawn value is equal to or exceeds stickiness):#
		if(any(separation_draws >= stickiness)) {#
			# Get clusters of continents to split apart:#
			clusters_to_split <- separate_continents[grep("&", separate_continents)][which(separation_draws >= stickiness)]#
			# For each cluster to split apart:#
			for(i in 1:length(clusters_to_split)) {#
				# Get numbers of continents involved:#
				cluster_continent_numbers <- sort(strsplit(clusters_to_split[i], "&")[[1]])#
				# Get longitudes of continents in cluster:#
				cluster_longitudes <- position[as.numeric(cluster_continent_numbers), t, 1]#
#
				# Get latitudes of continents in cluster:#
				cluster_latitudes <- position[as.numeric(cluster_continent_numbers), t, 2]#
				# Make protected links an empty matrix:#
				cluster_protected_links <- matrix(nrow = 0, ncol = 2)#
				# If there are recent collisions (that will potentially need to be excluded from new splits):#
				if(length(perm_collisions) > 0) {#
					# For each new collision:#
					for(j in 1:nrow(perm_collisions)) {#
						# If new collision occurs within the cluster:#
						if(all(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers) == as.character(perm_collisions[j, ]))) {#
							# Add new collision to protected links list:#
							cluster_protected_links <- rbind(cluster_protected_links, perm_collisions[j, ])#
						}#
					}#
#
				}#
				# Get splits (new clusters) of separated cluster:#
				splits <- ContinentSplitter(min_separation, cluster_longitudes, cluster_latitudes, cluster_continent_numbers, cluster_protected_links, EarthRad)#
				# Update separate continents vector:#
				separate_continents <- sort(c(separate_continents[-match(clusters_to_split[i], separate_continents)], splits))#
			}#
		}#
#
# Now change the Euler poles and speeds#
		# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
		touching_continents <- HowManySeparateContinents((radius * 2), position[,t,1], position[,t,2])#
		if (paste(sort(touching_continents), collapse="") != paste(sort(tail(touching,n=1)[[1]]), collapse="")) {#
			touching <- c(touching, list(touching_continents))#
		}#
#
		# If the continental clustering has changed:#
		if (paste(sort(separate_continents), collapse="") != paste(sort(tail(linked,n=1)[[1]]), collapse="")) {#
			# Add new continental configuration to linked list#
			linked <- c(linked, list(separate_continents))#
#
			# Update time step for previous continental configuration:#
			names(linked)[(length(linked) - 1)] <- paste(strsplit(names(linked[(length(linked) - 1)]), ":")[[1]][1], ":", t - 1, sep="")#
			# Add time step to new continental configuration:#
			names(linked)[length(linked)] <- paste(t, ":", t, sep="")#
			# Select continents that are different to previous time step#
			toKeep <- c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]])[duplicated(c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]]))]#
#
			#Vectors for new poles and speeds#
			new_euler_latitudes <- rep(NA, length(separate_continents))#
			new_euler_longitudes <- rep(NA, length(separate_continents))#
			new_degrees_per_step <- rep(NA, length(separate_continents))#
#
			if (length(toKeep) != 0){#
				#Inherit previous poles and speeds for those clumps that remain the same#
				for (y in 1:length(toKeep)) {#
					new_euler_longitudes[match(toKeep[y],separate_continents)]<- euler_pole_longitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_euler_latitudes[match(toKeep[y],separate_continents)]<- euler_pole_latitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_degrees_per_step[match(toKeep[y],separate_continents)]<- degrees_per_step[match(toKeep[y],tail(linked, n=2)[[1]])]#
				}#
			}#
#
			# Make new Euler poles#
			new_euler_longitudes[is.na(new_euler_longitudes)]<- runif((length(separate_continents)-length(toKeep)), -180, 180)#
#
			changed_euler_latitudes<- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			while((sum(changed_euler_latitudes == 90) + sum(changed_euler_latitudes == -90)) > 0) changed_euler_latitudes <- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			new_euler_latitudes[is.na(new_euler_latitudes)] <- changed_euler_latitudes#
#
			# Get Great Circle distances from Euler pole to each continent centre:#
			for (l in 1:(length(separate_continents)-length(toKeep))) {#
				# Find the first NA to fill in:#
				changer <- match(NA, new_degrees_per_step)#
				#Find the contients that are in the clump whose speed is going to change#
				rows <- as.numeric(unlist(strsplit(separate_continents[changer], "&")))#
				#Find the new euler pole for that clump#
				euler_long <- new_euler_longitudes[changer]#
				euler_lat <- new_euler_latitudes[changer]#
				#Find the distances of each of the continents in the clump from their new euler pole#
				euler_GC_distances <- One2ManyGreatCircleDistance(euler_long, euler_lat, position[rows, t, 1], position[rows, t, 2])#
				#Find which of those is closest to the equator#
				furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
				# Randomly draw a continent speed:#
				continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# If a negative or zero speed is picked then redraw:#
				while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# Set degree change per step (effectively the speed):#
				new_degrees_per_step[changer] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
			}#
			euler_pole_longitudes <- new_euler_longitudes#
			euler_pole_latitudes <- new_euler_latitudes#
			degrees_per_step <- new_degrees_per_step#
		}#
#
#Need to add in the tree bit#
		#Move the animals with the continents#
		for (cont in 1:N_continents) {#
			#Find the rows that are in the continent of focus#
			moving <- which(rownames(organism_long_matrix)==cont)#
#
			if (length(moving)==0) {#
				next #
			} else {#
				#Find out how many degrees around the euler pole that continent went#
				organism_degrees <- organism_mover[cont,3]#
				#loops through all the organisms that are currently living#
				for (organism in 1:length(moving)) {#
					organism_row <- moving[organism]#
					if (is.na(organism_long_matrix[organism_row, ot + 1])) {#
						next#
					} else {#
						first_long <- organism_long_matrix[organism_row, ot + 1]#
						first_lat <- organism_lat_matrix[organism_row, ot + 1]#
						organism_distance <- GreatCircleDistanceFromLongLat(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						organism_bearing <- BearingBetweenTwoLongLatPoints(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						new_organism_bearing <- (organism_bearing + organism_degrees) %% 360#
						new_organism_loc <- EndPoint(organism_mover[cont,1], organism_mover[cont,2], new_organism_bearing, organism_distance)#
						organism_long_matrix[organism_row, ot + 1] <- new_organism_loc$long#
    					organism_lat_matrix[organism_row, ot + 1] <- new_organism_loc$lat#
					}#
				}#
			}#
		}#
		for (f in 1:organism_multiplier) {#
            if (sum(alive) == 0) stop("METEOR IMPACT!! EVERYTHING HAS GONE EXTINCT! AAAAHHHHHH!!!")#
            dt<-1#
            ot <- ot + dt#
            for (m in 1:nrow(organism_lat_matrix)) {#
                if (alive[m]) {#
                    starting<-c(organism_lat_matrix[m,ot],organism_long_matrix[m,ot])#
                    moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd))) #generates a random walk step and calculates new position#
                    on_cont <- as.numeric(rownames(organism_lat_matrix)[m])#
                    friends <- as.numeric(strsplit(tail(touching, n=1)[[1]][which_supercontinent(on_cont, tail(touching, n=1)[[1]])], "&")[[1]])#
                    dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    if (length(friends) > 1) {#
                    	all_dist <- vector(length = length(friends))#
                    	for (g in 1:length(friends)) {#
                    		all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    	}#
                    	while (min(all_dist) > radius) {#
                    		moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		temp_all_dist <- vector(length = length(friends))#
                    		for (g in 1:length(friends)) {#
                    			temp_all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    		}#
                    		all_dist <- temp_all_dist#
                    	}#
                    	new_cont <- friends[which(all_dist == min(all_dist))] #
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                    	rownames(organism_long_matrix)[m] <- new_cont#
                    	rownames(organism_lat_matrix)[m] <- new_cont#
                    	if(new_cont != on_cont) {#
                    		dispersals <- rbind(dispersals, c(on_cont, new_cont, m, t, ot+1))#
                    	}#
                    } else {#
                    	while (dist_from_center >= radius) {#
                    		moveto <- EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    	}#
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                	}#
                }#
            }#
#
            r <- runif(1)#
            if (r <= b/(b + d)) { ###4 #this creates a bifucation in the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                e <- matrix(edge[alive,], ncol = 2)#
                parent <- e[random_lineage,2]#
                x <- which(edge[,2] == parent)#
                new.rows.lat <- new.rows.long <- extra.rows#
                new.rows.lat[, ot+1] <- organism_lat_matrix[x, ot+1] #updates the long and lat matricies with new coordiantes for each lineage#
                new.rows.long[, ot+1] <- organism_long_matrix[x, ot+1]#
                rownames(new.rows.lat) <- rep(rownames(organism_lat_matrix)[x],2)#
                rownames(new.rows.long) <- rep(rownames(organism_long_matrix)[x],2)#
                organism_lat_matrix <- rbind(organism_lat_matrix,new.rows.lat)#
                organism_long_matrix <- rbind(organism_long_matrix,new.rows.long)#
                alive[alive][random_lineage] <- FALSE#
                edge <- rbind(edge, c(parent, next.node), c(parent, next.node + 1))#
                next.node <- next.node + 2#
                alive <- c(alive, TRUE, TRUE)#
                stem.depth <- c(stem.depth, ot, ot)#
                edge.length[x] <- ot - stem.depth[x]#
                edge.length<-c(edge.length, NA, NA)#
            } else {###4 This terminates one of the current lineages on the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                edge.length[alive][random_lineage] <- ot - stem.depth[alive][random_lineage]#
                alive[alive][random_lineage] <- FALSE#
            }###4#
        }#1A#
        if (any(progress == t)) {#
        	cat("- ")#
        }#
    }
linked
plot(try$organism_longitudes[1,], try$organism_latitudes[1,], xlim=c(-180, 180), ylim=c(-90, 90), type = "l")
for (i in 1:nrow(try$organism_longitudes))   lines(try$organism_longitudes[i,], try$organism_latitudes[i,])
N_steps = 300
# Subfunction to find out which supercontinent a circle belongs to:#
	which_supercontinent <- function(cont, sprconts){#
		cont <- as.character(cont)#
		result <- which(unlist(lapply(lapply(lapply(strsplit(sprconts, "&"), match, cont), sort), length)) == 1)#
		return(result)#
	}#
	# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)#
# Are any continents joined at start?:#
#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
#
	# Get list of separate continents:#
	separate_continents <- HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
#
	# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
	touching_continents <- HowManySeparateContinents((radius * 2), continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
# Assign Euler poles to each separate continent:#
	# Randomly draw longitudes for each separated continent:#
	euler_pole_longitudes <- runif(length(separate_continents), -180, 180)#
	# Randomly draw latitudes for each separated continent:#
	euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
	# Ensure no latitude is directly at a pole (North or South) by redrawing if any are found:#
	if((sum(euler_pole_latitudes == 90) + sum(euler_pole_latitudes == -90)) > 0) euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
#
# Assign speeds to each separate continent:#
	# Create empty vector to store degrees per step (effectively the speed of movement) for each continent:#
	degrees_per_step <- vector(mode="numeric")#
	# For each separate continent:#
	for(i in 1:length(separate_continents)) {#
		# Get Greate Circle distances from Euler pole to each continent centre:#
		euler_GC_distances <- One2ManyGreatCircleDistance(euler_pole_longitudes[i], euler_pole_latitudes[i], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Longitude"], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Latitude"])#
		# Find GC distance to furthest continent (closest to euler pole "equator") in cluster (as speed will be assigned based on this):#
		furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
		# Randomly draw a continent speed:#
		continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# If a negative or zero speed is picked then redraw:#
		while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# Set degree change per step (effectively the speed):#
		degrees_per_step[i] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
	}#
#
	#starting information for the tree#
	dispersals <- matrix(nrow=0, ncol=5)#
	begin_cont <- ceiling(runif(1, 0, N_continents))#
	life_begins <- EndPoint(continent_starting_points[begin_cont, "Longitude"], continent_starting_points[begin_cont, "Latitude"], runif(1,0,360), runif(1,0,radius))#
	extra.rows <- matrix(NA,nrow=2,ncol= (N_steps * organism_multiplier) + 1)#
	organism_lat_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_long_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_lat_matrix[,1] <- life_begins$lat#
    organism_long_matrix[,1] <- life_begins$lon#
    rownames(organism_lat_matrix) <- rep(begin_cont, 2)#
    rownames(organism_long_matrix) <- rep(begin_cont, 2)#
    edge <- rbind(c(1, 2), c(1, 3)) # this is a starting edge matrix#
    edge.length <- rep(NA, 2)#
    stem.depth <- numeric(2)#
    alive <- rep(TRUE, 2) # marker for live lineages#
    ot <- 0; # time(step) at any point in the tree#
    next.node <- 4#
#
	# Now need to move them!#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	linked <- list()#
	linked[[1]] <- separate_continents#
	names(linked)[[1]] <- "1:1"#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	touching <- list()#
	touching[[1]] <- touching_continents#
#
	#Array to store the positions of every continent at each time step#
	position <- array(NA, c(N_continents, N_steps + 1, 2), c("continent", "timestep", "coordinate"))#
	position[,1,1] <- continent_starting_points[,"Longitude"]#
	position[,1,2] <- continent_starting_points[,"Latitude"]#
#
	temp_position<-matrix(nrow = N_continents, ncol=2)#
#
	progress <- seq(1, N_steps, floor(N_steps/50))#
	cat("Starting time steps \n")#
	cat("Progress \n")#
	cat("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n")#
#
	#for loops to move everything#
	for (t in 2:(N_steps + 1)) {#
		#distances apart before they move#
		starting_distances <- GreatCircleDistanceMatrix(position[,t-1,1], position[,t-1,2])#
#
		for (k in 1:N_continents) {#
			#find current longlat of the circle k#
			start_long <- position[k, t-1, 1]#
			start_lat <- position[k, t-1, 2]#
#
			#Identify which supercontinent, and therefore which element of the euler pole and speed vectors, the circle k belongs to#
			where <- which_supercontinent(k, tail(linked, n=1)[[1]])#
#
			#Find distance of circle from pole#
			distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where], lat2=euler_pole_latitudes[where], Warn = FALSE)#
			#Find bearing of circle from pole#
			init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where], euler_pole_latitudes[where], start_long, start_lat)#
#
			#Find the new bearing of circle from pole according to the speed specified#
			new_bearing <- (init_bearing + degrees_per_step[where]) %% 360#
#
			#Find the new location of the circle#
			new_loc <- EndPoint(euler_pole_longitudes[where], euler_pole_latitudes[where], new_bearing, distance)#
#
			#Add the new loction to the position matrix#
			temp_position[k,1] <- new_loc$long#
			temp_position[k,2] <- new_loc$lat#
#
		}#
#
		#Matrix of the distances between each continent in their new positions, before these are set#
		new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
		comp1 <- vector()#
		comp2 <- vector()#
#
		#Making a vector of whether any continents have collided and should be linked#
		collisions<-matrix(nrow=0, ncol=2)#
		for (q in 1:(N_continents-1)) {#
			for (p in (q+1):N_continents) {#
				comp1 <- all.equal(new_distances[p,q],starting_distances[p,q])#
				comp2 <- new_distances[p,q] <= min_separation#
				if (comp1 != TRUE && comp2 == TRUE) {#
					collisions<-rbind(collisions,c(p,q))#
				}#
			}#
		}#
#
		#Matrix of euler poles and speeds for each individual continent for moving the animals later#
		organism_mover <- matrix(nrow=N_continents, ncol= 3)#
		for (clump in 1:length(tail(linked, n=1)[[1]])) {#
			which_conts <- as.numeric(strsplit(tail(linked, n=1)[[1]][[clump]], "&")[[1]])#
			organism_mover[which_conts,1] <- rep(euler_pole_longitudes[clump],length(which_conts))#
			organism_mover[which_conts,2] <- rep(euler_pole_latitudes[clump],length(which_conts))#
			#This bit will get overwritten if there are collisions#
			organism_mover[which_conts,3] <- rep(degrees_per_step[clump],length(which_conts))#
		}#
		perm_collisions <- matrix(nrow=0, ncol=2)#
#
		# Moving continents back if there has only been one collision#
		while(nrow(collisions) > 0) {#
#
			# Set up vector to store proportional changes after collisions#
			proportion <- vector()#
#
			# Find out proportions to reduce to for all potential collisions#
			for (coll in 1:nrow(collisions)) {#
				cont_1 <- collisions[coll,1]#
				cont_2 <- collisions[coll,2]#
				where_1 <- which_supercontinent(cont_1, tail(linked, n=1)[[1]])#
				where_2 <- which_supercontinent(cont_2, tail(linked, n=1)[[1]])#
				continent_1_euler_longitude = euler_pole_longitudes[where_1]#
				continent_1_euler_latitude = euler_pole_latitudes[where_1]#
				continent_2_euler_longitude = euler_pole_longitudes[where_2]#
				continent_2_euler_latitude = euler_pole_latitudes[where_2]#
				continent_1_degrees_per_step = degrees_per_step[where_1]#
				continent_2_degrees_per_step = degrees_per_step[where_2]#
				proportion[coll] <- ColliderReverser(min_separation, position[cont_1, t-1, 1], position[cont_1, t-1, 2], temp_position[cont_1,1], temp_position[cont_1,2], position[cont_2, t-1, 1], position[cont_2, t-1, 2], temp_position[cont_2,1], temp_position[cont_2,2], continent_1_euler_longitude, continent_1_euler_latitude, continent_2_euler_longitude, continent_2_euler_latitude, continent_1_degrees_per_step, continent_2_degrees_per_step, EarthRad = 6367.4447, Warn = FALSE)#
			}#
#
			# Select proportion to move for first collision#
			first_collision <- match(min(proportion),proportion)#
#
			# Find the two continents that collided first#
			cont_involved <- sort(collisions[first_collision, ])#
#
			# Add to matrix of definite collisions that cannot be separated in the next step#
			perm_collisions <- rbind(perm_collisions, cont_involved)#
#
			# Move first clump back#
			head_of_collision_1 <- cont_involved[1]#
			where_1 <- which_supercontinent(head_of_collision_1, tail(linked, n=1)[[1]])#
#
			#Find the other continents that were attached to the collider#
			all_involved <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_1], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents in one of the clumps#
			for (rev in 1:length(all_involved)) {#
				cont_to_rev <- all_involved[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_1], lat2=euler_pole_latitudes[where_1], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], start_long, start_lat)#
#
				#degrees to add#
				addition <- proportion[first_collision] * degrees_per_step[where_1]#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <- (init_bearing + addition) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
#
				organism_mover[cont_to_rev,3] <- addition#
			}#
#
			#Move the second clump back#
			head_of_collision_2 <- cont_involved[2]#
			where_2 <- which_supercontinent(head_of_collision_2, tail(linked, n=1)[[1]])#
			all_involved_2 <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_2], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents the other clump#
			for (rev in 1:length(all_involved_2)) {#
				cont_to_rev <- all_involved_2[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_2], lat2=euler_pole_latitudes[where_2], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], start_long, start_lat)#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <-  (init_bearing + (proportion[first_collision] * degrees_per_step[where_2])) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
			}#
#
			#Recalculate the new distances#
			new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
			comp1 <- vector()#
			comp2 <- vector()#
#
			# Check whether any other collisions have still occurred#
			collisions <- matrix(nrow=0, ncol=2)#
			for (q in 1:(N_continents - 1)) {#
				for (p in (q+1):N_continents) {#
					comp1 <- all.equal(new_distances[p, q], starting_distances[p, q])#
					comp2 <- new_distances[p, q] <= min_separation#
					if (comp1 != TRUE && comp2 == TRUE) {#
						# If collision has not already been recorded:#
						if(length(sort(match(paste(sort(c(q, p)), collapse=""), apply(perm_collisions, 1, paste, collapse="")))) == 0) {#
							# Record collision:#
							collisions <- rbind(collisions, c(p, q))#
						}#
					}#
				}#
			}#
		}#
#
		# When it finishes while loop can now 'ossify' the positions and move to selecting separations#
		position[, t, 1] <- temp_position[, 1]#
		position[, t, 2] <- temp_position[, 2]#
#
# Finding out if anything gets separated#
		# How many separate continents are there now? (after collisions may have occurred):#
		separate_continents <- HowManySeparateContinents(min_separation, position[,t,1], position[,t,2])#
		# Make random uniform draws for each continental cluster:#
		separation_draws <- runif(length(grep("&", separate_continents)))#
		# Case if a separation occurs (drawn value is equal to or exceeds stickiness):#
		if(any(separation_draws >= stickiness)) {#
			# Get clusters of continents to split apart:#
			clusters_to_split <- separate_continents[grep("&", separate_continents)][which(separation_draws >= stickiness)]#
			# For each cluster to split apart:#
			for(i in 1:length(clusters_to_split)) {#
				# Get numbers of continents involved:#
				cluster_continent_numbers <- sort(strsplit(clusters_to_split[i], "&")[[1]])#
				# Get longitudes of continents in cluster:#
				cluster_longitudes <- position[as.numeric(cluster_continent_numbers), t, 1]#
#
				# Get latitudes of continents in cluster:#
				cluster_latitudes <- position[as.numeric(cluster_continent_numbers), t, 2]#
				# Make protected links an empty matrix:#
				cluster_protected_links <- matrix(nrow = 0, ncol = 2)#
				# If there are recent collisions (that will potentially need to be excluded from new splits):#
				if(length(perm_collisions) > 0) {#
					# For each new collision:#
					for(j in 1:nrow(perm_collisions)) {#
						# If new collision occurs within the cluster:#
						if(all(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers) == as.character(perm_collisions[j, ]))) {#
							# Add new collision to protected links list:#
							cluster_protected_links <- rbind(cluster_protected_links, perm_collisions[j, ])#
						}#
					}#
#
				}#
				# Get splits (new clusters) of separated cluster:#
				splits <- ContinentSplitter(min_separation, cluster_longitudes, cluster_latitudes, cluster_continent_numbers, cluster_protected_links, EarthRad)#
				# Update separate continents vector:#
				separate_continents <- sort(c(separate_continents[-match(clusters_to_split[i], separate_continents)], splits))#
			}#
		}#
#
# Now change the Euler poles and speeds#
		# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
		touching_continents <- HowManySeparateContinents((radius * 2), position[,t,1], position[,t,2])#
		if (paste(sort(touching_continents), collapse="") != paste(sort(tail(touching,n=1)[[1]]), collapse="")) {#
			touching <- c(touching, list(touching_continents))#
		}#
#
		# If the continental clustering has changed:#
		if (paste(sort(separate_continents), collapse="") != paste(sort(tail(linked,n=1)[[1]]), collapse="")) {#
			# Add new continental configuration to linked list#
			linked <- c(linked, list(separate_continents))#
#
			# Update time step for previous continental configuration:#
			names(linked)[(length(linked) - 1)] <- paste(strsplit(names(linked[(length(linked) - 1)]), ":")[[1]][1], ":", t - 1, sep="")#
			# Add time step to new continental configuration:#
			names(linked)[length(linked)] <- paste(t, ":", t, sep="")#
			# Select continents that are different to previous time step#
			toKeep <- c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]])[duplicated(c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]]))]#
#
			#Vectors for new poles and speeds#
			new_euler_latitudes <- rep(NA, length(separate_continents))#
			new_euler_longitudes <- rep(NA, length(separate_continents))#
			new_degrees_per_step <- rep(NA, length(separate_continents))#
#
			if (length(toKeep) != 0){#
				#Inherit previous poles and speeds for those clumps that remain the same#
				for (y in 1:length(toKeep)) {#
					new_euler_longitudes[match(toKeep[y],separate_continents)]<- euler_pole_longitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_euler_latitudes[match(toKeep[y],separate_continents)]<- euler_pole_latitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_degrees_per_step[match(toKeep[y],separate_continents)]<- degrees_per_step[match(toKeep[y],tail(linked, n=2)[[1]])]#
				}#
			}#
#
			# Make new Euler poles#
			new_euler_longitudes[is.na(new_euler_longitudes)]<- runif((length(separate_continents)-length(toKeep)), -180, 180)#
#
			changed_euler_latitudes<- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			while((sum(changed_euler_latitudes == 90) + sum(changed_euler_latitudes == -90)) > 0) changed_euler_latitudes <- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			new_euler_latitudes[is.na(new_euler_latitudes)] <- changed_euler_latitudes#
#
			# Get Great Circle distances from Euler pole to each continent centre:#
			for (l in 1:(length(separate_continents)-length(toKeep))) {#
				# Find the first NA to fill in:#
				changer <- match(NA, new_degrees_per_step)#
				#Find the contients that are in the clump whose speed is going to change#
				rows <- as.numeric(unlist(strsplit(separate_continents[changer], "&")))#
				#Find the new euler pole for that clump#
				euler_long <- new_euler_longitudes[changer]#
				euler_lat <- new_euler_latitudes[changer]#
				#Find the distances of each of the continents in the clump from their new euler pole#
				euler_GC_distances <- One2ManyGreatCircleDistance(euler_long, euler_lat, position[rows, t, 1], position[rows, t, 2])#
				#Find which of those is closest to the equator#
				furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
				# Randomly draw a continent speed:#
				continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# If a negative or zero speed is picked then redraw:#
				while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# Set degree change per step (effectively the speed):#
				new_degrees_per_step[changer] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
			}#
			euler_pole_longitudes <- new_euler_longitudes#
			euler_pole_latitudes <- new_euler_latitudes#
			degrees_per_step <- new_degrees_per_step#
		}#
#
#Need to add in the tree bit#
		#Move the animals with the continents#
		for (cont in 1:N_continents) {#
			#Find the rows that are in the continent of focus#
			moving <- which(rownames(organism_long_matrix)==cont)#
#
			if (length(moving)==0) {#
				next #
			} else {#
				#Find out how many degrees around the euler pole that continent went#
				organism_degrees <- organism_mover[cont,3]#
				#loops through all the organisms that are currently living#
				for (organism in 1:length(moving)) {#
					organism_row <- moving[organism]#
					if (is.na(organism_long_matrix[organism_row, ot + 1])) {#
						next#
					} else {#
						first_long <- organism_long_matrix[organism_row, ot + 1]#
						first_lat <- organism_lat_matrix[organism_row, ot + 1]#
						organism_distance <- GreatCircleDistanceFromLongLat(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						organism_bearing <- BearingBetweenTwoLongLatPoints(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						new_organism_bearing <- (organism_bearing + organism_degrees) %% 360#
						new_organism_loc <- EndPoint(organism_mover[cont,1], organism_mover[cont,2], new_organism_bearing, organism_distance)#
						organism_long_matrix[organism_row, ot + 1] <- new_organism_loc$long#
    					organism_lat_matrix[organism_row, ot + 1] <- new_organism_loc$lat#
					}#
				}#
			}#
		}#
		for (f in 1:organism_multiplier) {#
            if (sum(alive) == 0) stop("METEOR IMPACT!! EVERYTHING HAS GONE EXTINCT! AAAAHHHHHH!!!")#
            dt<-1#
            ot <- ot + dt#
            for (m in 1:nrow(organism_lat_matrix)) {#
                if (alive[m]) {#
                    starting<-c(organism_lat_matrix[m,ot],organism_long_matrix[m,ot])#
                    moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd))) #generates a random walk step and calculates new position#
                    on_cont <- as.numeric(rownames(organism_lat_matrix)[m])#
                    friends <- as.numeric(strsplit(tail(touching, n=1)[[1]][which_supercontinent(on_cont, tail(touching, n=1)[[1]])], "&")[[1]])#
                    dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    if (length(friends) > 1) {#
                    	all_dist <- vector(length = length(friends))#
                    	for (g in 1:length(friends)) {#
                    		all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    	}#
                    	while (min(all_dist) > radius) {#
                    		moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		temp_all_dist <- vector(length = length(friends))#
                    		for (g in 1:length(friends)) {#
                    			temp_all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    		}#
                    		all_dist <- temp_all_dist#
                    	}#
                    	new_cont <- friends[which(all_dist == min(all_dist))] #
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                    	rownames(organism_long_matrix)[m] <- new_cont#
                    	rownames(organism_lat_matrix)[m] <- new_cont#
                    	if(new_cont != on_cont) {#
                    		dispersals <- rbind(dispersals, c(on_cont, new_cont, m, t, ot+1))#
                    	}#
                    } else {#
                    	while (dist_from_center >= radius) {#
                    		moveto <- EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    	}#
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                	}#
                }#
            }#
#
            r <- runif(1)#
            if (r <= b/(b + d)) { ###4 #this creates a bifucation in the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                e <- matrix(edge[alive,], ncol = 2)#
                parent <- e[random_lineage,2]#
                x <- which(edge[,2] == parent)#
                new.rows.lat <- new.rows.long <- extra.rows#
                new.rows.lat[, ot+1] <- organism_lat_matrix[x, ot+1] #updates the long and lat matricies with new coordiantes for each lineage#
                new.rows.long[, ot+1] <- organism_long_matrix[x, ot+1]#
                rownames(new.rows.lat) <- rep(rownames(organism_lat_matrix)[x],2)#
                rownames(new.rows.long) <- rep(rownames(organism_long_matrix)[x],2)#
                organism_lat_matrix <- rbind(organism_lat_matrix,new.rows.lat)#
                organism_long_matrix <- rbind(organism_long_matrix,new.rows.long)#
                alive[alive][random_lineage] <- FALSE#
                edge <- rbind(edge, c(parent, next.node), c(parent, next.node + 1))#
                next.node <- next.node + 2#
                alive <- c(alive, TRUE, TRUE)#
                stem.depth <- c(stem.depth, ot, ot)#
                edge.length[x] <- ot - stem.depth[x]#
                edge.length<-c(edge.length, NA, NA)#
            } else {###4 This terminates one of the current lineages on the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                edge.length[alive][random_lineage] <- ot - stem.depth[alive][random_lineage]#
                alive[alive][random_lineage] <- FALSE#
            }###4#
        }#1A#
        if (any(progress == t)) {#
        	cat("- ")#
        }#
    }#
#
    #Things to do right at the end to turn it into a phylo object#
    edge.length[alive] <- ot - stem.depth[alive];#
    n <- -1#
    for (f in 1:max(edge)) {#
        if (any(edge[,1] == f)) {#
           	edge[which(edge[,1] == f), 1] <- n#
           	edge[which(edge[,2] == f), 2] <- n#
           	n <- n - 1;#
        }#
    }#
    edge[edge > 0] <- 1:sum(edge > 0)#
   	tip.label <- 1:sum(edge > 0)#
    mode(edge) <- "character"#
    mode(tip.label) <- "character"#
    obj <- list(edge = edge, edge.length = edge.length, tip.label=tip.label)#
    class(obj) <- "phylo"#
    obj <- old2new.phylo(obj)#
    obj$tip.label = paste("s", 1:Ntip(obj), sep = "")#
	# Add final time step to continental configurations:#
	names(linked)[length(linked)] <- paste(strsplit(names(linked)[length(linked)], ":")[[1]][1], ":", t, sep="")#
	output <- list(position, linked, touching, obj, organism_long_matrix, organism_lat_matrix)#
	names(output) <- c("continent_positions", "continent_clusters", "continent_overlaps", "tree", "organism_longitudes", "organism_latitudes")
protected_links
protected_link
protected_links
cluster_protected_links
ContinentSplitter(min_separation, cluster_longitudes, cluster_latitudes, cluster_continent_numbers, cluster_protected_links, EarthRad)
cluster_continent_numbers
# Get numbers of continents involved:#
				cluster_continent_numbers <- sort(strsplit(clusters_to_split[i], "&")[[1]])#
				# Get longitudes of continents in cluster:#
				cluster_longitudes <- position[as.numeric(cluster_continent_numbers), t, 1]#
#
				# Get latitudes of continents in cluster:#
				cluster_latitudes <- position[as.numeric(cluster_continent_numbers), t, 2]#
				# Make protected links an empty matrix:#
				cluster_protected_links <- matrix(nrow = 0, ncol = 2)#
				# If there are recent collisions (that will potentially need to be excluded from new splits):#
				if(length(perm_collisions) > 0) {#
					# For each new collision:#
					for(j in 1:nrow(perm_collisions)) {#
						# If new collision occurs within the cluster:#
						if(all(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers) == as.character(perm_collisions[j, ]))) {#
							# Add new collision to protected links list:#
							cluster_protected_links <- rbind(cluster_protected_links, perm_collisions[j, ])#
						}#
					}#
#
				}
cluster_protected_links
cluster_continent_numbers
perm_collisions
j
all(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers) == as.character(perm_collisions[j, ]))
intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers) == as.character(perm_collisions[j, ])
as.character(perm_collisions[j, ])
cluster_continent_numbers
intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers)
length(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers))
length(intersect(as.character(perm_collisions[j, ]), c(cluster_continent_numbers, "1")))
length(intersect(as.character(perm_collisions[j, ]), c(cluster_continent_numbers, "1", "6")))
length(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers))
# Get numbers of continents involved:#
				cluster_continent_numbers <- sort(strsplit(clusters_to_split[i], "&")[[1]])#
				# Get longitudes of continents in cluster:#
				cluster_longitudes <- position[as.numeric(cluster_continent_numbers), t, 1]#
#
				# Get latitudes of continents in cluster:#
				cluster_latitudes <- position[as.numeric(cluster_continent_numbers), t, 2]#
				# Make protected links an empty matrix:#
				cluster_protected_links <- matrix(nrow = 0, ncol = 2)#
				# If there are recent collisions (that will potentially need to be excluded from new splits):#
				if(length(perm_collisions) > 0) {#
					# For each new collision:#
					for(j in 1:nrow(perm_collisions)) {#
						# If new collision occurs within the cluster:#
						if(length(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers)) == 2) {#
							# Add new collision to protected links list:#
							cluster_protected_links <- rbind(cluster_protected_links, perm_collisions[j, ])#
						}#
					}#
#
				}
cluster_protected_links
ContinentSplitter(min_separation, cluster_longitudes, cluster_latitudes, cluster_continent_numbers, cluster_protected_links, EarthRad)
document()
N_steps
# Subfunction to find out which supercontinent a circle belongs to:#
	which_supercontinent <- function(cont, sprconts){#
		cont <- as.character(cont)#
		result <- which(unlist(lapply(lapply(lapply(strsplit(sprconts, "&"), match, cont), sort), length)) == 1)#
		return(result)#
	}#
	# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)#
# Are any continents joined at start?:#
#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
#
	# Get list of separate continents:#
	separate_continents <- HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
#
	# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
	touching_continents <- HowManySeparateContinents((radius * 2), continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
# Assign Euler poles to each separate continent:#
	# Randomly draw longitudes for each separated continent:#
	euler_pole_longitudes <- runif(length(separate_continents), -180, 180)#
	# Randomly draw latitudes for each separated continent:#
	euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
	# Ensure no latitude is directly at a pole (North or South) by redrawing if any are found:#
	if((sum(euler_pole_latitudes == 90) + sum(euler_pole_latitudes == -90)) > 0) euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
#
# Assign speeds to each separate continent:#
	# Create empty vector to store degrees per step (effectively the speed of movement) for each continent:#
	degrees_per_step <- vector(mode="numeric")#
	# For each separate continent:#
	for(i in 1:length(separate_continents)) {#
		# Get Greate Circle distances from Euler pole to each continent centre:#
		euler_GC_distances <- One2ManyGreatCircleDistance(euler_pole_longitudes[i], euler_pole_latitudes[i], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Longitude"], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Latitude"])#
		# Find GC distance to furthest continent (closest to euler pole "equator") in cluster (as speed will be assigned based on this):#
		furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
		# Randomly draw a continent speed:#
		continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# If a negative or zero speed is picked then redraw:#
		while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# Set degree change per step (effectively the speed):#
		degrees_per_step[i] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
	}#
#
	#starting information for the tree#
	dispersals <- matrix(nrow=0, ncol=5)#
	begin_cont <- ceiling(runif(1, 0, N_continents))#
	life_begins <- EndPoint(continent_starting_points[begin_cont, "Longitude"], continent_starting_points[begin_cont, "Latitude"], runif(1,0,360), runif(1,0,radius))#
	extra.rows <- matrix(NA,nrow=2,ncol= (N_steps * organism_multiplier) + 1)#
	organism_lat_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_long_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_lat_matrix[,1] <- life_begins$lat#
    organism_long_matrix[,1] <- life_begins$lon#
    rownames(organism_lat_matrix) <- rep(begin_cont, 2)#
    rownames(organism_long_matrix) <- rep(begin_cont, 2)#
    edge <- rbind(c(1, 2), c(1, 3)) # this is a starting edge matrix#
    edge.length <- rep(NA, 2)#
    stem.depth <- numeric(2)#
    alive <- rep(TRUE, 2) # marker for live lineages#
    ot <- 0; # time(step) at any point in the tree#
    next.node <- 4#
#
	# Now need to move them!#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	linked <- list()#
	linked[[1]] <- separate_continents#
	names(linked)[[1]] <- "1:1"#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	touching <- list()#
	touching[[1]] <- touching_continents#
#
	#Array to store the positions of every continent at each time step#
	position <- array(NA, c(N_continents, N_steps + 1, 2), c("continent", "timestep", "coordinate"))#
	position[,1,1] <- continent_starting_points[,"Longitude"]#
	position[,1,2] <- continent_starting_points[,"Latitude"]#
#
	temp_position<-matrix(nrow = N_continents, ncol=2)#
#
	progress <- seq(1, N_steps, floor(N_steps/50))#
	cat("Starting time steps \n")#
	cat("Progress \n")#
	cat("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n")#
#
	#for loops to move everything#
	for (t in 2:(N_steps + 1)) {#
		#distances apart before they move#
		starting_distances <- GreatCircleDistanceMatrix(position[,t-1,1], position[,t-1,2])#
#
		for (k in 1:N_continents) {#
			#find current longlat of the circle k#
			start_long <- position[k, t-1, 1]#
			start_lat <- position[k, t-1, 2]#
#
			#Identify which supercontinent, and therefore which element of the euler pole and speed vectors, the circle k belongs to#
			where <- which_supercontinent(k, tail(linked, n=1)[[1]])#
#
			#Find distance of circle from pole#
			distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where], lat2=euler_pole_latitudes[where], Warn = FALSE)#
			#Find bearing of circle from pole#
			init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where], euler_pole_latitudes[where], start_long, start_lat)#
#
			#Find the new bearing of circle from pole according to the speed specified#
			new_bearing <- (init_bearing + degrees_per_step[where]) %% 360#
#
			#Find the new location of the circle#
			new_loc <- EndPoint(euler_pole_longitudes[where], euler_pole_latitudes[where], new_bearing, distance)#
#
			#Add the new loction to the position matrix#
			temp_position[k,1] <- new_loc$long#
			temp_position[k,2] <- new_loc$lat#
#
		}#
#
		#Matrix of the distances between each continent in their new positions, before these are set#
		new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
		comp1 <- vector()#
		comp2 <- vector()#
#
		#Making a vector of whether any continents have collided and should be linked#
		collisions<-matrix(nrow=0, ncol=2)#
		for (q in 1:(N_continents-1)) {#
			for (p in (q+1):N_continents) {#
				comp1 <- all.equal(new_distances[p,q],starting_distances[p,q])#
				comp2 <- new_distances[p,q] <= min_separation#
				if (comp1 != TRUE && comp2 == TRUE) {#
					collisions<-rbind(collisions,c(p,q))#
				}#
			}#
		}#
#
		#Matrix of euler poles and speeds for each individual continent for moving the animals later#
		organism_mover <- matrix(nrow=N_continents, ncol= 3)#
		for (clump in 1:length(tail(linked, n=1)[[1]])) {#
			which_conts <- as.numeric(strsplit(tail(linked, n=1)[[1]][[clump]], "&")[[1]])#
			organism_mover[which_conts,1] <- rep(euler_pole_longitudes[clump],length(which_conts))#
			organism_mover[which_conts,2] <- rep(euler_pole_latitudes[clump],length(which_conts))#
			#This bit will get overwritten if there are collisions#
			organism_mover[which_conts,3] <- rep(degrees_per_step[clump],length(which_conts))#
		}#
		perm_collisions <- matrix(nrow=0, ncol=2)#
#
		# Moving continents back if there has only been one collision#
		while(nrow(collisions) > 0) {#
#
			# Set up vector to store proportional changes after collisions#
			proportion <- vector()#
#
			# Find out proportions to reduce to for all potential collisions#
			for (coll in 1:nrow(collisions)) {#
				cont_1 <- collisions[coll,1]#
				cont_2 <- collisions[coll,2]#
				where_1 <- which_supercontinent(cont_1, tail(linked, n=1)[[1]])#
				where_2 <- which_supercontinent(cont_2, tail(linked, n=1)[[1]])#
				continent_1_euler_longitude = euler_pole_longitudes[where_1]#
				continent_1_euler_latitude = euler_pole_latitudes[where_1]#
				continent_2_euler_longitude = euler_pole_longitudes[where_2]#
				continent_2_euler_latitude = euler_pole_latitudes[where_2]#
				continent_1_degrees_per_step = degrees_per_step[where_1]#
				continent_2_degrees_per_step = degrees_per_step[where_2]#
				proportion[coll] <- ColliderReverser(min_separation, position[cont_1, t-1, 1], position[cont_1, t-1, 2], temp_position[cont_1,1], temp_position[cont_1,2], position[cont_2, t-1, 1], position[cont_2, t-1, 2], temp_position[cont_2,1], temp_position[cont_2,2], continent_1_euler_longitude, continent_1_euler_latitude, continent_2_euler_longitude, continent_2_euler_latitude, continent_1_degrees_per_step, continent_2_degrees_per_step, EarthRad = 6367.4447, Warn = FALSE)#
			}#
#
			# Select proportion to move for first collision#
			first_collision <- match(min(proportion),proportion)#
#
			# Find the two continents that collided first#
			cont_involved <- sort(collisions[first_collision, ])#
#
			# Add to matrix of definite collisions that cannot be separated in the next step#
			perm_collisions <- rbind(perm_collisions, cont_involved)#
#
			# Move first clump back#
			head_of_collision_1 <- cont_involved[1]#
			where_1 <- which_supercontinent(head_of_collision_1, tail(linked, n=1)[[1]])#
#
			#Find the other continents that were attached to the collider#
			all_involved <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_1], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents in one of the clumps#
			for (rev in 1:length(all_involved)) {#
				cont_to_rev <- all_involved[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_1], lat2=euler_pole_latitudes[where_1], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], start_long, start_lat)#
#
				#degrees to add#
				addition <- proportion[first_collision] * degrees_per_step[where_1]#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <- (init_bearing + addition) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
#
				organism_mover[cont_to_rev,3] <- addition#
			}#
#
			#Move the second clump back#
			head_of_collision_2 <- cont_involved[2]#
			where_2 <- which_supercontinent(head_of_collision_2, tail(linked, n=1)[[1]])#
			all_involved_2 <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_2], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents the other clump#
			for (rev in 1:length(all_involved_2)) {#
				cont_to_rev <- all_involved_2[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_2], lat2=euler_pole_latitudes[where_2], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], start_long, start_lat)#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <-  (init_bearing + (proportion[first_collision] * degrees_per_step[where_2])) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
			}#
#
			#Recalculate the new distances#
			new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
			comp1 <- vector()#
			comp2 <- vector()#
#
			# Check whether any other collisions have still occurred#
			collisions <- matrix(nrow=0, ncol=2)#
			for (q in 1:(N_continents - 1)) {#
				for (p in (q+1):N_continents) {#
					comp1 <- all.equal(new_distances[p, q], starting_distances[p, q])#
					comp2 <- new_distances[p, q] <= min_separation#
					if (comp1 != TRUE && comp2 == TRUE) {#
						# If collision has not already been recorded:#
						if(length(sort(match(paste(sort(c(q, p)), collapse=""), apply(perm_collisions, 1, paste, collapse="")))) == 0) {#
							# Record collision:#
							collisions <- rbind(collisions, c(p, q))#
						}#
					}#
				}#
			}#
		}#
#
		# When it finishes while loop can now 'ossify' the positions and move to selecting separations#
		position[, t, 1] <- temp_position[, 1]#
		position[, t, 2] <- temp_position[, 2]#
#
# Finding out if anything gets separated#
		# How many separate continents are there now? (after collisions may have occurred):#
		separate_continents <- HowManySeparateContinents(min_separation, position[,t,1], position[,t,2])#
		# Make random uniform draws for each continental cluster:#
		separation_draws <- runif(length(grep("&", separate_continents)))#
		# Case if a separation occurs (drawn value is equal to or exceeds stickiness):#
		if(any(separation_draws >= stickiness)) {#
			# Get clusters of continents to split apart:#
			clusters_to_split <- separate_continents[grep("&", separate_continents)][which(separation_draws >= stickiness)]#
			# For each cluster to split apart:#
			for(i in 1:length(clusters_to_split)) {#
				# Get numbers of continents involved:#
				cluster_continent_numbers <- sort(strsplit(clusters_to_split[i], "&")[[1]])#
				# Get longitudes of continents in cluster:#
				cluster_longitudes <- position[as.numeric(cluster_continent_numbers), t, 1]#
#
				# Get latitudes of continents in cluster:#
				cluster_latitudes <- position[as.numeric(cluster_continent_numbers), t, 2]#
				# Make protected links an empty matrix:#
				cluster_protected_links <- matrix(nrow = 0, ncol = 2)#
				# If there are recent collisions (that will potentially need to be excluded from new splits):#
				if(length(perm_collisions) > 0) {#
					# For each new collision:#
					for(j in 1:nrow(perm_collisions)) {#
						# If new collision occurs within the cluster:#
						if(length(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers)) == 2) {#
							# Add new collision to protected links list:#
							cluster_protected_links <- rbind(cluster_protected_links, perm_collisions[j, ])#
						}#
					}#
#
				}#
				# Get splits (new clusters) of separated cluster:#
				splits <- ContinentSplitter(min_separation, cluster_longitudes, cluster_latitudes, cluster_continent_numbers, cluster_protected_links, EarthRad)#
				# Update separate continents vector:#
				separate_continents <- sort(c(separate_continents[-match(clusters_to_split[i], separate_continents)], splits))#
			}#
		}#
#
# Now change the Euler poles and speeds#
		# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
		touching_continents <- HowManySeparateContinents((radius * 2), position[,t,1], position[,t,2])#
		if (paste(sort(touching_continents), collapse="") != paste(sort(tail(touching,n=1)[[1]]), collapse="")) {#
			touching <- c(touching, list(touching_continents))#
		}#
#
		# If the continental clustering has changed:#
		if (paste(sort(separate_continents), collapse="") != paste(sort(tail(linked,n=1)[[1]]), collapse="")) {#
			# Add new continental configuration to linked list#
			linked <- c(linked, list(separate_continents))#
#
			# Update time step for previous continental configuration:#
			names(linked)[(length(linked) - 1)] <- paste(strsplit(names(linked[(length(linked) - 1)]), ":")[[1]][1], ":", t - 1, sep="")#
			# Add time step to new continental configuration:#
			names(linked)[length(linked)] <- paste(t, ":", t, sep="")#
			# Select continents that are different to previous time step#
			toKeep <- c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]])[duplicated(c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]]))]#
#
			#Vectors for new poles and speeds#
			new_euler_latitudes <- rep(NA, length(separate_continents))#
			new_euler_longitudes <- rep(NA, length(separate_continents))#
			new_degrees_per_step <- rep(NA, length(separate_continents))#
#
			if (length(toKeep) != 0){#
				#Inherit previous poles and speeds for those clumps that remain the same#
				for (y in 1:length(toKeep)) {#
					new_euler_longitudes[match(toKeep[y],separate_continents)]<- euler_pole_longitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_euler_latitudes[match(toKeep[y],separate_continents)]<- euler_pole_latitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_degrees_per_step[match(toKeep[y],separate_continents)]<- degrees_per_step[match(toKeep[y],tail(linked, n=2)[[1]])]#
				}#
			}#
#
			# Make new Euler poles#
			new_euler_longitudes[is.na(new_euler_longitudes)]<- runif((length(separate_continents)-length(toKeep)), -180, 180)#
#
			changed_euler_latitudes<- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			while((sum(changed_euler_latitudes == 90) + sum(changed_euler_latitudes == -90)) > 0) changed_euler_latitudes <- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			new_euler_latitudes[is.na(new_euler_latitudes)] <- changed_euler_latitudes#
#
			# Get Great Circle distances from Euler pole to each continent centre:#
			for (l in 1:(length(separate_continents)-length(toKeep))) {#
				# Find the first NA to fill in:#
				changer <- match(NA, new_degrees_per_step)#
				#Find the contients that are in the clump whose speed is going to change#
				rows <- as.numeric(unlist(strsplit(separate_continents[changer], "&")))#
				#Find the new euler pole for that clump#
				euler_long <- new_euler_longitudes[changer]#
				euler_lat <- new_euler_latitudes[changer]#
				#Find the distances of each of the continents in the clump from their new euler pole#
				euler_GC_distances <- One2ManyGreatCircleDistance(euler_long, euler_lat, position[rows, t, 1], position[rows, t, 2])#
				#Find which of those is closest to the equator#
				furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
				# Randomly draw a continent speed:#
				continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# If a negative or zero speed is picked then redraw:#
				while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# Set degree change per step (effectively the speed):#
				new_degrees_per_step[changer] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
			}#
			euler_pole_longitudes <- new_euler_longitudes#
			euler_pole_latitudes <- new_euler_latitudes#
			degrees_per_step <- new_degrees_per_step#
		}#
#
#Need to add in the tree bit#
		#Move the animals with the continents#
		for (cont in 1:N_continents) {#
			#Find the rows that are in the continent of focus#
			moving <- which(rownames(organism_long_matrix)==cont)#
#
			if (length(moving)==0) {#
				next #
			} else {#
				#Find out how many degrees around the euler pole that continent went#
				organism_degrees <- organism_mover[cont,3]#
				#loops through all the organisms that are currently living#
				for (organism in 1:length(moving)) {#
					organism_row <- moving[organism]#
					if (is.na(organism_long_matrix[organism_row, ot + 1])) {#
						next#
					} else {#
						first_long <- organism_long_matrix[organism_row, ot + 1]#
						first_lat <- organism_lat_matrix[organism_row, ot + 1]#
						organism_distance <- GreatCircleDistanceFromLongLat(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						organism_bearing <- BearingBetweenTwoLongLatPoints(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						new_organism_bearing <- (organism_bearing + organism_degrees) %% 360#
						new_organism_loc <- EndPoint(organism_mover[cont,1], organism_mover[cont,2], new_organism_bearing, organism_distance)#
						organism_long_matrix[organism_row, ot + 1] <- new_organism_loc$long#
    					organism_lat_matrix[organism_row, ot + 1] <- new_organism_loc$lat#
					}#
				}#
			}#
		}#
		for (f in 1:organism_multiplier) {#
            if (sum(alive) == 0) stop("METEOR IMPACT!! EVERYTHING HAS GONE EXTINCT! AAAAHHHHHH!!!")#
            dt<-1#
            ot <- ot + dt#
            for (m in 1:nrow(organism_lat_matrix)) {#
                if (alive[m]) {#
                    starting<-c(organism_lat_matrix[m,ot],organism_long_matrix[m,ot])#
                    moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd))) #generates a random walk step and calculates new position#
                    on_cont <- as.numeric(rownames(organism_lat_matrix)[m])#
                    friends <- as.numeric(strsplit(tail(touching, n=1)[[1]][which_supercontinent(on_cont, tail(touching, n=1)[[1]])], "&")[[1]])#
                    dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    if (length(friends) > 1) {#
                    	all_dist <- vector(length = length(friends))#
                    	for (g in 1:length(friends)) {#
                    		all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    	}#
                    	while (min(all_dist) > radius) {#
                    		moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		temp_all_dist <- vector(length = length(friends))#
                    		for (g in 1:length(friends)) {#
                    			temp_all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    		}#
                    		all_dist <- temp_all_dist#
                    	}#
                    	new_cont <- friends[which(all_dist == min(all_dist))] #
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                    	rownames(organism_long_matrix)[m] <- new_cont#
                    	rownames(organism_lat_matrix)[m] <- new_cont#
                    	if(new_cont != on_cont) {#
                    		dispersals <- rbind(dispersals, c(on_cont, new_cont, m, t, ot+1))#
                    	}#
                    } else {#
                    	while (dist_from_center >= radius) {#
                    		moveto <- EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    	}#
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                	}#
                }#
            }#
#
            r <- runif(1)#
            if (r <= b/(b + d)) { ###4 #this creates a bifucation in the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                e <- matrix(edge[alive,], ncol = 2)#
                parent <- e[random_lineage,2]#
                x <- which(edge[,2] == parent)#
                new.rows.lat <- new.rows.long <- extra.rows#
                new.rows.lat[, ot+1] <- organism_lat_matrix[x, ot+1] #updates the long and lat matricies with new coordiantes for each lineage#
                new.rows.long[, ot+1] <- organism_long_matrix[x, ot+1]#
                rownames(new.rows.lat) <- rep(rownames(organism_lat_matrix)[x],2)#
                rownames(new.rows.long) <- rep(rownames(organism_long_matrix)[x],2)#
                organism_lat_matrix <- rbind(organism_lat_matrix,new.rows.lat)#
                organism_long_matrix <- rbind(organism_long_matrix,new.rows.long)#
                alive[alive][random_lineage] <- FALSE#
                edge <- rbind(edge, c(parent, next.node), c(parent, next.node + 1))#
                next.node <- next.node + 2#
                alive <- c(alive, TRUE, TRUE)#
                stem.depth <- c(stem.depth, ot, ot)#
                edge.length[x] <- ot - stem.depth[x]#
                edge.length<-c(edge.length, NA, NA)#
            } else {###4 This terminates one of the current lineages on the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                edge.length[alive][random_lineage] <- ot - stem.depth[alive][random_lineage]#
                alive[alive][random_lineage] <- FALSE#
            }###4#
        }#1A#
        if (any(progress == t)) {#
        	cat("- ")#
        }#
    }#
#
    #Things to do right at the end to turn it into a phylo object#
    edge.length[alive] <- ot - stem.depth[alive];#
    n <- -1#
    for (f in 1:max(edge)) {#
        if (any(edge[,1] == f)) {#
           	edge[which(edge[,1] == f), 1] <- n#
           	edge[which(edge[,2] == f), 2] <- n#
           	n <- n - 1;#
        }#
    }#
    edge[edge > 0] <- 1:sum(edge > 0)#
   	tip.label <- 1:sum(edge > 0)#
    mode(edge) <- "character"#
    mode(tip.label) <- "character"#
    obj <- list(edge = edge, edge.length = edge.length, tip.label=tip.label)#
    class(obj) <- "phylo"#
    obj <- old2new.phylo(obj)#
    obj$tip.label = paste("s", 1:Ntip(obj), sep = "")#
	# Add final time step to continental configurations:#
	names(linked)[length(linked)] <- paste(strsplit(names(linked)[length(linked)], ":")[[1]][1], ":", t, sep="")#
	output <- list(position, linked, touching, obj, organism_long_matrix, organism_lat_matrix)#
	names(output) <- c("continent_positions", "continent_clusters", "continent_overlaps", "tree", "organism_longitudes", "organism_latitudes")
output
output$continent_positions
output$continent_clusters
output$continent_overlaps
output$tree
output$organism_longitudes
output$organism_latitudes
output$organism_latitudes[1,]
output$organism_latitudes[2,]
output$organism_latitudes[3,]
output$organism_latitudes[4,]
try<-output
plot(try$organism_longitudes[1,], try$organism_latitudes[1,], xlim=c(-180, 180), ylim=c(-90, 90), type = "l")
for (i in 1:nrow(try$organism_longitudes))   lines(try$organism_longitudes[i,], try$organism_latitudes[i,])
for(i in 1:N_continents) points(try$continent_positions[i,,1], try$continent_positions[i,,2], col=rainbow(N_steps))
touching
linked
touching_continents
HowManySeparateContinents
min_separation
radius*2
min_separation <- radius * 2
HowManySeparateContinents((radius * 2), continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])
longitudes <- continent_starting_points[, "Longitude"]; latitudes <- continent_starting_points[, "Latitude"]
longitudes
latitudes
intercontinental_links <- IntercontinentalLinks(min_separation, longitudes, latitudes, EarthRad = EarthRad)
intercontinental_links
# Get starting intercontinental distances:#
	intercontinental_links <- intercontinental_distance_matrix <- GreatCircleDistanceMatrix(longitudes, latitudes, EarthRad = EarthRad)
# Get starting intercontinental distances:#
	intercontinental_links <- intercontinental_distance_matrix <- GreatCircleDistanceMatrix(longitudes, latitudes, EarthRad = EarthRad)#
	# For each row:#
	for(i in 1:(nrow(intercontinental_distance_matrix) - 1)) {#
		# For each column:#
		for(j in (i + 1):nrow(intercontinental_distance_matrix)) {#
			# If continents are linked:#
			if(all.equal(intercontinental_distance_matrix[i, j], min_separation) == TRUE) {#
				# Record a one for the link:#
				intercontinental_links[j, i] <- intercontinental_links[i, j] <- 1#
			# If continents are not linked:#
			} else {#
				print("here")#
				# Record a zero for no link:#
				intercontinental_links[j, i] <- intercontinental_links[i, j] <- 0#
			}#
		}#
	}
intercontinental_distance_matrix[i, j], min_separation
intercontinental_distance_matrix[i, j] < min_separation
N_steps = 300; organism_multiplier = 1; N_continents = 7; radius = 2000; start_configuration = "supercontinent"; squishiness = 0.25; stickiness = 0.95; continent_speed_mean = 5; continent_speed_sd = 2; organism_step_sd = 100; b = 0.1; d = 0.05; EarthRad = 6367.4447; polar = FALSE
# Subfunction to find out which supercontinent a circle belongs to:#
	which_supercontinent <- function(cont, sprconts){#
		cont <- as.character(cont)#
		result <- which(unlist(lapply(lapply(lapply(strsplit(sprconts, "&"), match, cont), sort), length)) == 1)#
		return(result)#
	}#
	# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)#
# Are any continents joined at start?:#
#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
#
	# Get list of separate continents:#
	separate_continents <- HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
#
	# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
	touching_continents <- HowManySeparateContinents((radius * 2), continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
# Assign Euler poles to each separate continent:#
	# Randomly draw longitudes for each separated continent:#
	euler_pole_longitudes <- runif(length(separate_continents), -180, 180)#
	# Randomly draw latitudes for each separated continent:#
	euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
	# Ensure no latitude is directly at a pole (North or South) by redrawing if any are found:#
	if((sum(euler_pole_latitudes == 90) + sum(euler_pole_latitudes == -90)) > 0) euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
#
# Assign speeds to each separate continent:#
	# Create empty vector to store degrees per step (effectively the speed of movement) for each continent:#
	degrees_per_step <- vector(mode="numeric")#
	# For each separate continent:#
	for(i in 1:length(separate_continents)) {#
		# Get Greate Circle distances from Euler pole to each continent centre:#
		euler_GC_distances <- One2ManyGreatCircleDistance(euler_pole_longitudes[i], euler_pole_latitudes[i], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Longitude"], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Latitude"])#
		# Find GC distance to furthest continent (closest to euler pole "equator") in cluster (as speed will be assigned based on this):#
		furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
		# Randomly draw a continent speed:#
		continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# If a negative or zero speed is picked then redraw:#
		while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# Set degree change per step (effectively the speed):#
		degrees_per_step[i] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
	}#
#
	#starting information for the tree#
	dispersals <- matrix(nrow=0, ncol=5)#
	begin_cont <- ceiling(runif(1, 0, N_continents))#
	life_begins <- EndPoint(continent_starting_points[begin_cont, "Longitude"], continent_starting_points[begin_cont, "Latitude"], runif(1,0,360), runif(1,0,radius))#
	extra.rows <- matrix(NA,nrow=2,ncol= (N_steps * organism_multiplier) + 1)#
	organism_lat_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_long_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_lat_matrix[,1] <- life_begins$lat#
    organism_long_matrix[,1] <- life_begins$lon#
    rownames(organism_lat_matrix) <- rep(begin_cont, 2)#
    rownames(organism_long_matrix) <- rep(begin_cont, 2)#
    edge <- rbind(c(1, 2), c(1, 3)) # this is a starting edge matrix#
    edge.length <- rep(NA, 2)#
    stem.depth <- numeric(2)#
    alive <- rep(TRUE, 2) # marker for live lineages#
    ot <- 0; # time(step) at any point in the tree#
    next.node <- 4#
#
	# Now need to move them!#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	linked <- list()#
	linked[[1]] <- separate_continents#
	names(linked)[[1]] <- "1:1"#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	touching <- list()#
	touching[[1]] <- touching_continents#
#
	#Array to store the positions of every continent at each time step#
	position <- array(NA, c(N_continents, N_steps + 1, 2), c("continent", "timestep", "coordinate"))#
	position[,1,1] <- continent_starting_points[,"Longitude"]#
	position[,1,2] <- continent_starting_points[,"Latitude"]#
#
	temp_position<-matrix(nrow = N_continents, ncol=2)#
#
	progress <- seq(1, N_steps, floor(N_steps/50))#
	cat("Starting time steps \n")#
	cat("Progress \n")#
	cat("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n")#
#
	#for loops to move everything#
	for (t in 2:(N_steps + 1)) {#
		#distances apart before they move#
		starting_distances <- GreatCircleDistanceMatrix(position[,t-1,1], position[,t-1,2])#
#
		for (k in 1:N_continents) {#
			#find current longlat of the circle k#
			start_long <- position[k, t-1, 1]#
			start_lat <- position[k, t-1, 2]#
#
			#Identify which supercontinent, and therefore which element of the euler pole and speed vectors, the circle k belongs to#
			where <- which_supercontinent(k, tail(linked, n=1)[[1]])#
#
			#Find distance of circle from pole#
			distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where], lat2=euler_pole_latitudes[where], Warn = FALSE)#
			#Find bearing of circle from pole#
			init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where], euler_pole_latitudes[where], start_long, start_lat)#
#
			#Find the new bearing of circle from pole according to the speed specified#
			new_bearing <- (init_bearing + degrees_per_step[where]) %% 360#
#
			#Find the new location of the circle#
			new_loc <- EndPoint(euler_pole_longitudes[where], euler_pole_latitudes[where], new_bearing, distance)#
#
			#Add the new loction to the position matrix#
			temp_position[k,1] <- new_loc$long#
			temp_position[k,2] <- new_loc$lat#
#
		}#
#
		#Matrix of the distances between each continent in their new positions, before these are set#
		new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
		comp1 <- vector()#
		comp2 <- vector()#
#
		#Making a vector of whether any continents have collided and should be linked#
		collisions<-matrix(nrow=0, ncol=2)#
		for (q in 1:(N_continents-1)) {#
			for (p in (q+1):N_continents) {#
				comp1 <- all.equal(new_distances[p,q],starting_distances[p,q])#
				comp2 <- new_distances[p,q] <= min_separation#
				if (comp1 != TRUE && comp2 == TRUE) {#
					collisions<-rbind(collisions,c(p,q))#
				}#
			}#
		}#
#
		#Matrix of euler poles and speeds for each individual continent for moving the animals later#
		organism_mover <- matrix(nrow=N_continents, ncol= 3)#
		for (clump in 1:length(tail(linked, n=1)[[1]])) {#
			which_conts <- as.numeric(strsplit(tail(linked, n=1)[[1]][[clump]], "&")[[1]])#
			organism_mover[which_conts,1] <- rep(euler_pole_longitudes[clump],length(which_conts))#
			organism_mover[which_conts,2] <- rep(euler_pole_latitudes[clump],length(which_conts))#
			#This bit will get overwritten if there are collisions#
			organism_mover[which_conts,3] <- rep(degrees_per_step[clump],length(which_conts))#
		}#
		perm_collisions <- matrix(nrow=0, ncol=2)#
#
		# Moving continents back if there has only been one collision#
		while(nrow(collisions) > 0) {#
#
			# Set up vector to store proportional changes after collisions#
			proportion <- vector()#
#
			# Find out proportions to reduce to for all potential collisions#
			for (coll in 1:nrow(collisions)) {#
				cont_1 <- collisions[coll,1]#
				cont_2 <- collisions[coll,2]#
				where_1 <- which_supercontinent(cont_1, tail(linked, n=1)[[1]])#
				where_2 <- which_supercontinent(cont_2, tail(linked, n=1)[[1]])#
				continent_1_euler_longitude = euler_pole_longitudes[where_1]#
				continent_1_euler_latitude = euler_pole_latitudes[where_1]#
				continent_2_euler_longitude = euler_pole_longitudes[where_2]#
				continent_2_euler_latitude = euler_pole_latitudes[where_2]#
				continent_1_degrees_per_step = degrees_per_step[where_1]#
				continent_2_degrees_per_step = degrees_per_step[where_2]#
				proportion[coll] <- ColliderReverser(min_separation, position[cont_1, t-1, 1], position[cont_1, t-1, 2], temp_position[cont_1,1], temp_position[cont_1,2], position[cont_2, t-1, 1], position[cont_2, t-1, 2], temp_position[cont_2,1], temp_position[cont_2,2], continent_1_euler_longitude, continent_1_euler_latitude, continent_2_euler_longitude, continent_2_euler_latitude, continent_1_degrees_per_step, continent_2_degrees_per_step, EarthRad = 6367.4447, Warn = FALSE)#
			}#
#
			# Select proportion to move for first collision#
			first_collision <- match(min(proportion),proportion)#
#
			# Find the two continents that collided first#
			cont_involved <- sort(collisions[first_collision, ])#
#
			# Add to matrix of definite collisions that cannot be separated in the next step#
			perm_collisions <- rbind(perm_collisions, cont_involved)#
#
			# Move first clump back#
			head_of_collision_1 <- cont_involved[1]#
			where_1 <- which_supercontinent(head_of_collision_1, tail(linked, n=1)[[1]])#
#
			#Find the other continents that were attached to the collider#
			all_involved <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_1], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents in one of the clumps#
			for (rev in 1:length(all_involved)) {#
				cont_to_rev <- all_involved[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_1], lat2=euler_pole_latitudes[where_1], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], start_long, start_lat)#
#
				#degrees to add#
				addition <- proportion[first_collision] * degrees_per_step[where_1]#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <- (init_bearing + addition) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
#
				organism_mover[cont_to_rev,3] <- addition#
			}#
#
			#Move the second clump back#
			head_of_collision_2 <- cont_involved[2]#
			where_2 <- which_supercontinent(head_of_collision_2, tail(linked, n=1)[[1]])#
			all_involved_2 <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_2], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents the other clump#
			for (rev in 1:length(all_involved_2)) {#
				cont_to_rev <- all_involved_2[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_2], lat2=euler_pole_latitudes[where_2], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], start_long, start_lat)#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <-  (init_bearing + (proportion[first_collision] * degrees_per_step[where_2])) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
			}#
#
			#Recalculate the new distances#
			new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
			comp1 <- vector()#
			comp2 <- vector()#
#
			# Check whether any other collisions have still occurred#
			collisions <- matrix(nrow=0, ncol=2)#
			for (q in 1:(N_continents - 1)) {#
				for (p in (q+1):N_continents) {#
					comp1 <- all.equal(new_distances[p, q], starting_distances[p, q])#
					comp2 <- new_distances[p, q] <= min_separation#
					if (comp1 != TRUE && comp2 == TRUE) {#
						# If collision has not already been recorded:#
						if(length(sort(match(paste(sort(c(q, p)), collapse=""), apply(perm_collisions, 1, paste, collapse="")))) == 0) {#
							# Record collision:#
							collisions <- rbind(collisions, c(p, q))#
						}#
					}#
				}#
			}#
		}#
#
		# When it finishes while loop can now 'ossify' the positions and move to selecting separations#
		position[, t, 1] <- temp_position[, 1]#
		position[, t, 2] <- temp_position[, 2]#
#
# Finding out if anything gets separated#
		# How many separate continents are there now? (after collisions may have occurred):#
		separate_continents <- HowManySeparateContinents(min_separation, position[,t,1], position[,t,2])#
		# Make random uniform draws for each continental cluster:#
		separation_draws <- runif(length(grep("&", separate_continents)))#
		# Case if a separation occurs (drawn value is equal to or exceeds stickiness):#
		if(any(separation_draws >= stickiness)) {#
			# Get clusters of continents to split apart:#
			clusters_to_split <- separate_continents[grep("&", separate_continents)][which(separation_draws >= stickiness)]#
			# For each cluster to split apart:#
			for(i in 1:length(clusters_to_split)) {#
				# Get numbers of continents involved:#
				cluster_continent_numbers <- sort(strsplit(clusters_to_split[i], "&")[[1]])#
				# Get longitudes of continents in cluster:#
				cluster_longitudes <- position[as.numeric(cluster_continent_numbers), t, 1]#
#
				# Get latitudes of continents in cluster:#
				cluster_latitudes <- position[as.numeric(cluster_continent_numbers), t, 2]#
				# Make protected links an empty matrix:#
				cluster_protected_links <- matrix(nrow = 0, ncol = 2)#
				# If there are recent collisions (that will potentially need to be excluded from new splits):#
				if(length(perm_collisions) > 0) {#
					# For each new collision:#
					for(j in 1:nrow(perm_collisions)) {#
						# If new collision occurs within the cluster:#
						if(length(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers)) == 2) {#
							# Add new collision to protected links list:#
							cluster_protected_links <- rbind(cluster_protected_links, perm_collisions[j, ])#
						}#
					}#
#
				}#
				# Get splits (new clusters) of separated cluster:#
				splits <- ContinentSplitter(min_separation, cluster_longitudes, cluster_latitudes, cluster_continent_numbers, cluster_protected_links, EarthRad)#
				# Update separate continents vector:#
				separate_continents <- sort(c(separate_continents[-match(clusters_to_split[i], separate_continents)], splits))#
			}#
		}#
#
# Now change the Euler poles and speeds#
		# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
		touching_continents <- HowManySeparateContinents((radius * 2), position[,t,1], position[,t,2])#
		if (paste(sort(touching_continents), collapse="") != paste(sort(tail(touching,n=1)[[1]]), collapse="")) {#
			touching <- c(touching, list(touching_continents))#
		}#
#
		# If the continental clustering has changed:#
		if (paste(sort(separate_continents), collapse="") != paste(sort(tail(linked,n=1)[[1]]), collapse="")) {#
			# Add new continental configuration to linked list#
			linked <- c(linked, list(separate_continents))#
#
			# Update time step for previous continental configuration:#
			names(linked)[(length(linked) - 1)] <- paste(strsplit(names(linked[(length(linked) - 1)]), ":")[[1]][1], ":", t - 1, sep="")#
			# Add time step to new continental configuration:#
			names(linked)[length(linked)] <- paste(t, ":", t, sep="")#
			# Select continents that are different to previous time step#
			toKeep <- c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]])[duplicated(c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]]))]#
#
			#Vectors for new poles and speeds#
			new_euler_latitudes <- rep(NA, length(separate_continents))#
			new_euler_longitudes <- rep(NA, length(separate_continents))#
			new_degrees_per_step <- rep(NA, length(separate_continents))#
#
			if (length(toKeep) != 0){#
				#Inherit previous poles and speeds for those clumps that remain the same#
				for (y in 1:length(toKeep)) {#
					new_euler_longitudes[match(toKeep[y],separate_continents)]<- euler_pole_longitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_euler_latitudes[match(toKeep[y],separate_continents)]<- euler_pole_latitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_degrees_per_step[match(toKeep[y],separate_continents)]<- degrees_per_step[match(toKeep[y],tail(linked, n=2)[[1]])]#
				}#
			}#
#
			# Make new Euler poles#
			new_euler_longitudes[is.na(new_euler_longitudes)]<- runif((length(separate_continents)-length(toKeep)), -180, 180)#
#
			changed_euler_latitudes<- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			while((sum(changed_euler_latitudes == 90) + sum(changed_euler_latitudes == -90)) > 0) changed_euler_latitudes <- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			new_euler_latitudes[is.na(new_euler_latitudes)] <- changed_euler_latitudes#
#
			# Get Great Circle distances from Euler pole to each continent centre:#
			for (l in 1:(length(separate_continents)-length(toKeep))) {#
				# Find the first NA to fill in:#
				changer <- match(NA, new_degrees_per_step)#
				#Find the contients that are in the clump whose speed is going to change#
				rows <- as.numeric(unlist(strsplit(separate_continents[changer], "&")))#
				#Find the new euler pole for that clump#
				euler_long <- new_euler_longitudes[changer]#
				euler_lat <- new_euler_latitudes[changer]#
				#Find the distances of each of the continents in the clump from their new euler pole#
				euler_GC_distances <- One2ManyGreatCircleDistance(euler_long, euler_lat, position[rows, t, 1], position[rows, t, 2])#
				#Find which of those is closest to the equator#
				furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
				# Randomly draw a continent speed:#
				continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# If a negative or zero speed is picked then redraw:#
				while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# Set degree change per step (effectively the speed):#
				new_degrees_per_step[changer] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
			}#
			euler_pole_longitudes <- new_euler_longitudes#
			euler_pole_latitudes <- new_euler_latitudes#
			degrees_per_step <- new_degrees_per_step#
		}#
#
#Need to add in the tree bit#
		#Move the animals with the continents#
		for (cont in 1:N_continents) {#
			#Find the rows that are in the continent of focus#
			moving <- which(rownames(organism_long_matrix)==cont)#
#
			if (length(moving)==0) {#
				next #
			} else {#
				#Find out how many degrees around the euler pole that continent went#
				organism_degrees <- organism_mover[cont,3]#
				#loops through all the organisms that are currently living#
				for (organism in 1:length(moving)) {#
					organism_row <- moving[organism]#
					if (is.na(organism_long_matrix[organism_row, ot + 1])) {#
						next#
					} else {#
						first_long <- organism_long_matrix[organism_row, ot + 1]#
						first_lat <- organism_lat_matrix[organism_row, ot + 1]#
						organism_distance <- GreatCircleDistanceFromLongLat(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						organism_bearing <- BearingBetweenTwoLongLatPoints(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						new_organism_bearing <- (organism_bearing + organism_degrees) %% 360#
						new_organism_loc <- EndPoint(organism_mover[cont,1], organism_mover[cont,2], new_organism_bearing, organism_distance)#
						organism_long_matrix[organism_row, ot + 1] <- new_organism_loc$long#
    					organism_lat_matrix[organism_row, ot + 1] <- new_organism_loc$lat#
					}#
				}#
			}#
		}#
		for (f in 1:organism_multiplier) {#
            if (sum(alive) == 0) stop("METEOR IMPACT!! EVERYTHING HAS GONE EXTINCT! AAAAHHHHHH!!!")#
            dt<-1#
            ot <- ot + dt#
            for (m in 1:nrow(organism_lat_matrix)) {#
                if (alive[m]) {#
                    starting<-c(organism_lat_matrix[m,ot],organism_long_matrix[m,ot])#
                    moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd))) #generates a random walk step and calculates new position#
                    on_cont <- as.numeric(rownames(organism_lat_matrix)[m])#
                    friends <- as.numeric(strsplit(tail(touching, n=1)[[1]][which_supercontinent(on_cont, tail(touching, n=1)[[1]])], "&")[[1]])#
                    dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    if (length(friends) > 1) {#
                    	all_dist <- vector(length = length(friends))#
                    	for (g in 1:length(friends)) {#
                    		all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    	}#
                    	while (min(all_dist) > radius) {#
                    		moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		temp_all_dist <- vector(length = length(friends))#
                    		for (g in 1:length(friends)) {#
                    			temp_all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    		}#
                    		all_dist <- temp_all_dist#
                    	}#
                    	new_cont <- friends[which(all_dist == min(all_dist))] #
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                    	rownames(organism_long_matrix)[m] <- new_cont#
                    	rownames(organism_lat_matrix)[m] <- new_cont#
                    	if(new_cont != on_cont) {#
                    		dispersals <- rbind(dispersals, c(on_cont, new_cont, m, t, ot+1))#
                    	}#
                    } else {#
                    	while (dist_from_center >= radius) {#
                    		moveto <- EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    	}#
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                	}#
                }#
            }#
#
            r <- runif(1)#
            if (r <= b/(b + d)) { ###4 #this creates a bifucation in the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                e <- matrix(edge[alive,], ncol = 2)#
                parent <- e[random_lineage,2]#
                x <- which(edge[,2] == parent)#
                new.rows.lat <- new.rows.long <- extra.rows#
                new.rows.lat[, ot+1] <- organism_lat_matrix[x, ot+1] #updates the long and lat matricies with new coordiantes for each lineage#
                new.rows.long[, ot+1] <- organism_long_matrix[x, ot+1]#
                rownames(new.rows.lat) <- rep(rownames(organism_lat_matrix)[x],2)#
                rownames(new.rows.long) <- rep(rownames(organism_long_matrix)[x],2)#
                organism_lat_matrix <- rbind(organism_lat_matrix,new.rows.lat)#
                organism_long_matrix <- rbind(organism_long_matrix,new.rows.long)#
                alive[alive][random_lineage] <- FALSE#
                edge <- rbind(edge, c(parent, next.node), c(parent, next.node + 1))#
                next.node <- next.node + 2#
                alive <- c(alive, TRUE, TRUE)#
                stem.depth <- c(stem.depth, ot, ot)#
                edge.length[x] <- ot - stem.depth[x]#
                edge.length<-c(edge.length, NA, NA)#
            } else {###4 This terminates one of the current lineages on the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                edge.length[alive][random_lineage] <- ot - stem.depth[alive][random_lineage]#
                alive[alive][random_lineage] <- FALSE#
            }###4#
        }#1A#
        if (any(progress == t)) {#
        	cat("- ")#
        }#
    }#
#
    #Things to do right at the end to turn it into a phylo object#
    edge.length[alive] <- ot - stem.depth[alive];#
    n <- -1#
    for (f in 1:max(edge)) {#
        if (any(edge[,1] == f)) {#
           	edge[which(edge[,1] == f), 1] <- n#
           	edge[which(edge[,2] == f), 2] <- n#
           	n <- n - 1;#
        }#
    }#
    edge[edge > 0] <- 1:sum(edge > 0)#
   	tip.label <- 1:sum(edge > 0)#
    mode(edge) <- "character"#
    mode(tip.label) <- "character"#
    obj <- list(edge = edge, edge.length = edge.length, tip.label=tip.label)#
    class(obj) <- "phylo"#
    obj <- old2new.phylo(obj)#
    obj$tip.label = paste("s", 1:Ntip(obj), sep = "")#
	# Add final time step to continental configurations:#
	names(linked)[length(linked)] <- paste(strsplit(names(linked)[length(linked)], ":")[[1]][1], ":", t, sep="")#
	output <- list(position, linked, touching, obj, organism_long_matrix, organism_lat_matrix)#
	names(output) <- c("continent_positions", "continent_clusters", "continent_overlaps", "tree", "organism_longitudes", "organism_latitudes")
# Subfunction to find out which supercontinent a circle belongs to:#
	which_supercontinent <- function(cont, sprconts){#
		cont <- as.character(cont)#
		result <- which(unlist(lapply(lapply(lapply(strsplit(sprconts, "&"), match, cont), sort), length)) == 1)#
		return(result)#
	}#
	# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)#
# Are any continents joined at start?:#
#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
#
	# Get list of separate continents:#
	separate_continents <- HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
#
	# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
	touching_continents <- HowManySeparateContinents((radius * 2), continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
# Assign Euler poles to each separate continent:#
	# Randomly draw longitudes for each separated continent:#
	euler_pole_longitudes <- runif(length(separate_continents), -180, 180)#
	# Randomly draw latitudes for each separated continent:#
	euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
	# Ensure no latitude is directly at a pole (North or South) by redrawing if any are found:#
	if((sum(euler_pole_latitudes == 90) + sum(euler_pole_latitudes == -90)) > 0) euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
#
# Assign speeds to each separate continent:#
	# Create empty vector to store degrees per step (effectively the speed of movement) for each continent:#
	degrees_per_step <- vector(mode="numeric")#
	# For each separate continent:#
	for(i in 1:length(separate_continents)) {#
		# Get Greate Circle distances from Euler pole to each continent centre:#
		euler_GC_distances <- One2ManyGreatCircleDistance(euler_pole_longitudes[i], euler_pole_latitudes[i], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Longitude"], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Latitude"])#
		# Find GC distance to furthest continent (closest to euler pole "equator") in cluster (as speed will be assigned based on this):#
		furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
		# Randomly draw a continent speed:#
		continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# If a negative or zero speed is picked then redraw:#
		while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# Set degree change per step (effectively the speed):#
		degrees_per_step[i] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
	}#
#
	#starting information for the tree#
	dispersals <- matrix(nrow=0, ncol=5)#
	begin_cont <- ceiling(runif(1, 0, N_continents))#
	life_begins <- EndPoint(continent_starting_points[begin_cont, "Longitude"], continent_starting_points[begin_cont, "Latitude"], runif(1,0,360), runif(1,0,radius))#
	extra.rows <- matrix(NA,nrow=2,ncol= (N_steps * organism_multiplier) + 1)#
	organism_lat_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_long_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_lat_matrix[,1] <- life_begins$lat#
    organism_long_matrix[,1] <- life_begins$lon#
    rownames(organism_lat_matrix) <- rep(begin_cont, 2)#
    rownames(organism_long_matrix) <- rep(begin_cont, 2)#
    edge <- rbind(c(1, 2), c(1, 3)) # this is a starting edge matrix#
    edge.length <- rep(NA, 2)#
    stem.depth <- numeric(2)#
    alive <- rep(TRUE, 2) # marker for live lineages#
    ot <- 0; # time(step) at any point in the tree#
    next.node <- 4#
#
	# Now need to move them!#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	linked <- list()#
	linked[[1]] <- separate_continents#
	names(linked)[[1]] <- "1:1"#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	touching <- list()#
	touching[[1]] <- touching_continents#
#
	#Array to store the positions of every continent at each time step#
	position <- array(NA, c(N_continents, N_steps + 1, 2), c("continent", "timestep", "coordinate"))#
	position[,1,1] <- continent_starting_points[,"Longitude"]#
	position[,1,2] <- continent_starting_points[,"Latitude"]#
#
	temp_position<-matrix(nrow = N_continents, ncol=2)#
#
	progress <- seq(1, N_steps, floor(N_steps/50))#
	cat("Starting time steps \n")#
	cat("Progress \n")#
	cat("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n")#
#
	#for loops to move everything#
	for (t in 2:(N_steps + 1)) {#
		#distances apart before they move#
		starting_distances <- GreatCircleDistanceMatrix(position[,t-1,1], position[,t-1,2])#
#
		for (k in 1:N_continents) {#
			#find current longlat of the circle k#
			start_long <- position[k, t-1, 1]#
			start_lat <- position[k, t-1, 2]#
#
			#Identify which supercontinent, and therefore which element of the euler pole and speed vectors, the circle k belongs to#
			where <- which_supercontinent(k, tail(linked, n=1)[[1]])#
#
			#Find distance of circle from pole#
			distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where], lat2=euler_pole_latitudes[where], Warn = FALSE)#
			#Find bearing of circle from pole#
			init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where], euler_pole_latitudes[where], start_long, start_lat)#
#
			#Find the new bearing of circle from pole according to the speed specified#
			new_bearing <- (init_bearing + degrees_per_step[where]) %% 360#
#
			#Find the new location of the circle#
			new_loc <- EndPoint(euler_pole_longitudes[where], euler_pole_latitudes[where], new_bearing, distance)#
#
			#Add the new loction to the position matrix#
			temp_position[k,1] <- new_loc$long#
			temp_position[k,2] <- new_loc$lat#
#
		}#
#
		#Matrix of the distances between each continent in their new positions, before these are set#
		new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
		comp1 <- vector()#
		comp2 <- vector()#
#
		#Making a vector of whether any continents have collided and should be linked#
		collisions<-matrix(nrow=0, ncol=2)#
		for (q in 1:(N_continents-1)) {#
			for (p in (q+1):N_continents) {#
				comp1 <- all.equal(new_distances[p,q],starting_distances[p,q])#
				comp2 <- new_distances[p,q] <= min_separation#
				if (comp1 != TRUE && comp2 == TRUE) {#
					collisions<-rbind(collisions,c(p,q))#
				}#
			}#
		}#
#
		#Matrix of euler poles and speeds for each individual continent for moving the animals later#
		organism_mover <- matrix(nrow=N_continents, ncol= 3)#
		for (clump in 1:length(tail(linked, n=1)[[1]])) {#
			which_conts <- as.numeric(strsplit(tail(linked, n=1)[[1]][[clump]], "&")[[1]])#
			organism_mover[which_conts,1] <- rep(euler_pole_longitudes[clump],length(which_conts))#
			organism_mover[which_conts,2] <- rep(euler_pole_latitudes[clump],length(which_conts))#
			#This bit will get overwritten if there are collisions#
			organism_mover[which_conts,3] <- rep(degrees_per_step[clump],length(which_conts))#
		}#
		perm_collisions <- matrix(nrow=0, ncol=2)#
#
		# Moving continents back if there has only been one collision#
		while(nrow(collisions) > 0) {#
#
			# Set up vector to store proportional changes after collisions#
			proportion <- vector()#
#
			# Find out proportions to reduce to for all potential collisions#
			for (coll in 1:nrow(collisions)) {#
				cont_1 <- collisions[coll,1]#
				cont_2 <- collisions[coll,2]#
				where_1 <- which_supercontinent(cont_1, tail(linked, n=1)[[1]])#
				where_2 <- which_supercontinent(cont_2, tail(linked, n=1)[[1]])#
				continent_1_euler_longitude = euler_pole_longitudes[where_1]#
				continent_1_euler_latitude = euler_pole_latitudes[where_1]#
				continent_2_euler_longitude = euler_pole_longitudes[where_2]#
				continent_2_euler_latitude = euler_pole_latitudes[where_2]#
				continent_1_degrees_per_step = degrees_per_step[where_1]#
				continent_2_degrees_per_step = degrees_per_step[where_2]#
				proportion[coll] <- ColliderReverser(min_separation, position[cont_1, t-1, 1], position[cont_1, t-1, 2], temp_position[cont_1,1], temp_position[cont_1,2], position[cont_2, t-1, 1], position[cont_2, t-1, 2], temp_position[cont_2,1], temp_position[cont_2,2], continent_1_euler_longitude, continent_1_euler_latitude, continent_2_euler_longitude, continent_2_euler_latitude, continent_1_degrees_per_step, continent_2_degrees_per_step, EarthRad = 6367.4447, Warn = FALSE)#
			}#
#
			# Select proportion to move for first collision#
			first_collision <- match(min(proportion),proportion)#
#
			# Find the two continents that collided first#
			cont_involved <- sort(collisions[first_collision, ])#
#
			# Add to matrix of definite collisions that cannot be separated in the next step#
			perm_collisions <- rbind(perm_collisions, cont_involved)#
#
			# Move first clump back#
			head_of_collision_1 <- cont_involved[1]#
			where_1 <- which_supercontinent(head_of_collision_1, tail(linked, n=1)[[1]])#
#
			#Find the other continents that were attached to the collider#
			all_involved <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_1], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents in one of the clumps#
			for (rev in 1:length(all_involved)) {#
				cont_to_rev <- all_involved[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_1], lat2=euler_pole_latitudes[where_1], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], start_long, start_lat)#
#
				#degrees to add#
				addition <- proportion[first_collision] * degrees_per_step[where_1]#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <- (init_bearing + addition) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
#
				organism_mover[cont_to_rev,3] <- addition#
			}#
#
			#Move the second clump back#
			head_of_collision_2 <- cont_involved[2]#
			where_2 <- which_supercontinent(head_of_collision_2, tail(linked, n=1)[[1]])#
			all_involved_2 <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_2], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents the other clump#
			for (rev in 1:length(all_involved_2)) {#
				cont_to_rev <- all_involved_2[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_2], lat2=euler_pole_latitudes[where_2], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], start_long, start_lat)#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <-  (init_bearing + (proportion[first_collision] * degrees_per_step[where_2])) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
			}#
#
			#Recalculate the new distances#
			new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
			comp1 <- vector()#
			comp2 <- vector()#
#
			# Check whether any other collisions have still occurred#
			collisions <- matrix(nrow=0, ncol=2)#
			for (q in 1:(N_continents - 1)) {#
				for (p in (q+1):N_continents) {#
					comp1 <- all.equal(new_distances[p, q], starting_distances[p, q])#
					comp2 <- new_distances[p, q] <= min_separation#
					if (comp1 != TRUE && comp2 == TRUE) {#
						# If collision has not already been recorded:#
						if(length(sort(match(paste(sort(c(q, p)), collapse=""), apply(perm_collisions, 1, paste, collapse="")))) == 0) {#
							# Record collision:#
							collisions <- rbind(collisions, c(p, q))#
						}#
					}#
				}#
			}#
		}#
#
		# When it finishes while loop can now 'ossify' the positions and move to selecting separations#
		position[, t, 1] <- temp_position[, 1]#
		position[, t, 2] <- temp_position[, 2]#
#
# Finding out if anything gets separated#
		# How many separate continents are there now? (after collisions may have occurred):#
		separate_continents <- HowManySeparateContinents(min_separation, position[,t,1], position[,t,2])#
		# Make random uniform draws for each continental cluster:#
		separation_draws <- runif(length(grep("&", separate_continents)))#
		# Case if a separation occurs (drawn value is equal to or exceeds stickiness):#
		if(any(separation_draws >= stickiness)) {#
			# Get clusters of continents to split apart:#
			clusters_to_split <- separate_continents[grep("&", separate_continents)][which(separation_draws >= stickiness)]#
			# For each cluster to split apart:#
			for(i in 1:length(clusters_to_split)) {#
				# Get numbers of continents involved:#
				cluster_continent_numbers <- sort(strsplit(clusters_to_split[i], "&")[[1]])#
				# Get longitudes of continents in cluster:#
				cluster_longitudes <- position[as.numeric(cluster_continent_numbers), t, 1]#
#
				# Get latitudes of continents in cluster:#
				cluster_latitudes <- position[as.numeric(cluster_continent_numbers), t, 2]#
				# Make protected links an empty matrix:#
				cluster_protected_links <- matrix(nrow = 0, ncol = 2)#
				# If there are recent collisions (that will potentially need to be excluded from new splits):#
				if(length(perm_collisions) > 0) {#
					# For each new collision:#
					for(j in 1:nrow(perm_collisions)) {#
						# If new collision occurs within the cluster:#
						if(length(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers)) == 2) {#
							# Add new collision to protected links list:#
							cluster_protected_links <- rbind(cluster_protected_links, perm_collisions[j, ])#
						}#
					}#
#
				}#
				# Get splits (new clusters) of separated cluster:#
				splits <- ContinentSplitter(min_separation, cluster_longitudes, cluster_latitudes, cluster_continent_numbers, cluster_protected_links, EarthRad)#
				# Update separate continents vector:#
				separate_continents <- sort(c(separate_continents[-match(clusters_to_split[i], separate_continents)], splits))#
			}#
		}#
#
# Now change the Euler poles and speeds#
		# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
		touching_continents <- HowManySeparateContinents((radius * 2), position[,t,1], position[,t,2])#
		if (paste(sort(touching_continents), collapse="") != paste(sort(tail(touching,n=1)[[1]]), collapse="")) {#
			touching <- c(touching, list(touching_continents))#
		}#
#
		# If the continental clustering has changed:#
		if (paste(sort(separate_continents), collapse="") != paste(sort(tail(linked,n=1)[[1]]), collapse="")) {#
			# Add new continental configuration to linked list#
			linked <- c(linked, list(separate_continents))#
#
			# Update time step for previous continental configuration:#
			names(linked)[(length(linked) - 1)] <- paste(strsplit(names(linked[(length(linked) - 1)]), ":")[[1]][1], ":", t - 1, sep="")#
			# Add time step to new continental configuration:#
			names(linked)[length(linked)] <- paste(t, ":", t, sep="")#
			# Select continents that are different to previous time step#
			toKeep <- c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]])[duplicated(c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]]))]#
#
			#Vectors for new poles and speeds#
			new_euler_latitudes <- rep(NA, length(separate_continents))#
			new_euler_longitudes <- rep(NA, length(separate_continents))#
			new_degrees_per_step <- rep(NA, length(separate_continents))#
#
			if (length(toKeep) != 0){#
				#Inherit previous poles and speeds for those clumps that remain the same#
				for (y in 1:length(toKeep)) {#
					new_euler_longitudes[match(toKeep[y],separate_continents)]<- euler_pole_longitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_euler_latitudes[match(toKeep[y],separate_continents)]<- euler_pole_latitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_degrees_per_step[match(toKeep[y],separate_continents)]<- degrees_per_step[match(toKeep[y],tail(linked, n=2)[[1]])]#
				}#
			}#
#
			# Make new Euler poles#
			new_euler_longitudes[is.na(new_euler_longitudes)]<- runif((length(separate_continents)-length(toKeep)), -180, 180)#
#
			changed_euler_latitudes<- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			while((sum(changed_euler_latitudes == 90) + sum(changed_euler_latitudes == -90)) > 0) changed_euler_latitudes <- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			new_euler_latitudes[is.na(new_euler_latitudes)] <- changed_euler_latitudes#
#
			# Get Great Circle distances from Euler pole to each continent centre:#
			for (l in 1:(length(separate_continents)-length(toKeep))) {#
				# Find the first NA to fill in:#
				changer <- match(NA, new_degrees_per_step)#
				#Find the contients that are in the clump whose speed is going to change#
				rows <- as.numeric(unlist(strsplit(separate_continents[changer], "&")))#
				#Find the new euler pole for that clump#
				euler_long <- new_euler_longitudes[changer]#
				euler_lat <- new_euler_latitudes[changer]#
				#Find the distances of each of the continents in the clump from their new euler pole#
				euler_GC_distances <- One2ManyGreatCircleDistance(euler_long, euler_lat, position[rows, t, 1], position[rows, t, 2])#
				#Find which of those is closest to the equator#
				furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
				# Randomly draw a continent speed:#
				continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# If a negative or zero speed is picked then redraw:#
				while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# Set degree change per step (effectively the speed):#
				new_degrees_per_step[changer] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
			}#
			euler_pole_longitudes <- new_euler_longitudes#
			euler_pole_latitudes <- new_euler_latitudes#
			degrees_per_step <- new_degrees_per_step#
		}#
#
#Need to add in the tree bit#
		#Move the animals with the continents#
		for (cont in 1:N_continents) {#
			#Find the rows that are in the continent of focus#
			moving <- which(rownames(organism_long_matrix)==cont)#
#
			if (length(moving)==0) {#
				next #
			} else {#
				#Find out how many degrees around the euler pole that continent went#
				organism_degrees <- organism_mover[cont,3]#
				#loops through all the organisms that are currently living#
				for (organism in 1:length(moving)) {#
					organism_row <- moving[organism]#
					if (is.na(organism_long_matrix[organism_row, ot + 1])) {#
						next#
					} else {#
						first_long <- organism_long_matrix[organism_row, ot + 1]#
						first_lat <- organism_lat_matrix[organism_row, ot + 1]#
						organism_distance <- GreatCircleDistanceFromLongLat(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						organism_bearing <- BearingBetweenTwoLongLatPoints(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						new_organism_bearing <- (organism_bearing + organism_degrees) %% 360#
						new_organism_loc <- EndPoint(organism_mover[cont,1], organism_mover[cont,2], new_organism_bearing, organism_distance)#
						organism_long_matrix[organism_row, ot + 1] <- new_organism_loc$long#
    					organism_lat_matrix[organism_row, ot + 1] <- new_organism_loc$lat#
					}#
				}#
			}#
		}#
		for (f in 1:organism_multiplier) {#
            if (sum(alive) == 0) stop("METEOR IMPACT!! EVERYTHING HAS GONE EXTINCT! AAAAHHHHHH!!!")#
            dt<-1#
            ot <- ot + dt#
            for (m in 1:nrow(organism_lat_matrix)) {#
                if (alive[m]) {#
                    starting<-c(organism_lat_matrix[m,ot],organism_long_matrix[m,ot])#
                    moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd))) #generates a random walk step and calculates new position#
                    on_cont <- as.numeric(rownames(organism_lat_matrix)[m])#
                    friends <- as.numeric(strsplit(tail(touching, n=1)[[1]][which_supercontinent(on_cont, tail(touching, n=1)[[1]])], "&")[[1]])#
                    dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    if (length(friends) > 1) {#
                    	all_dist <- vector(length = length(friends))#
                    	for (g in 1:length(friends)) {#
                    		all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    	}#
                    	while (min(all_dist) > radius) {#
                    		moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		temp_all_dist <- vector(length = length(friends))#
                    		for (g in 1:length(friends)) {#
                    			temp_all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    		}#
                    		all_dist <- temp_all_dist#
                    	}#
                    	new_cont <- friends[which(all_dist == min(all_dist))] #
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                    	rownames(organism_long_matrix)[m] <- new_cont#
                    	rownames(organism_lat_matrix)[m] <- new_cont#
                    	if(new_cont != on_cont) {#
                    		dispersals <- rbind(dispersals, c(on_cont, new_cont, m, t, ot+1))#
                    	}#
                    } else {#
                    	while (dist_from_center >= radius) {#
                    		moveto <- EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    	}#
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                	}#
                }#
            }#
#
            r <- runif(1)#
            if (r <= b/(b + d)) { ###4 #this creates a bifucation in the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                e <- matrix(edge[alive,], ncol = 2)#
                parent <- e[random_lineage,2]#
                x <- which(edge[,2] == parent)#
                new.rows.lat <- new.rows.long <- extra.rows#
                new.rows.lat[, ot+1] <- organism_lat_matrix[x, ot+1] #updates the long and lat matricies with new coordiantes for each lineage#
                new.rows.long[, ot+1] <- organism_long_matrix[x, ot+1]#
                rownames(new.rows.lat) <- rep(rownames(organism_lat_matrix)[x],2)#
                rownames(new.rows.long) <- rep(rownames(organism_long_matrix)[x],2)#
                organism_lat_matrix <- rbind(organism_lat_matrix,new.rows.lat)#
                organism_long_matrix <- rbind(organism_long_matrix,new.rows.long)#
                alive[alive][random_lineage] <- FALSE#
                edge <- rbind(edge, c(parent, next.node), c(parent, next.node + 1))#
                next.node <- next.node + 2#
                alive <- c(alive, TRUE, TRUE)#
                stem.depth <- c(stem.depth, ot, ot)#
                edge.length[x] <- ot - stem.depth[x]#
                edge.length<-c(edge.length, NA, NA)#
            } else {###4 This terminates one of the current lineages on the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                edge.length[alive][random_lineage] <- ot - stem.depth[alive][random_lineage]#
                alive[alive][random_lineage] <- FALSE#
            }###4#
        }#1A#
        if (any(progress == t)) {#
        	cat("- ")#
        }#
    }#
#
    #Things to do right at the end to turn it into a phylo object#
    edge.length[alive] <- ot - stem.depth[alive];#
    n <- -1#
    for (f in 1:max(edge)) {#
        if (any(edge[,1] == f)) {#
           	edge[which(edge[,1] == f), 1] <- n#
           	edge[which(edge[,2] == f), 2] <- n#
           	n <- n - 1;#
        }#
    }#
    edge[edge > 0] <- 1:sum(edge > 0)#
   	tip.label <- 1:sum(edge > 0)#
    mode(edge) <- "character"#
    mode(tip.label) <- "character"#
    obj <- list(edge = edge, edge.length = edge.length, tip.label=tip.label)#
    class(obj) <- "phylo"#
    obj <- old2new.phylo(obj)#
    obj$tip.label = paste("s", 1:Ntip(obj), sep = "")#
	# Add final time step to continental configurations:#
	names(linked)[length(linked)] <- paste(strsplit(names(linked)[length(linked)], ":")[[1]][1], ":", t, sep="")#
	output <- list(position, linked, touching, obj, organism_long_matrix, organism_lat_matrix)#
	names(output) <- c("continent_positions", "continent_clusters", "continent_overlaps", "tree", "organism_longitudes", "organism_latitudes")
try <- output
plot(try$organism_longitudes[1,], try$organism_latitudes[1,], xlim=c(-180, 180), ylim=c(-90, 90), type = "l")
for (i in 1:nrow(try$organism_longitudes))   lines(try$organism_longitudes[i,], try$organism_latitudes[i,])
for(i in 1:N_continents) points(try$continent_positions[i,,1], try$continent_positions[i,,2], col=rainbow(N_steps))
touching
document()
check()
install()
# Subfunction to find out which supercontinent a circle belongs to:#
	which_supercontinent <- function(cont, sprconts){#
		cont <- as.character(cont)#
		result <- which(unlist(lapply(lapply(lapply(strsplit(sprconts, "&"), match, cont), sort), length)) == 1)#
		return(result)#
	}#
	# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)#
# Are any continents joined at start?:#
#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
#
	# Get list of separate continents:#
	separate_continents <- HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
#
	# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
	touching_continents <- HowManySeparateContinents((radius * 2), continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
# Assign Euler poles to each separate continent:#
	# Randomly draw longitudes for each separated continent:#
	euler_pole_longitudes <- runif(length(separate_continents), -180, 180)#
	# Randomly draw latitudes for each separated continent:#
	euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
	# Ensure no latitude is directly at a pole (North or South) by redrawing if any are found:#
	if((sum(euler_pole_latitudes == 90) + sum(euler_pole_latitudes == -90)) > 0) euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
#
# Assign speeds to each separate continent:#
	# Create empty vector to store degrees per step (effectively the speed of movement) for each continent:#
	degrees_per_step <- vector(mode="numeric")#
	# For each separate continent:#
	for(i in 1:length(separate_continents)) {#
		# Get Greate Circle distances from Euler pole to each continent centre:#
		euler_GC_distances <- One2ManyGreatCircleDistance(euler_pole_longitudes[i], euler_pole_latitudes[i], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Longitude"], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Latitude"])#
		# Find GC distance to furthest continent (closest to euler pole "equator") in cluster (as speed will be assigned based on this):#
		furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
		# Randomly draw a continent speed:#
		continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# If a negative or zero speed is picked then redraw:#
		while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# Set degree change per step (effectively the speed):#
		degrees_per_step[i] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
	}#
#
	#starting information for the tree#
	dispersals <- matrix(nrow=0, ncol=5)#
	begin_cont <- ceiling(runif(1, 0, N_continents))#
	life_begins <- EndPoint(continent_starting_points[begin_cont, "Longitude"], continent_starting_points[begin_cont, "Latitude"], runif(1,0,360), runif(1,0,radius))#
	extra.rows <- matrix(NA,nrow=2,ncol= (N_steps * organism_multiplier) + 1)#
	organism_lat_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_long_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_lat_matrix[,1] <- life_begins$lat#
    organism_long_matrix[,1] <- life_begins$lon#
    rownames(organism_lat_matrix) <- rep(begin_cont, 2)#
    rownames(organism_long_matrix) <- rep(begin_cont, 2)#
    edge <- rbind(c(1, 2), c(1, 3)) # this is a starting edge matrix#
    edge.length <- rep(NA, 2)#
    stem.depth <- numeric(2)#
    alive <- rep(TRUE, 2) # marker for live lineages#
    ot <- 0; # time(step) at any point in the tree#
    next.node <- 4#
#
	# Now need to move them!#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	linked <- list()#
	linked[[1]] <- separate_continents#
	names(linked)[[1]] <- "1:1"#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	touching <- list()#
	touching[[1]] <- touching_continents#
#
	#Array to store the positions of every continent at each time step#
	position <- array(NA, c(N_continents, N_steps + 1, 2), c("continent", "timestep", "coordinate"))#
	position[,1,1] <- continent_starting_points[,"Longitude"]#
	position[,1,2] <- continent_starting_points[,"Latitude"]#
#
	temp_position<-matrix(nrow = N_continents, ncol=2)#
#
	progress <- seq(1, N_steps, floor(N_steps/50))#
	cat("Starting time steps \n")#
	cat("Progress \n")#
	cat("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n")#
#
	#for loops to move everything#
	for (t in 2:(N_steps + 1)) {#
		#distances apart before they move#
		starting_distances <- GreatCircleDistanceMatrix(position[,t-1,1], position[,t-1,2])#
#
		for (k in 1:N_continents) {#
			#find current longlat of the circle k#
			start_long <- position[k, t-1, 1]#
			start_lat <- position[k, t-1, 2]#
#
			#Identify which supercontinent, and therefore which element of the euler pole and speed vectors, the circle k belongs to#
			where <- which_supercontinent(k, tail(linked, n=1)[[1]])#
#
			#Find distance of circle from pole#
			distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where], lat2=euler_pole_latitudes[where], Warn = FALSE)#
			#Find bearing of circle from pole#
			init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where], euler_pole_latitudes[where], start_long, start_lat)#
#
			#Find the new bearing of circle from pole according to the speed specified#
			new_bearing <- (init_bearing + degrees_per_step[where]) %% 360#
#
			#Find the new location of the circle#
			new_loc <- EndPoint(euler_pole_longitudes[where], euler_pole_latitudes[where], new_bearing, distance)#
#
			#Add the new loction to the position matrix#
			temp_position[k,1] <- new_loc$long#
			temp_position[k,2] <- new_loc$lat#
#
		}#
#
		#Matrix of the distances between each continent in their new positions, before these are set#
		new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
		comp1 <- vector()#
		comp2 <- vector()#
#
		#Making a vector of whether any continents have collided and should be linked#
		collisions<-matrix(nrow=0, ncol=2)#
		for (q in 1:(N_continents-1)) {#
			for (p in (q+1):N_continents) {#
				comp1 <- all.equal(new_distances[p,q],starting_distances[p,q])#
				comp2 <- new_distances[p,q] <= min_separation#
				if (comp1 != TRUE && comp2 == TRUE) {#
					collisions<-rbind(collisions,c(p,q))#
				}#
			}#
		}#
#
		#Matrix of euler poles and speeds for each individual continent for moving the animals later#
		organism_mover <- matrix(nrow=N_continents, ncol= 3)#
		for (clump in 1:length(tail(linked, n=1)[[1]])) {#
			which_conts <- as.numeric(strsplit(tail(linked, n=1)[[1]][[clump]], "&")[[1]])#
			organism_mover[which_conts,1] <- rep(euler_pole_longitudes[clump],length(which_conts))#
			organism_mover[which_conts,2] <- rep(euler_pole_latitudes[clump],length(which_conts))#
			#This bit will get overwritten if there are collisions#
			organism_mover[which_conts,3] <- rep(degrees_per_step[clump],length(which_conts))#
		}#
		perm_collisions <- matrix(nrow=0, ncol=2)#
#
		# Moving continents back if there has only been one collision#
		while(nrow(collisions) > 0) {#
#
			# Set up vector to store proportional changes after collisions#
			proportion <- vector()#
#
			# Find out proportions to reduce to for all potential collisions#
			for (coll in 1:nrow(collisions)) {#
				cont_1 <- collisions[coll,1]#
				cont_2 <- collisions[coll,2]#
				where_1 <- which_supercontinent(cont_1, tail(linked, n=1)[[1]])#
				where_2 <- which_supercontinent(cont_2, tail(linked, n=1)[[1]])#
				continent_1_euler_longitude = euler_pole_longitudes[where_1]#
				continent_1_euler_latitude = euler_pole_latitudes[where_1]#
				continent_2_euler_longitude = euler_pole_longitudes[where_2]#
				continent_2_euler_latitude = euler_pole_latitudes[where_2]#
				continent_1_degrees_per_step = degrees_per_step[where_1]#
				continent_2_degrees_per_step = degrees_per_step[where_2]#
				proportion[coll] <- ColliderReverser(min_separation, position[cont_1, t-1, 1], position[cont_1, t-1, 2], temp_position[cont_1,1], temp_position[cont_1,2], position[cont_2, t-1, 1], position[cont_2, t-1, 2], temp_position[cont_2,1], temp_position[cont_2,2], continent_1_euler_longitude, continent_1_euler_latitude, continent_2_euler_longitude, continent_2_euler_latitude, continent_1_degrees_per_step, continent_2_degrees_per_step, EarthRad = 6367.4447, Warn = FALSE)#
			}#
#
			# Select proportion to move for first collision#
			first_collision <- match(min(proportion),proportion)#
#
			# Find the two continents that collided first#
			cont_involved <- sort(collisions[first_collision, ])#
#
			# Add to matrix of definite collisions that cannot be separated in the next step#
			perm_collisions <- rbind(perm_collisions, cont_involved)#
#
			# Move first clump back#
			head_of_collision_1 <- cont_involved[1]#
			where_1 <- which_supercontinent(head_of_collision_1, tail(linked, n=1)[[1]])#
#
			#Find the other continents that were attached to the collider#
			all_involved <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_1], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents in one of the clumps#
			for (rev in 1:length(all_involved)) {#
				cont_to_rev <- all_involved[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_1], lat2=euler_pole_latitudes[where_1], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], start_long, start_lat)#
#
				#degrees to add#
				addition <- proportion[first_collision] * degrees_per_step[where_1]#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <- (init_bearing + addition) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
#
				organism_mover[cont_to_rev,3] <- addition#
			}#
#
			#Move the second clump back#
			head_of_collision_2 <- cont_involved[2]#
			where_2 <- which_supercontinent(head_of_collision_2, tail(linked, n=1)[[1]])#
			all_involved_2 <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_2], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents the other clump#
			for (rev in 1:length(all_involved_2)) {#
				cont_to_rev <- all_involved_2[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_2], lat2=euler_pole_latitudes[where_2], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], start_long, start_lat)#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <-  (init_bearing + (proportion[first_collision] * degrees_per_step[where_2])) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
			}#
#
			#Recalculate the new distances#
			new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
			comp1 <- vector()#
			comp2 <- vector()#
#
			# Check whether any other collisions have still occurred#
			collisions <- matrix(nrow=0, ncol=2)#
			for (q in 1:(N_continents - 1)) {#
				for (p in (q+1):N_continents) {#
					comp1 <- all.equal(new_distances[p, q], starting_distances[p, q])#
					comp2 <- new_distances[p, q] <= min_separation#
					if (comp1 != TRUE && comp2 == TRUE) {#
						# If collision has not already been recorded:#
						if(length(sort(match(paste(sort(c(q, p)), collapse=""), apply(perm_collisions, 1, paste, collapse="")))) == 0) {#
							# Record collision:#
							collisions <- rbind(collisions, c(p, q))#
						}#
					}#
				}#
			}#
		}#
#
		# When it finishes while loop can now 'ossify' the positions and move to selecting separations#
		position[, t, 1] <- temp_position[, 1]#
		position[, t, 2] <- temp_position[, 2]#
#
# Finding out if anything gets separated#
		# How many separate continents are there now? (after collisions may have occurred):#
		separate_continents <- HowManySeparateContinents(min_separation, position[,t,1], position[,t,2])#
		# Make random uniform draws for each continental cluster:#
		separation_draws <- runif(length(grep("&", separate_continents)))#
		# Case if a separation occurs (drawn value is equal to or exceeds stickiness):#
		if(any(separation_draws >= stickiness)) {#
			# Get clusters of continents to split apart:#
			clusters_to_split <- separate_continents[grep("&", separate_continents)][which(separation_draws >= stickiness)]#
			# For each cluster to split apart:#
			for(i in 1:length(clusters_to_split)) {#
				# Get numbers of continents involved:#
				cluster_continent_numbers <- sort(strsplit(clusters_to_split[i], "&")[[1]])#
				# Get longitudes of continents in cluster:#
				cluster_longitudes <- position[as.numeric(cluster_continent_numbers), t, 1]#
#
				# Get latitudes of continents in cluster:#
				cluster_latitudes <- position[as.numeric(cluster_continent_numbers), t, 2]#
				# Make protected links an empty matrix:#
				cluster_protected_links <- matrix(nrow = 0, ncol = 2)#
				# If there are recent collisions (that will potentially need to be excluded from new splits):#
				if(length(perm_collisions) > 0) {#
					# For each new collision:#
					for(j in 1:nrow(perm_collisions)) {#
						# If new collision occurs within the cluster:#
						if(length(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers)) == 2) {#
							# Add new collision to protected links list:#
							cluster_protected_links <- rbind(cluster_protected_links, perm_collisions[j, ])#
						}#
					}#
#
				}#
				# Get splits (new clusters) of separated cluster:#
				splits <- ContinentSplitter(min_separation, cluster_longitudes, cluster_latitudes, cluster_continent_numbers, cluster_protected_links, EarthRad)#
				# Update separate continents vector:#
				separate_continents <- sort(c(separate_continents[-match(clusters_to_split[i], separate_continents)], splits))#
			}#
		}#
#
# Now change the Euler poles and speeds#
		# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
		touching_continents <- HowManySeparateContinents((radius * 2), position[,t,1], position[,t,2])#
		if (paste(sort(touching_continents), collapse="") != paste(sort(tail(touching,n=1)[[1]]), collapse="")) {#
			touching <- c(touching, list(touching_continents))#
		}#
#
		# If the continental clustering has changed:#
		if (paste(sort(separate_continents), collapse="") != paste(sort(tail(linked,n=1)[[1]]), collapse="")) {#
			# Add new continental configuration to linked list#
			linked <- c(linked, list(separate_continents))#
#
			# Update time step for previous continental configuration:#
			names(linked)[(length(linked) - 1)] <- paste(strsplit(names(linked[(length(linked) - 1)]), ":")[[1]][1], ":", t - 1, sep="")#
			# Add time step to new continental configuration:#
			names(linked)[length(linked)] <- paste(t, ":", t, sep="")#
			# Select continents that are different to previous time step#
			toKeep <- c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]])[duplicated(c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]]))]#
#
			#Vectors for new poles and speeds#
			new_euler_latitudes <- rep(NA, length(separate_continents))#
			new_euler_longitudes <- rep(NA, length(separate_continents))#
			new_degrees_per_step <- rep(NA, length(separate_continents))#
#
			if (length(toKeep) != 0){#
				#Inherit previous poles and speeds for those clumps that remain the same#
				for (y in 1:length(toKeep)) {#
					new_euler_longitudes[match(toKeep[y],separate_continents)]<- euler_pole_longitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_euler_latitudes[match(toKeep[y],separate_continents)]<- euler_pole_latitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_degrees_per_step[match(toKeep[y],separate_continents)]<- degrees_per_step[match(toKeep[y],tail(linked, n=2)[[1]])]#
				}#
			}#
#
			# Make new Euler poles#
			new_euler_longitudes[is.na(new_euler_longitudes)]<- runif((length(separate_continents)-length(toKeep)), -180, 180)#
#
			changed_euler_latitudes<- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			while((sum(changed_euler_latitudes == 90) + sum(changed_euler_latitudes == -90)) > 0) changed_euler_latitudes <- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			new_euler_latitudes[is.na(new_euler_latitudes)] <- changed_euler_latitudes#
#
			# Get Great Circle distances from Euler pole to each continent centre:#
			for (l in 1:(length(separate_continents)-length(toKeep))) {#
				# Find the first NA to fill in:#
				changer <- match(NA, new_degrees_per_step)#
				#Find the contients that are in the clump whose speed is going to change#
				rows <- as.numeric(unlist(strsplit(separate_continents[changer], "&")))#
				#Find the new euler pole for that clump#
				euler_long <- new_euler_longitudes[changer]#
				euler_lat <- new_euler_latitudes[changer]#
				#Find the distances of each of the continents in the clump from their new euler pole#
				euler_GC_distances <- One2ManyGreatCircleDistance(euler_long, euler_lat, position[rows, t, 1], position[rows, t, 2])#
				#Find which of those is closest to the equator#
				furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
				# Randomly draw a continent speed:#
				continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# If a negative or zero speed is picked then redraw:#
				while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# Set degree change per step (effectively the speed):#
				new_degrees_per_step[changer] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
			}#
			euler_pole_longitudes <- new_euler_longitudes#
			euler_pole_latitudes <- new_euler_latitudes#
			degrees_per_step <- new_degrees_per_step#
		}#
#
#Need to add in the tree bit#
		#Move the animals with the continents#
		for (cont in 1:N_continents) {#
			#Find the rows that are in the continent of focus#
			moving <- which(rownames(organism_long_matrix)==cont)#
#
			if (length(moving)==0) {#
				next #
			} else {#
				#Find out how many degrees around the euler pole that continent went#
				organism_degrees <- organism_mover[cont,3]#
				#loops through all the organisms that are currently living#
				for (organism in 1:length(moving)) {#
					organism_row <- moving[organism]#
					if (is.na(organism_long_matrix[organism_row, ot + 1])) {#
						next#
					} else {#
						first_long <- organism_long_matrix[organism_row, ot + 1]#
						first_lat <- organism_lat_matrix[organism_row, ot + 1]#
						organism_distance <- GreatCircleDistanceFromLongLat(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						organism_bearing <- BearingBetweenTwoLongLatPoints(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						new_organism_bearing <- (organism_bearing + organism_degrees) %% 360#
						new_organism_loc <- EndPoint(organism_mover[cont,1], organism_mover[cont,2], new_organism_bearing, organism_distance)#
						organism_long_matrix[organism_row, ot + 1] <- new_organism_loc$long#
    					organism_lat_matrix[organism_row, ot + 1] <- new_organism_loc$lat#
					}#
				}#
			}#
		}#
		for (f in 1:organism_multiplier) {#
            if (sum(alive) == 0) stop("METEOR IMPACT!! EVERYTHING HAS GONE EXTINCT! AAAAHHHHHH!!!")#
            dt<-1#
            ot <- ot + dt#
            for (m in 1:nrow(organism_lat_matrix)) {#
                if (alive[m]) {#
                    starting<-c(organism_lat_matrix[m,ot],organism_long_matrix[m,ot])#
                    moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd))) #generates a random walk step and calculates new position#
                    on_cont <- as.numeric(rownames(organism_lat_matrix)[m])#
                    friends <- as.numeric(strsplit(tail(touching, n=1)[[1]][which_supercontinent(on_cont, tail(touching, n=1)[[1]])], "&")[[1]])#
                    dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    if (length(friends) > 1) {#
                    	all_dist <- vector(length = length(friends))#
                    	for (g in 1:length(friends)) {#
                    		all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    	}#
                    	while (min(all_dist) > radius) {#
                    		moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		temp_all_dist <- vector(length = length(friends))#
                    		for (g in 1:length(friends)) {#
                    			temp_all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    		}#
                    		all_dist <- temp_all_dist#
                    	}#
                    	new_cont <- friends[which(all_dist == min(all_dist))] #
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                    	rownames(organism_long_matrix)[m] <- new_cont#
                    	rownames(organism_lat_matrix)[m] <- new_cont#
                    	if(new_cont != on_cont) {#
                    		dispersals <- rbind(dispersals, c(on_cont, new_cont, m, t, ot+1))#
                    	}#
                    } else {#
                    	while (dist_from_center >= radius) {#
                    		moveto <- EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    	}#
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                	}#
                }#
            }#
#
            r <- runif(1)#
            if (r <= b/(b + d)) { ###4 #this creates a bifucation in the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                e <- matrix(edge[alive,], ncol = 2)#
                parent <- e[random_lineage,2]#
                x <- which(edge[,2] == parent)#
                new.rows.lat <- new.rows.long <- extra.rows#
                new.rows.lat[, ot+1] <- organism_lat_matrix[x, ot+1] #updates the long and lat matricies with new coordiantes for each lineage#
                new.rows.long[, ot+1] <- organism_long_matrix[x, ot+1]#
                rownames(new.rows.lat) <- rep(rownames(organism_lat_matrix)[x],2)#
                rownames(new.rows.long) <- rep(rownames(organism_long_matrix)[x],2)#
                organism_lat_matrix <- rbind(organism_lat_matrix,new.rows.lat)#
                organism_long_matrix <- rbind(organism_long_matrix,new.rows.long)#
                alive[alive][random_lineage] <- FALSE#
                edge <- rbind(edge, c(parent, next.node), c(parent, next.node + 1))#
                next.node <- next.node + 2#
                alive <- c(alive, TRUE, TRUE)#
                stem.depth <- c(stem.depth, ot, ot)#
                edge.length[x] <- ot - stem.depth[x]#
                edge.length<-c(edge.length, NA, NA)#
            } else {###4 This terminates one of the current lineages on the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                edge.length[alive][random_lineage] <- ot - stem.depth[alive][random_lineage]#
                alive[alive][random_lineage] <- FALSE#
            }###4#
        }#1A#
        if (any(progress == t)) {#
        	cat("- ")#
        }#
    }#
#
    #Things to do right at the end to turn it into a phylo object#
    edge.length[alive] <- ot - stem.depth[alive];#
    n <- -1#
    for (f in 1:max(edge)) {#
        if (any(edge[,1] == f)) {#
           	edge[which(edge[,1] == f), 1] <- n#
           	edge[which(edge[,2] == f), 2] <- n#
           	n <- n - 1;#
        }#
    }#
    edge[edge > 0] <- 1:sum(edge > 0)#
   	tip.label <- 1:sum(edge > 0)#
    mode(edge) <- "character"#
    mode(tip.label) <- "character"#
    obj <- list(edge = edge, edge.length = edge.length, tip.label=tip.label)#
    class(obj) <- "phylo"#
    obj <- old2new.phylo(obj)#
    obj$tip.label = paste("s", 1:Ntip(obj), sep = "")#
	# Add final time step to continental configurations:#
	names(linked)[length(linked)] <- paste(strsplit(names(linked)[length(linked)], ":")[[1]][1], ":", t, sep="")#
	output <- list(position, linked, touching, obj, organism_long_matrix, organism_lat_matrix)#
	names(output) <- c("continent_positions", "continent_clusters", "continent_overlaps", "tree", "organism_longitudes", "organism_latitudes")
try<-output
plot(try$organism_longitudes[1,], try$organism_latitudes[1,], xlim=c(-180, 180), ylim=c(-90, 90), type = "l")
for (i in 1:nrow(try$organism_longitudes))   lines(try$organism_longitudes[i,], try$organism_latitudes[i,])
for(i in 1:N_continents) points(try$continent_positions[i,,1], try$continent_positions[i,,2], col=rainbow(N_steps))
touching
N_steps = 500; organism_multiplier = 1; N_continents = 7; radius = 2000; start_configuration = "supercontinent"; squishiness = 0.25; stickiness = 0.95; continent_speed_mean = 5; continent_speed_sd = 2; organism_step_sd = 200; b = 0.1; d = 0.05; EarthRad = 6367.4447; polar = FALSE
# Subfunction to find out which supercontinent a circle belongs to:#
	which_supercontinent <- function(cont, sprconts){#
		cont <- as.character(cont)#
		result <- which(unlist(lapply(lapply(lapply(strsplit(sprconts, "&"), match, cont), sort), length)) == 1)#
		return(result)#
	}#
	# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)#
# Are any continents joined at start?:#
#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
#
	# Get list of separate continents:#
	separate_continents <- HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
#
	# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
	touching_continents <- HowManySeparateContinents((radius * 2), continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
# Assign Euler poles to each separate continent:#
	# Randomly draw longitudes for each separated continent:#
	euler_pole_longitudes <- runif(length(separate_continents), -180, 180)#
	# Randomly draw latitudes for each separated continent:#
	euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
	# Ensure no latitude is directly at a pole (North or South) by redrawing if any are found:#
	if((sum(euler_pole_latitudes == 90) + sum(euler_pole_latitudes == -90)) > 0) euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
#
# Assign speeds to each separate continent:#
	# Create empty vector to store degrees per step (effectively the speed of movement) for each continent:#
	degrees_per_step <- vector(mode="numeric")#
	# For each separate continent:#
	for(i in 1:length(separate_continents)) {#
		# Get Greate Circle distances from Euler pole to each continent centre:#
		euler_GC_distances <- One2ManyGreatCircleDistance(euler_pole_longitudes[i], euler_pole_latitudes[i], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Longitude"], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Latitude"])#
		# Find GC distance to furthest continent (closest to euler pole "equator") in cluster (as speed will be assigned based on this):#
		furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
		# Randomly draw a continent speed:#
		continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# If a negative or zero speed is picked then redraw:#
		while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# Set degree change per step (effectively the speed):#
		degrees_per_step[i] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
	}#
#
	#starting information for the tree#
	dispersals <- matrix(nrow=0, ncol=5)#
	begin_cont <- ceiling(runif(1, 0, N_continents))#
	life_begins <- EndPoint(continent_starting_points[begin_cont, "Longitude"], continent_starting_points[begin_cont, "Latitude"], runif(1,0,360), runif(1,0,radius))#
	extra.rows <- matrix(NA,nrow=2,ncol= (N_steps * organism_multiplier) + 1)#
	organism_lat_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_long_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_lat_matrix[,1] <- life_begins$lat#
    organism_long_matrix[,1] <- life_begins$lon#
    rownames(organism_lat_matrix) <- rep(begin_cont, 2)#
    rownames(organism_long_matrix) <- rep(begin_cont, 2)#
    edge <- rbind(c(1, 2), c(1, 3)) # this is a starting edge matrix#
    edge.length <- rep(NA, 2)#
    stem.depth <- numeric(2)#
    alive <- rep(TRUE, 2) # marker for live lineages#
    ot <- 0; # time(step) at any point in the tree#
    next.node <- 4#
#
	# Now need to move them!#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	linked <- list()#
	linked[[1]] <- separate_continents#
	names(linked)[[1]] <- "1:1"#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	touching <- list()#
	touching[[1]] <- touching_continents#
#
	#Array to store the positions of every continent at each time step#
	position <- array(NA, c(N_continents, N_steps + 1, 2), c("continent", "timestep", "coordinate"))#
	position[,1,1] <- continent_starting_points[,"Longitude"]#
	position[,1,2] <- continent_starting_points[,"Latitude"]#
#
	temp_position<-matrix(nrow = N_continents, ncol=2)#
#
	progress <- seq(1, N_steps, floor(N_steps/50))#
	cat("Starting time steps \n")#
	cat("Progress \n")#
	cat("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n")#
#
	#for loops to move everything#
	for (t in 2:(N_steps + 1)) {#
		#distances apart before they move#
		starting_distances <- GreatCircleDistanceMatrix(position[,t-1,1], position[,t-1,2])#
#
		for (k in 1:N_continents) {#
			#find current longlat of the circle k#
			start_long <- position[k, t-1, 1]#
			start_lat <- position[k, t-1, 2]#
#
			#Identify which supercontinent, and therefore which element of the euler pole and speed vectors, the circle k belongs to#
			where <- which_supercontinent(k, tail(linked, n=1)[[1]])#
#
			#Find distance of circle from pole#
			distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where], lat2=euler_pole_latitudes[where], Warn = FALSE)#
			#Find bearing of circle from pole#
			init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where], euler_pole_latitudes[where], start_long, start_lat)#
#
			#Find the new bearing of circle from pole according to the speed specified#
			new_bearing <- (init_bearing + degrees_per_step[where]) %% 360#
#
			#Find the new location of the circle#
			new_loc <- EndPoint(euler_pole_longitudes[where], euler_pole_latitudes[where], new_bearing, distance)#
#
			#Add the new loction to the position matrix#
			temp_position[k,1] <- new_loc$long#
			temp_position[k,2] <- new_loc$lat#
#
		}#
#
		#Matrix of the distances between each continent in their new positions, before these are set#
		new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
		comp1 <- vector()#
		comp2 <- vector()#
#
		#Making a vector of whether any continents have collided and should be linked#
		collisions<-matrix(nrow=0, ncol=2)#
		for (q in 1:(N_continents-1)) {#
			for (p in (q+1):N_continents) {#
				comp1 <- all.equal(new_distances[p,q],starting_distances[p,q])#
				comp2 <- new_distances[p,q] <= min_separation#
				if (comp1 != TRUE && comp2 == TRUE) {#
					collisions<-rbind(collisions,c(p,q))#
				}#
			}#
		}#
#
		#Matrix of euler poles and speeds for each individual continent for moving the animals later#
		organism_mover <- matrix(nrow=N_continents, ncol= 3)#
		for (clump in 1:length(tail(linked, n=1)[[1]])) {#
			which_conts <- as.numeric(strsplit(tail(linked, n=1)[[1]][[clump]], "&")[[1]])#
			organism_mover[which_conts,1] <- rep(euler_pole_longitudes[clump],length(which_conts))#
			organism_mover[which_conts,2] <- rep(euler_pole_latitudes[clump],length(which_conts))#
			#This bit will get overwritten if there are collisions#
			organism_mover[which_conts,3] <- rep(degrees_per_step[clump],length(which_conts))#
		}#
		perm_collisions <- matrix(nrow=0, ncol=2)#
#
		# Moving continents back if there has only been one collision#
		while(nrow(collisions) > 0) {#
#
			# Set up vector to store proportional changes after collisions#
			proportion <- vector()#
#
			# Find out proportions to reduce to for all potential collisions#
			for (coll in 1:nrow(collisions)) {#
				cont_1 <- collisions[coll,1]#
				cont_2 <- collisions[coll,2]#
				where_1 <- which_supercontinent(cont_1, tail(linked, n=1)[[1]])#
				where_2 <- which_supercontinent(cont_2, tail(linked, n=1)[[1]])#
				continent_1_euler_longitude = euler_pole_longitudes[where_1]#
				continent_1_euler_latitude = euler_pole_latitudes[where_1]#
				continent_2_euler_longitude = euler_pole_longitudes[where_2]#
				continent_2_euler_latitude = euler_pole_latitudes[where_2]#
				continent_1_degrees_per_step = degrees_per_step[where_1]#
				continent_2_degrees_per_step = degrees_per_step[where_2]#
				proportion[coll] <- ColliderReverser(min_separation, position[cont_1, t-1, 1], position[cont_1, t-1, 2], temp_position[cont_1,1], temp_position[cont_1,2], position[cont_2, t-1, 1], position[cont_2, t-1, 2], temp_position[cont_2,1], temp_position[cont_2,2], continent_1_euler_longitude, continent_1_euler_latitude, continent_2_euler_longitude, continent_2_euler_latitude, continent_1_degrees_per_step, continent_2_degrees_per_step, EarthRad = 6367.4447, Warn = FALSE)#
			}#
#
			# Select proportion to move for first collision#
			first_collision <- match(min(proportion),proportion)#
#
			# Find the two continents that collided first#
			cont_involved <- sort(collisions[first_collision, ])#
#
			# Add to matrix of definite collisions that cannot be separated in the next step#
			perm_collisions <- rbind(perm_collisions, cont_involved)#
#
			# Move first clump back#
			head_of_collision_1 <- cont_involved[1]#
			where_1 <- which_supercontinent(head_of_collision_1, tail(linked, n=1)[[1]])#
#
			#Find the other continents that were attached to the collider#
			all_involved <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_1], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents in one of the clumps#
			for (rev in 1:length(all_involved)) {#
				cont_to_rev <- all_involved[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_1], lat2=euler_pole_latitudes[where_1], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], start_long, start_lat)#
#
				#degrees to add#
				addition <- proportion[first_collision] * degrees_per_step[where_1]#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <- (init_bearing + addition) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
#
				organism_mover[cont_to_rev,3] <- addition#
			}#
#
			#Move the second clump back#
			head_of_collision_2 <- cont_involved[2]#
			where_2 <- which_supercontinent(head_of_collision_2, tail(linked, n=1)[[1]])#
			all_involved_2 <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_2], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents the other clump#
			for (rev in 1:length(all_involved_2)) {#
				cont_to_rev <- all_involved_2[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_2], lat2=euler_pole_latitudes[where_2], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], start_long, start_lat)#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <-  (init_bearing + (proportion[first_collision] * degrees_per_step[where_2])) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
			}#
#
			#Recalculate the new distances#
			new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
			comp1 <- vector()#
			comp2 <- vector()#
#
			# Check whether any other collisions have still occurred#
			collisions <- matrix(nrow=0, ncol=2)#
			for (q in 1:(N_continents - 1)) {#
				for (p in (q+1):N_continents) {#
					comp1 <- all.equal(new_distances[p, q], starting_distances[p, q])#
					comp2 <- new_distances[p, q] <= min_separation#
					if (comp1 != TRUE && comp2 == TRUE) {#
						# If collision has not already been recorded:#
						if(length(sort(match(paste(sort(c(q, p)), collapse=""), apply(perm_collisions, 1, paste, collapse="")))) == 0) {#
							# Record collision:#
							collisions <- rbind(collisions, c(p, q))#
						}#
					}#
				}#
			}#
		}#
#
		# When it finishes while loop can now 'ossify' the positions and move to selecting separations#
		position[, t, 1] <- temp_position[, 1]#
		position[, t, 2] <- temp_position[, 2]#
#
# Finding out if anything gets separated#
		# How many separate continents are there now? (after collisions may have occurred):#
		separate_continents <- HowManySeparateContinents(min_separation, position[,t,1], position[,t,2])#
		# Make random uniform draws for each continental cluster:#
		separation_draws <- runif(length(grep("&", separate_continents)))#
		# Case if a separation occurs (drawn value is equal to or exceeds stickiness):#
		if(any(separation_draws >= stickiness)) {#
			# Get clusters of continents to split apart:#
			clusters_to_split <- separate_continents[grep("&", separate_continents)][which(separation_draws >= stickiness)]#
			# For each cluster to split apart:#
			for(i in 1:length(clusters_to_split)) {#
				# Get numbers of continents involved:#
				cluster_continent_numbers <- sort(strsplit(clusters_to_split[i], "&")[[1]])#
				# Get longitudes of continents in cluster:#
				cluster_longitudes <- position[as.numeric(cluster_continent_numbers), t, 1]#
#
				# Get latitudes of continents in cluster:#
				cluster_latitudes <- position[as.numeric(cluster_continent_numbers), t, 2]#
				# Make protected links an empty matrix:#
				cluster_protected_links <- matrix(nrow = 0, ncol = 2)#
				# If there are recent collisions (that will potentially need to be excluded from new splits):#
				if(length(perm_collisions) > 0) {#
					# For each new collision:#
					for(j in 1:nrow(perm_collisions)) {#
						# If new collision occurs within the cluster:#
						if(length(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers)) == 2) {#
							# Add new collision to protected links list:#
							cluster_protected_links <- rbind(cluster_protected_links, perm_collisions[j, ])#
						}#
					}#
#
				}#
				# Get splits (new clusters) of separated cluster:#
				splits <- ContinentSplitter(min_separation, cluster_longitudes, cluster_latitudes, cluster_continent_numbers, cluster_protected_links, EarthRad)#
				# Update separate continents vector:#
				separate_continents <- sort(c(separate_continents[-match(clusters_to_split[i], separate_continents)], splits))#
			}#
		}#
#
# Now change the Euler poles and speeds#
		# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
		touching_continents <- HowManySeparateContinents((radius * 2), position[,t,1], position[,t,2])#
		if (paste(sort(touching_continents), collapse="") != paste(sort(tail(touching,n=1)[[1]]), collapse="")) {#
			touching <- c(touching, list(touching_continents))#
		}#
#
		# If the continental clustering has changed:#
		if (paste(sort(separate_continents), collapse="") != paste(sort(tail(linked,n=1)[[1]]), collapse="")) {#
			# Add new continental configuration to linked list#
			linked <- c(linked, list(separate_continents))#
#
			# Update time step for previous continental configuration:#
			names(linked)[(length(linked) - 1)] <- paste(strsplit(names(linked[(length(linked) - 1)]), ":")[[1]][1], ":", t - 1, sep="")#
			# Add time step to new continental configuration:#
			names(linked)[length(linked)] <- paste(t, ":", t, sep="")#
			# Select continents that are different to previous time step#
			toKeep <- c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]])[duplicated(c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]]))]#
#
			#Vectors for new poles and speeds#
			new_euler_latitudes <- rep(NA, length(separate_continents))#
			new_euler_longitudes <- rep(NA, length(separate_continents))#
			new_degrees_per_step <- rep(NA, length(separate_continents))#
#
			if (length(toKeep) != 0){#
				#Inherit previous poles and speeds for those clumps that remain the same#
				for (y in 1:length(toKeep)) {#
					new_euler_longitudes[match(toKeep[y],separate_continents)]<- euler_pole_longitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_euler_latitudes[match(toKeep[y],separate_continents)]<- euler_pole_latitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_degrees_per_step[match(toKeep[y],separate_continents)]<- degrees_per_step[match(toKeep[y],tail(linked, n=2)[[1]])]#
				}#
			}#
#
			# Make new Euler poles#
			new_euler_longitudes[is.na(new_euler_longitudes)]<- runif((length(separate_continents)-length(toKeep)), -180, 180)#
#
			changed_euler_latitudes<- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			while((sum(changed_euler_latitudes == 90) + sum(changed_euler_latitudes == -90)) > 0) changed_euler_latitudes <- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			new_euler_latitudes[is.na(new_euler_latitudes)] <- changed_euler_latitudes#
#
			# Get Great Circle distances from Euler pole to each continent centre:#
			for (l in 1:(length(separate_continents)-length(toKeep))) {#
				# Find the first NA to fill in:#
				changer <- match(NA, new_degrees_per_step)#
				#Find the contients that are in the clump whose speed is going to change#
				rows <- as.numeric(unlist(strsplit(separate_continents[changer], "&")))#
				#Find the new euler pole for that clump#
				euler_long <- new_euler_longitudes[changer]#
				euler_lat <- new_euler_latitudes[changer]#
				#Find the distances of each of the continents in the clump from their new euler pole#
				euler_GC_distances <- One2ManyGreatCircleDistance(euler_long, euler_lat, position[rows, t, 1], position[rows, t, 2])#
				#Find which of those is closest to the equator#
				furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
				# Randomly draw a continent speed:#
				continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# If a negative or zero speed is picked then redraw:#
				while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# Set degree change per step (effectively the speed):#
				new_degrees_per_step[changer] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
			}#
			euler_pole_longitudes <- new_euler_longitudes#
			euler_pole_latitudes <- new_euler_latitudes#
			degrees_per_step <- new_degrees_per_step#
		}#
#
#Need to add in the tree bit#
		#Move the animals with the continents#
		for (cont in 1:N_continents) {#
			#Find the rows that are in the continent of focus#
			moving <- which(rownames(organism_long_matrix)==cont)#
#
			if (length(moving)==0) {#
				next #
			} else {#
				#Find out how many degrees around the euler pole that continent went#
				organism_degrees <- organism_mover[cont,3]#
				#loops through all the organisms that are currently living#
				for (organism in 1:length(moving)) {#
					organism_row <- moving[organism]#
					if (is.na(organism_long_matrix[organism_row, ot + 1])) {#
						next#
					} else {#
						first_long <- organism_long_matrix[organism_row, ot + 1]#
						first_lat <- organism_lat_matrix[organism_row, ot + 1]#
						organism_distance <- GreatCircleDistanceFromLongLat(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						organism_bearing <- BearingBetweenTwoLongLatPoints(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						new_organism_bearing <- (organism_bearing + organism_degrees) %% 360#
						new_organism_loc <- EndPoint(organism_mover[cont,1], organism_mover[cont,2], new_organism_bearing, organism_distance)#
						organism_long_matrix[organism_row, ot + 1] <- new_organism_loc$long#
    					organism_lat_matrix[organism_row, ot + 1] <- new_organism_loc$lat#
					}#
				}#
			}#
		}#
		for (f in 1:organism_multiplier) {#
            if (sum(alive) == 0) stop("METEOR IMPACT!! EVERYTHING HAS GONE EXTINCT! AAAAHHHHHH!!!")#
            dt<-1#
            ot <- ot + dt#
            for (m in 1:nrow(organism_lat_matrix)) {#
                if (alive[m]) {#
                    starting<-c(organism_lat_matrix[m,ot],organism_long_matrix[m,ot])#
                    moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd))) #generates a random walk step and calculates new position#
                    on_cont <- as.numeric(rownames(organism_lat_matrix)[m])#
                    friends <- as.numeric(strsplit(tail(touching, n=1)[[1]][which_supercontinent(on_cont, tail(touching, n=1)[[1]])], "&")[[1]])#
                    dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    if (length(friends) > 1) {#
                    	all_dist <- vector(length = length(friends))#
                    	for (g in 1:length(friends)) {#
                    		all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    	}#
                    	while (min(all_dist) > radius) {#
                    		moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		temp_all_dist <- vector(length = length(friends))#
                    		for (g in 1:length(friends)) {#
                    			temp_all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    		}#
                    		all_dist <- temp_all_dist#
                    	}#
                    	new_cont <- friends[which(all_dist == min(all_dist))] #
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                    	rownames(organism_long_matrix)[m] <- new_cont#
                    	rownames(organism_lat_matrix)[m] <- new_cont#
                    	if(new_cont != on_cont) {#
                    		dispersals <- rbind(dispersals, c(on_cont, new_cont, m, t, ot+1))#
                    	}#
                    } else {#
                    	while (dist_from_center >= radius) {#
                    		moveto <- EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    	}#
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                	}#
                }#
            }#
#
            r <- runif(1)#
            if (r <= b/(b + d)) { ###4 #this creates a bifucation in the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                e <- matrix(edge[alive,], ncol = 2)#
                parent <- e[random_lineage,2]#
                x <- which(edge[,2] == parent)#
                new.rows.lat <- new.rows.long <- extra.rows#
                new.rows.lat[, ot+1] <- organism_lat_matrix[x, ot+1] #updates the long and lat matricies with new coordiantes for each lineage#
                new.rows.long[, ot+1] <- organism_long_matrix[x, ot+1]#
                rownames(new.rows.lat) <- rep(rownames(organism_lat_matrix)[x],2)#
                rownames(new.rows.long) <- rep(rownames(organism_long_matrix)[x],2)#
                organism_lat_matrix <- rbind(organism_lat_matrix,new.rows.lat)#
                organism_long_matrix <- rbind(organism_long_matrix,new.rows.long)#
                alive[alive][random_lineage] <- FALSE#
                edge <- rbind(edge, c(parent, next.node), c(parent, next.node + 1))#
                next.node <- next.node + 2#
                alive <- c(alive, TRUE, TRUE)#
                stem.depth <- c(stem.depth, ot, ot)#
                edge.length[x] <- ot - stem.depth[x]#
                edge.length<-c(edge.length, NA, NA)#
            } else {###4 This terminates one of the current lineages on the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                edge.length[alive][random_lineage] <- ot - stem.depth[alive][random_lineage]#
                alive[alive][random_lineage] <- FALSE#
            }###4#
        }#1A#
        if (any(progress == t)) {#
        	cat("- ")#
        }#
    }#
#
    #Things to do right at the end to turn it into a phylo object#
    edge.length[alive] <- ot - stem.depth[alive];#
    n <- -1#
    for (f in 1:max(edge)) {#
        if (any(edge[,1] == f)) {#
           	edge[which(edge[,1] == f), 1] <- n#
           	edge[which(edge[,2] == f), 2] <- n#
           	n <- n - 1;#
        }#
    }#
    edge[edge > 0] <- 1:sum(edge > 0)#
   	tip.label <- 1:sum(edge > 0)#
    mode(edge) <- "character"#
    mode(tip.label) <- "character"#
    obj <- list(edge = edge, edge.length = edge.length, tip.label=tip.label)#
    class(obj) <- "phylo"#
    obj <- old2new.phylo(obj)#
    obj$tip.label = paste("s", 1:Ntip(obj), sep = "")#
	# Add final time step to continental configurations:#
	names(linked)[length(linked)] <- paste(strsplit(names(linked)[length(linked)], ":")[[1]][1], ":", t, sep="")#
	output <- list(position, linked, touching, obj, organism_long_matrix, organism_lat_matrix)#
	names(output) <- c("continent_positions", "continent_clusters", "continent_overlaps", "tree", "organism_longitudes", "organism_latitudes")
# Subfunction to find out which supercontinent a circle belongs to:#
	which_supercontinent <- function(cont, sprconts){#
		cont <- as.character(cont)#
		result <- which(unlist(lapply(lapply(lapply(strsplit(sprconts, "&"), match, cont), sort), length)) == 1)#
		return(result)#
	}#
	# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)#
# Are any continents joined at start?:#
#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
#
	# Get list of separate continents:#
	separate_continents <- HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
#
	# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
	touching_continents <- HowManySeparateContinents((radius * 2), continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
# Assign Euler poles to each separate continent:#
	# Randomly draw longitudes for each separated continent:#
	euler_pole_longitudes <- runif(length(separate_continents), -180, 180)#
	# Randomly draw latitudes for each separated continent:#
	euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
	# Ensure no latitude is directly at a pole (North or South) by redrawing if any are found:#
	if((sum(euler_pole_latitudes == 90) + sum(euler_pole_latitudes == -90)) > 0) euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
#
# Assign speeds to each separate continent:#
	# Create empty vector to store degrees per step (effectively the speed of movement) for each continent:#
	degrees_per_step <- vector(mode="numeric")#
	# For each separate continent:#
	for(i in 1:length(separate_continents)) {#
		# Get Greate Circle distances from Euler pole to each continent centre:#
		euler_GC_distances <- One2ManyGreatCircleDistance(euler_pole_longitudes[i], euler_pole_latitudes[i], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Longitude"], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Latitude"])#
		# Find GC distance to furthest continent (closest to euler pole "equator") in cluster (as speed will be assigned based on this):#
		furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
		# Randomly draw a continent speed:#
		continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# If a negative or zero speed is picked then redraw:#
		while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# Set degree change per step (effectively the speed):#
		degrees_per_step[i] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
	}#
#
	#starting information for the tree#
	dispersals <- matrix(nrow=0, ncol=5)#
	begin_cont <- ceiling(runif(1, 0, N_continents))#
	life_begins <- EndPoint(continent_starting_points[begin_cont, "Longitude"], continent_starting_points[begin_cont, "Latitude"], runif(1,0,360), runif(1,0,radius))#
	extra.rows <- matrix(NA,nrow=2,ncol= (N_steps * organism_multiplier) + 1)#
	organism_lat_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_long_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_lat_matrix[,1] <- life_begins$lat#
    organism_long_matrix[,1] <- life_begins$lon#
    rownames(organism_lat_matrix) <- rep(begin_cont, 2)#
    rownames(organism_long_matrix) <- rep(begin_cont, 2)#
    edge <- rbind(c(1, 2), c(1, 3)) # this is a starting edge matrix#
    edge.length <- rep(NA, 2)#
    stem.depth <- numeric(2)#
    alive <- rep(TRUE, 2) # marker for live lineages#
    ot <- 0; # time(step) at any point in the tree#
    next.node <- 4#
#
	# Now need to move them!#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	linked <- list()#
	linked[[1]] <- separate_continents#
	names(linked)[[1]] <- "1:1"#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	touching <- list()#
	touching[[1]] <- touching_continents#
#
	#Array to store the positions of every continent at each time step#
	position <- array(NA, c(N_continents, N_steps + 1, 2), c("continent", "timestep", "coordinate"))#
	position[,1,1] <- continent_starting_points[,"Longitude"]#
	position[,1,2] <- continent_starting_points[,"Latitude"]#
#
	temp_position<-matrix(nrow = N_continents, ncol=2)#
#
	progress <- seq(1, N_steps, floor(N_steps/50))#
	cat("Starting time steps \n")#
	cat("Progress \n")#
	cat("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n")#
#
	#for loops to move everything#
	for (t in 2:(N_steps + 1)) {#
		#distances apart before they move#
		starting_distances <- GreatCircleDistanceMatrix(position[,t-1,1], position[,t-1,2])#
#
		for (k in 1:N_continents) {#
			#find current longlat of the circle k#
			start_long <- position[k, t-1, 1]#
			start_lat <- position[k, t-1, 2]#
#
			#Identify which supercontinent, and therefore which element of the euler pole and speed vectors, the circle k belongs to#
			where <- which_supercontinent(k, tail(linked, n=1)[[1]])#
#
			#Find distance of circle from pole#
			distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where], lat2=euler_pole_latitudes[where], Warn = FALSE)#
			#Find bearing of circle from pole#
			init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where], euler_pole_latitudes[where], start_long, start_lat)#
#
			#Find the new bearing of circle from pole according to the speed specified#
			new_bearing <- (init_bearing + degrees_per_step[where]) %% 360#
#
			#Find the new location of the circle#
			new_loc <- EndPoint(euler_pole_longitudes[where], euler_pole_latitudes[where], new_bearing, distance)#
#
			#Add the new loction to the position matrix#
			temp_position[k,1] <- new_loc$long#
			temp_position[k,2] <- new_loc$lat#
#
		}#
#
		#Matrix of the distances between each continent in their new positions, before these are set#
		new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
		comp1 <- vector()#
		comp2 <- vector()#
#
		#Making a vector of whether any continents have collided and should be linked#
		collisions<-matrix(nrow=0, ncol=2)#
		for (q in 1:(N_continents-1)) {#
			for (p in (q+1):N_continents) {#
				comp1 <- all.equal(new_distances[p,q],starting_distances[p,q])#
				comp2 <- new_distances[p,q] <= min_separation#
				if (comp1 != TRUE && comp2 == TRUE) {#
					collisions<-rbind(collisions,c(p,q))#
				}#
			}#
		}#
#
		#Matrix of euler poles and speeds for each individual continent for moving the animals later#
		organism_mover <- matrix(nrow=N_continents, ncol= 3)#
		for (clump in 1:length(tail(linked, n=1)[[1]])) {#
			which_conts <- as.numeric(strsplit(tail(linked, n=1)[[1]][[clump]], "&")[[1]])#
			organism_mover[which_conts,1] <- rep(euler_pole_longitudes[clump],length(which_conts))#
			organism_mover[which_conts,2] <- rep(euler_pole_latitudes[clump],length(which_conts))#
			#This bit will get overwritten if there are collisions#
			organism_mover[which_conts,3] <- rep(degrees_per_step[clump],length(which_conts))#
		}#
		perm_collisions <- matrix(nrow=0, ncol=2)#
#
		# Moving continents back if there has only been one collision#
		while(nrow(collisions) > 0) {#
#
			# Set up vector to store proportional changes after collisions#
			proportion <- vector()#
#
			# Find out proportions to reduce to for all potential collisions#
			for (coll in 1:nrow(collisions)) {#
				cont_1 <- collisions[coll,1]#
				cont_2 <- collisions[coll,2]#
				where_1 <- which_supercontinent(cont_1, tail(linked, n=1)[[1]])#
				where_2 <- which_supercontinent(cont_2, tail(linked, n=1)[[1]])#
				continent_1_euler_longitude = euler_pole_longitudes[where_1]#
				continent_1_euler_latitude = euler_pole_latitudes[where_1]#
				continent_2_euler_longitude = euler_pole_longitudes[where_2]#
				continent_2_euler_latitude = euler_pole_latitudes[where_2]#
				continent_1_degrees_per_step = degrees_per_step[where_1]#
				continent_2_degrees_per_step = degrees_per_step[where_2]#
				proportion[coll] <- ColliderReverser(min_separation, position[cont_1, t-1, 1], position[cont_1, t-1, 2], temp_position[cont_1,1], temp_position[cont_1,2], position[cont_2, t-1, 1], position[cont_2, t-1, 2], temp_position[cont_2,1], temp_position[cont_2,2], continent_1_euler_longitude, continent_1_euler_latitude, continent_2_euler_longitude, continent_2_euler_latitude, continent_1_degrees_per_step, continent_2_degrees_per_step, EarthRad = 6367.4447, Warn = FALSE)#
			}#
#
			# Select proportion to move for first collision#
			first_collision <- match(min(proportion),proportion)#
#
			# Find the two continents that collided first#
			cont_involved <- sort(collisions[first_collision, ])#
#
			# Add to matrix of definite collisions that cannot be separated in the next step#
			perm_collisions <- rbind(perm_collisions, cont_involved)#
#
			# Move first clump back#
			head_of_collision_1 <- cont_involved[1]#
			where_1 <- which_supercontinent(head_of_collision_1, tail(linked, n=1)[[1]])#
#
			#Find the other continents that were attached to the collider#
			all_involved <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_1], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents in one of the clumps#
			for (rev in 1:length(all_involved)) {#
				cont_to_rev <- all_involved[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_1], lat2=euler_pole_latitudes[where_1], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], start_long, start_lat)#
#
				#degrees to add#
				addition <- proportion[first_collision] * degrees_per_step[where_1]#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <- (init_bearing + addition) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
#
				organism_mover[cont_to_rev,3] <- addition#
			}#
#
			#Move the second clump back#
			head_of_collision_2 <- cont_involved[2]#
			where_2 <- which_supercontinent(head_of_collision_2, tail(linked, n=1)[[1]])#
			all_involved_2 <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_2], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents the other clump#
			for (rev in 1:length(all_involved_2)) {#
				cont_to_rev <- all_involved_2[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_2], lat2=euler_pole_latitudes[where_2], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], start_long, start_lat)#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <-  (init_bearing + (proportion[first_collision] * degrees_per_step[where_2])) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
			}#
#
			#Recalculate the new distances#
			new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
			comp1 <- vector()#
			comp2 <- vector()#
#
			# Check whether any other collisions have still occurred#
			collisions <- matrix(nrow=0, ncol=2)#
			for (q in 1:(N_continents - 1)) {#
				for (p in (q+1):N_continents) {#
					comp1 <- all.equal(new_distances[p, q], starting_distances[p, q])#
					comp2 <- new_distances[p, q] <= min_separation#
					if (comp1 != TRUE && comp2 == TRUE) {#
						# If collision has not already been recorded:#
						if(length(sort(match(paste(sort(c(q, p)), collapse=""), apply(perm_collisions, 1, paste, collapse="")))) == 0) {#
							# Record collision:#
							collisions <- rbind(collisions, c(p, q))#
						}#
					}#
				}#
			}#
		}#
#
		# When it finishes while loop can now 'ossify' the positions and move to selecting separations#
		position[, t, 1] <- temp_position[, 1]#
		position[, t, 2] <- temp_position[, 2]#
#
# Finding out if anything gets separated#
		# How many separate continents are there now? (after collisions may have occurred):#
		separate_continents <- HowManySeparateContinents(min_separation, position[,t,1], position[,t,2])#
		# Make random uniform draws for each continental cluster:#
		separation_draws <- runif(length(grep("&", separate_continents)))#
		# Case if a separation occurs (drawn value is equal to or exceeds stickiness):#
		if(any(separation_draws >= stickiness)) {#
			# Get clusters of continents to split apart:#
			clusters_to_split <- separate_continents[grep("&", separate_continents)][which(separation_draws >= stickiness)]#
			# For each cluster to split apart:#
			for(i in 1:length(clusters_to_split)) {#
				# Get numbers of continents involved:#
				cluster_continent_numbers <- sort(strsplit(clusters_to_split[i], "&")[[1]])#
				# Get longitudes of continents in cluster:#
				cluster_longitudes <- position[as.numeric(cluster_continent_numbers), t, 1]#
#
				# Get latitudes of continents in cluster:#
				cluster_latitudes <- position[as.numeric(cluster_continent_numbers), t, 2]#
				# Make protected links an empty matrix:#
				cluster_protected_links <- matrix(nrow = 0, ncol = 2)#
				# If there are recent collisions (that will potentially need to be excluded from new splits):#
				if(length(perm_collisions) > 0) {#
					# For each new collision:#
					for(j in 1:nrow(perm_collisions)) {#
						# If new collision occurs within the cluster:#
						if(length(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers)) == 2) {#
							# Add new collision to protected links list:#
							cluster_protected_links <- rbind(cluster_protected_links, perm_collisions[j, ])#
						}#
					}#
#
				}#
				# Get splits (new clusters) of separated cluster:#
				splits <- ContinentSplitter(min_separation, cluster_longitudes, cluster_latitudes, cluster_continent_numbers, cluster_protected_links, EarthRad)#
				# Update separate continents vector:#
				separate_continents <- sort(c(separate_continents[-match(clusters_to_split[i], separate_continents)], splits))#
			}#
		}#
#
# Now change the Euler poles and speeds#
		# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
		touching_continents <- HowManySeparateContinents((radius * 2), position[,t,1], position[,t,2])#
		if (paste(sort(touching_continents), collapse="") != paste(sort(tail(touching,n=1)[[1]]), collapse="")) {#
			touching <- c(touching, list(touching_continents))#
		}#
#
		# If the continental clustering has changed:#
		if (paste(sort(separate_continents), collapse="") != paste(sort(tail(linked,n=1)[[1]]), collapse="")) {#
			# Add new continental configuration to linked list#
			linked <- c(linked, list(separate_continents))#
#
			# Update time step for previous continental configuration:#
			names(linked)[(length(linked) - 1)] <- paste(strsplit(names(linked[(length(linked) - 1)]), ":")[[1]][1], ":", t - 1, sep="")#
			# Add time step to new continental configuration:#
			names(linked)[length(linked)] <- paste(t, ":", t, sep="")#
			# Select continents that are different to previous time step#
			toKeep <- c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]])[duplicated(c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]]))]#
#
			#Vectors for new poles and speeds#
			new_euler_latitudes <- rep(NA, length(separate_continents))#
			new_euler_longitudes <- rep(NA, length(separate_continents))#
			new_degrees_per_step <- rep(NA, length(separate_continents))#
#
			if (length(toKeep) != 0){#
				#Inherit previous poles and speeds for those clumps that remain the same#
				for (y in 1:length(toKeep)) {#
					new_euler_longitudes[match(toKeep[y],separate_continents)]<- euler_pole_longitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_euler_latitudes[match(toKeep[y],separate_continents)]<- euler_pole_latitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_degrees_per_step[match(toKeep[y],separate_continents)]<- degrees_per_step[match(toKeep[y],tail(linked, n=2)[[1]])]#
				}#
			}#
#
			# Make new Euler poles#
			new_euler_longitudes[is.na(new_euler_longitudes)]<- runif((length(separate_continents)-length(toKeep)), -180, 180)#
#
			changed_euler_latitudes<- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			while((sum(changed_euler_latitudes == 90) + sum(changed_euler_latitudes == -90)) > 0) changed_euler_latitudes <- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			new_euler_latitudes[is.na(new_euler_latitudes)] <- changed_euler_latitudes#
#
			# Get Great Circle distances from Euler pole to each continent centre:#
			for (l in 1:(length(separate_continents)-length(toKeep))) {#
				# Find the first NA to fill in:#
				changer <- match(NA, new_degrees_per_step)#
				#Find the contients that are in the clump whose speed is going to change#
				rows <- as.numeric(unlist(strsplit(separate_continents[changer], "&")))#
				#Find the new euler pole for that clump#
				euler_long <- new_euler_longitudes[changer]#
				euler_lat <- new_euler_latitudes[changer]#
				#Find the distances of each of the continents in the clump from their new euler pole#
				euler_GC_distances <- One2ManyGreatCircleDistance(euler_long, euler_lat, position[rows, t, 1], position[rows, t, 2])#
				#Find which of those is closest to the equator#
				furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
				# Randomly draw a continent speed:#
				continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# If a negative or zero speed is picked then redraw:#
				while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# Set degree change per step (effectively the speed):#
				new_degrees_per_step[changer] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
			}#
			euler_pole_longitudes <- new_euler_longitudes#
			euler_pole_latitudes <- new_euler_latitudes#
			degrees_per_step <- new_degrees_per_step#
		}#
#
#Need to add in the tree bit#
		#Move the animals with the continents#
		for (cont in 1:N_continents) {#
			#Find the rows that are in the continent of focus#
			moving <- which(rownames(organism_long_matrix)==cont)#
#
			if (length(moving)==0) {#
				next #
			} else {#
				#Find out how many degrees around the euler pole that continent went#
				organism_degrees <- organism_mover[cont,3]#
				#loops through all the organisms that are currently living#
				for (organism in 1:length(moving)) {#
					organism_row <- moving[organism]#
					if (is.na(organism_long_matrix[organism_row, ot + 1])) {#
						next#
					} else {#
						first_long <- organism_long_matrix[organism_row, ot + 1]#
						first_lat <- organism_lat_matrix[organism_row, ot + 1]#
						organism_distance <- GreatCircleDistanceFromLongLat(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						organism_bearing <- BearingBetweenTwoLongLatPoints(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						new_organism_bearing <- (organism_bearing + organism_degrees) %% 360#
						new_organism_loc <- EndPoint(organism_mover[cont,1], organism_mover[cont,2], new_organism_bearing, organism_distance)#
						organism_long_matrix[organism_row, ot + 1] <- new_organism_loc$long#
    					organism_lat_matrix[organism_row, ot + 1] <- new_organism_loc$lat#
					}#
				}#
			}#
		}#
		for (f in 1:organism_multiplier) {#
            if (sum(alive) == 0) stop("METEOR IMPACT!! EVERYTHING HAS GONE EXTINCT! AAAAHHHHHH!!!")#
            dt<-1#
            ot <- ot + dt#
            for (m in 1:nrow(organism_lat_matrix)) {#
                if (alive[m]) {#
                    starting<-c(organism_lat_matrix[m,ot],organism_long_matrix[m,ot])#
                    moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd))) #generates a random walk step and calculates new position#
                    on_cont <- as.numeric(rownames(organism_lat_matrix)[m])#
                    friends <- as.numeric(strsplit(tail(touching, n=1)[[1]][which_supercontinent(on_cont, tail(touching, n=1)[[1]])], "&")[[1]])#
                    dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    if (length(friends) > 1) {#
                    	all_dist <- vector(length = length(friends))#
                    	for (g in 1:length(friends)) {#
                    		all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    	}#
                    	while (min(all_dist) > radius) {#
                    		moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		temp_all_dist <- vector(length = length(friends))#
                    		for (g in 1:length(friends)) {#
                    			temp_all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    		}#
                    		all_dist <- temp_all_dist#
                    	}#
                    	new_cont <- friends[which(all_dist == min(all_dist))] #
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                    	rownames(organism_long_matrix)[m] <- new_cont#
                    	rownames(organism_lat_matrix)[m] <- new_cont#
                    	if(new_cont != on_cont) {#
                    		dispersals <- rbind(dispersals, c(on_cont, new_cont, m, t, ot+1))#
                    	}#
                    } else {#
                    	while (dist_from_center >= radius) {#
                    		moveto <- EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    	}#
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                	}#
                }#
            }#
#
            r <- runif(1)#
            if (r <= b/(b + d)) { ###4 #this creates a bifucation in the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                e <- matrix(edge[alive,], ncol = 2)#
                parent <- e[random_lineage,2]#
                x <- which(edge[,2] == parent)#
                new.rows.lat <- new.rows.long <- extra.rows#
                new.rows.lat[, ot+1] <- organism_lat_matrix[x, ot+1] #updates the long and lat matricies with new coordiantes for each lineage#
                new.rows.long[, ot+1] <- organism_long_matrix[x, ot+1]#
                rownames(new.rows.lat) <- rep(rownames(organism_lat_matrix)[x],2)#
                rownames(new.rows.long) <- rep(rownames(organism_long_matrix)[x],2)#
                organism_lat_matrix <- rbind(organism_lat_matrix,new.rows.lat)#
                organism_long_matrix <- rbind(organism_long_matrix,new.rows.long)#
                alive[alive][random_lineage] <- FALSE#
                edge <- rbind(edge, c(parent, next.node), c(parent, next.node + 1))#
                next.node <- next.node + 2#
                alive <- c(alive, TRUE, TRUE)#
                stem.depth <- c(stem.depth, ot, ot)#
                edge.length[x] <- ot - stem.depth[x]#
                edge.length<-c(edge.length, NA, NA)#
            } else {###4 This terminates one of the current lineages on the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                edge.length[alive][random_lineage] <- ot - stem.depth[alive][random_lineage]#
                alive[alive][random_lineage] <- FALSE#
            }###4#
        }#1A#
        if (any(progress == t)) {#
        	cat("- ")#
        }#
    }#
#
    #Things to do right at the end to turn it into a phylo object#
    edge.length[alive] <- ot - stem.depth[alive];#
    n <- -1#
    for (f in 1:max(edge)) {#
        if (any(edge[,1] == f)) {#
           	edge[which(edge[,1] == f), 1] <- n#
           	edge[which(edge[,2] == f), 2] <- n#
           	n <- n - 1;#
        }#
    }#
    edge[edge > 0] <- 1:sum(edge > 0)#
   	tip.label <- 1:sum(edge > 0)#
    mode(edge) <- "character"#
    mode(tip.label) <- "character"#
    obj <- list(edge = edge, edge.length = edge.length, tip.label=tip.label)#
    class(obj) <- "phylo"#
    obj <- old2new.phylo(obj)#
    obj$tip.label = paste("s", 1:Ntip(obj), sep = "")#
	# Add final time step to continental configurations:#
	names(linked)[length(linked)] <- paste(strsplit(names(linked)[length(linked)], ":")[[1]][1], ":", t, sep="")#
	output <- list(position, linked, touching, obj, organism_long_matrix, organism_lat_matrix)#
	names(output) <- c("continent_positions", "continent_clusters", "continent_overlaps", "tree", "organism_longitudes", "organism_latitudes")
# Subfunction to find out which supercontinent a circle belongs to:#
	which_supercontinent <- function(cont, sprconts){#
		cont <- as.character(cont)#
		result <- which(unlist(lapply(lapply(lapply(strsplit(sprconts, "&"), match, cont), sort), length)) == 1)#
		return(result)#
	}#
	# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)#
# Are any continents joined at start?:#
#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
#
	# Get list of separate continents:#
	separate_continents <- HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
#
	# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
	touching_continents <- HowManySeparateContinents((radius * 2), continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
# Assign Euler poles to each separate continent:#
	# Randomly draw longitudes for each separated continent:#
	euler_pole_longitudes <- runif(length(separate_continents), -180, 180)#
	# Randomly draw latitudes for each separated continent:#
	euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
	# Ensure no latitude is directly at a pole (North or South) by redrawing if any are found:#
	if((sum(euler_pole_latitudes == 90) + sum(euler_pole_latitudes == -90)) > 0) euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
#
# Assign speeds to each separate continent:#
	# Create empty vector to store degrees per step (effectively the speed of movement) for each continent:#
	degrees_per_step <- vector(mode="numeric")#
	# For each separate continent:#
	for(i in 1:length(separate_continents)) {#
		# Get Greate Circle distances from Euler pole to each continent centre:#
		euler_GC_distances <- One2ManyGreatCircleDistance(euler_pole_longitudes[i], euler_pole_latitudes[i], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Longitude"], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Latitude"])#
		# Find GC distance to furthest continent (closest to euler pole "equator") in cluster (as speed will be assigned based on this):#
		furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
		# Randomly draw a continent speed:#
		continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# If a negative or zero speed is picked then redraw:#
		while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# Set degree change per step (effectively the speed):#
		degrees_per_step[i] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
	}#
#
	#starting information for the tree#
	dispersals <- matrix(nrow=0, ncol=5)#
	begin_cont <- ceiling(runif(1, 0, N_continents))#
	life_begins <- EndPoint(continent_starting_points[begin_cont, "Longitude"], continent_starting_points[begin_cont, "Latitude"], runif(1,0,360), runif(1,0,radius))#
	extra.rows <- matrix(NA,nrow=2,ncol= (N_steps * organism_multiplier) + 1)#
	organism_lat_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_long_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_lat_matrix[,1] <- life_begins$lat#
    organism_long_matrix[,1] <- life_begins$lon#
    rownames(organism_lat_matrix) <- rep(begin_cont, 2)#
    rownames(organism_long_matrix) <- rep(begin_cont, 2)#
    edge <- rbind(c(1, 2), c(1, 3)) # this is a starting edge matrix#
    edge.length <- rep(NA, 2)#
    stem.depth <- numeric(2)#
    alive <- rep(TRUE, 2) # marker for live lineages#
    ot <- 0; # time(step) at any point in the tree#
    next.node <- 4#
#
	# Now need to move them!#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	linked <- list()#
	linked[[1]] <- separate_continents#
	names(linked)[[1]] <- "1:1"#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	touching <- list()#
	touching[[1]] <- touching_continents#
#
	#Array to store the positions of every continent at each time step#
	position <- array(NA, c(N_continents, N_steps + 1, 2), c("continent", "timestep", "coordinate"))#
	position[,1,1] <- continent_starting_points[,"Longitude"]#
	position[,1,2] <- continent_starting_points[,"Latitude"]#
#
	temp_position<-matrix(nrow = N_continents, ncol=2)#
#
	progress <- seq(1, N_steps, floor(N_steps/50))#
	cat("Starting time steps \n")#
	cat("Progress \n")#
	cat("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n")#
#
	#for loops to move everything#
	for (t in 2:(N_steps + 1)) {#
		#distances apart before they move#
		starting_distances <- GreatCircleDistanceMatrix(position[,t-1,1], position[,t-1,2])#
#
		for (k in 1:N_continents) {#
			#find current longlat of the circle k#
			start_long <- position[k, t-1, 1]#
			start_lat <- position[k, t-1, 2]#
#
			#Identify which supercontinent, and therefore which element of the euler pole and speed vectors, the circle k belongs to#
			where <- which_supercontinent(k, tail(linked, n=1)[[1]])#
#
			#Find distance of circle from pole#
			distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where], lat2=euler_pole_latitudes[where], Warn = FALSE)#
			#Find bearing of circle from pole#
			init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where], euler_pole_latitudes[where], start_long, start_lat)#
#
			#Find the new bearing of circle from pole according to the speed specified#
			new_bearing <- (init_bearing + degrees_per_step[where]) %% 360#
#
			#Find the new location of the circle#
			new_loc <- EndPoint(euler_pole_longitudes[where], euler_pole_latitudes[where], new_bearing, distance)#
#
			#Add the new loction to the position matrix#
			temp_position[k,1] <- new_loc$long#
			temp_position[k,2] <- new_loc$lat#
#
		}#
#
		#Matrix of the distances between each continent in their new positions, before these are set#
		new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
		comp1 <- vector()#
		comp2 <- vector()#
#
		#Making a vector of whether any continents have collided and should be linked#
		collisions<-matrix(nrow=0, ncol=2)#
		for (q in 1:(N_continents-1)) {#
			for (p in (q+1):N_continents) {#
				comp1 <- all.equal(new_distances[p,q],starting_distances[p,q])#
				comp2 <- new_distances[p,q] <= min_separation#
				if (comp1 != TRUE && comp2 == TRUE) {#
					collisions<-rbind(collisions,c(p,q))#
				}#
			}#
		}#
#
		#Matrix of euler poles and speeds for each individual continent for moving the animals later#
		organism_mover <- matrix(nrow=N_continents, ncol= 3)#
		for (clump in 1:length(tail(linked, n=1)[[1]])) {#
			which_conts <- as.numeric(strsplit(tail(linked, n=1)[[1]][[clump]], "&")[[1]])#
			organism_mover[which_conts,1] <- rep(euler_pole_longitudes[clump],length(which_conts))#
			organism_mover[which_conts,2] <- rep(euler_pole_latitudes[clump],length(which_conts))#
			#This bit will get overwritten if there are collisions#
			organism_mover[which_conts,3] <- rep(degrees_per_step[clump],length(which_conts))#
		}#
		perm_collisions <- matrix(nrow=0, ncol=2)#
#
		# Moving continents back if there has only been one collision#
		while(nrow(collisions) > 0) {#
#
			# Set up vector to store proportional changes after collisions#
			proportion <- vector()#
#
			# Find out proportions to reduce to for all potential collisions#
			for (coll in 1:nrow(collisions)) {#
				cont_1 <- collisions[coll,1]#
				cont_2 <- collisions[coll,2]#
				where_1 <- which_supercontinent(cont_1, tail(linked, n=1)[[1]])#
				where_2 <- which_supercontinent(cont_2, tail(linked, n=1)[[1]])#
				continent_1_euler_longitude = euler_pole_longitudes[where_1]#
				continent_1_euler_latitude = euler_pole_latitudes[where_1]#
				continent_2_euler_longitude = euler_pole_longitudes[where_2]#
				continent_2_euler_latitude = euler_pole_latitudes[where_2]#
				continent_1_degrees_per_step = degrees_per_step[where_1]#
				continent_2_degrees_per_step = degrees_per_step[where_2]#
				proportion[coll] <- ColliderReverser(min_separation, position[cont_1, t-1, 1], position[cont_1, t-1, 2], temp_position[cont_1,1], temp_position[cont_1,2], position[cont_2, t-1, 1], position[cont_2, t-1, 2], temp_position[cont_2,1], temp_position[cont_2,2], continent_1_euler_longitude, continent_1_euler_latitude, continent_2_euler_longitude, continent_2_euler_latitude, continent_1_degrees_per_step, continent_2_degrees_per_step, EarthRad = 6367.4447, Warn = FALSE)#
			}#
#
			# Select proportion to move for first collision#
			first_collision <- match(min(proportion),proportion)#
#
			# Find the two continents that collided first#
			cont_involved <- sort(collisions[first_collision, ])#
#
			# Add to matrix of definite collisions that cannot be separated in the next step#
			perm_collisions <- rbind(perm_collisions, cont_involved)#
#
			# Move first clump back#
			head_of_collision_1 <- cont_involved[1]#
			where_1 <- which_supercontinent(head_of_collision_1, tail(linked, n=1)[[1]])#
#
			#Find the other continents that were attached to the collider#
			all_involved <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_1], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents in one of the clumps#
			for (rev in 1:length(all_involved)) {#
				cont_to_rev <- all_involved[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_1], lat2=euler_pole_latitudes[where_1], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], start_long, start_lat)#
#
				#degrees to add#
				addition <- proportion[first_collision] * degrees_per_step[where_1]#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <- (init_bearing + addition) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
#
				organism_mover[cont_to_rev,3] <- addition#
			}#
#
			#Move the second clump back#
			head_of_collision_2 <- cont_involved[2]#
			where_2 <- which_supercontinent(head_of_collision_2, tail(linked, n=1)[[1]])#
			all_involved_2 <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_2], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents the other clump#
			for (rev in 1:length(all_involved_2)) {#
				cont_to_rev <- all_involved_2[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_2], lat2=euler_pole_latitudes[where_2], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], start_long, start_lat)#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <-  (init_bearing + (proportion[first_collision] * degrees_per_step[where_2])) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
			}#
#
			#Recalculate the new distances#
			new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
			comp1 <- vector()#
			comp2 <- vector()#
#
			# Check whether any other collisions have still occurred#
			collisions <- matrix(nrow=0, ncol=2)#
			for (q in 1:(N_continents - 1)) {#
				for (p in (q+1):N_continents) {#
					comp1 <- all.equal(new_distances[p, q], starting_distances[p, q])#
					comp2 <- new_distances[p, q] <= min_separation#
					if (comp1 != TRUE && comp2 == TRUE) {#
						# If collision has not already been recorded:#
						if(length(sort(match(paste(sort(c(q, p)), collapse=""), apply(perm_collisions, 1, paste, collapse="")))) == 0) {#
							# Record collision:#
							collisions <- rbind(collisions, c(p, q))#
						}#
					}#
				}#
			}#
		}#
#
		# When it finishes while loop can now 'ossify' the positions and move to selecting separations#
		position[, t, 1] <- temp_position[, 1]#
		position[, t, 2] <- temp_position[, 2]#
#
# Finding out if anything gets separated#
		# How many separate continents are there now? (after collisions may have occurred):#
		separate_continents <- HowManySeparateContinents(min_separation, position[,t,1], position[,t,2])#
		# Make random uniform draws for each continental cluster:#
		separation_draws <- runif(length(grep("&", separate_continents)))#
		# Case if a separation occurs (drawn value is equal to or exceeds stickiness):#
		if(any(separation_draws >= stickiness)) {#
			# Get clusters of continents to split apart:#
			clusters_to_split <- separate_continents[grep("&", separate_continents)][which(separation_draws >= stickiness)]#
			# For each cluster to split apart:#
			for(i in 1:length(clusters_to_split)) {#
				# Get numbers of continents involved:#
				cluster_continent_numbers <- sort(strsplit(clusters_to_split[i], "&")[[1]])#
				# Get longitudes of continents in cluster:#
				cluster_longitudes <- position[as.numeric(cluster_continent_numbers), t, 1]#
#
				# Get latitudes of continents in cluster:#
				cluster_latitudes <- position[as.numeric(cluster_continent_numbers), t, 2]#
				# Make protected links an empty matrix:#
				cluster_protected_links <- matrix(nrow = 0, ncol = 2)#
				# If there are recent collisions (that will potentially need to be excluded from new splits):#
				if(length(perm_collisions) > 0) {#
					# For each new collision:#
					for(j in 1:nrow(perm_collisions)) {#
						# If new collision occurs within the cluster:#
						if(length(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers)) == 2) {#
							# Add new collision to protected links list:#
							cluster_protected_links <- rbind(cluster_protected_links, perm_collisions[j, ])#
						}#
					}#
#
				}#
				# Get splits (new clusters) of separated cluster:#
				splits <- ContinentSplitter(min_separation, cluster_longitudes, cluster_latitudes, cluster_continent_numbers, cluster_protected_links, EarthRad)#
				# Update separate continents vector:#
				separate_continents <- sort(c(separate_continents[-match(clusters_to_split[i], separate_continents)], splits))#
			}#
		}#
#
# Now change the Euler poles and speeds#
		# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
		touching_continents <- HowManySeparateContinents((radius * 2), position[,t,1], position[,t,2])#
		if (paste(sort(touching_continents), collapse="") != paste(sort(tail(touching,n=1)[[1]]), collapse="")) {#
			touching <- c(touching, list(touching_continents))#
		}#
#
		# If the continental clustering has changed:#
		if (paste(sort(separate_continents), collapse="") != paste(sort(tail(linked,n=1)[[1]]), collapse="")) {#
			# Add new continental configuration to linked list#
			linked <- c(linked, list(separate_continents))#
#
			# Update time step for previous continental configuration:#
			names(linked)[(length(linked) - 1)] <- paste(strsplit(names(linked[(length(linked) - 1)]), ":")[[1]][1], ":", t - 1, sep="")#
			# Add time step to new continental configuration:#
			names(linked)[length(linked)] <- paste(t, ":", t, sep="")#
			# Select continents that are different to previous time step#
			toKeep <- c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]])[duplicated(c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]]))]#
#
			#Vectors for new poles and speeds#
			new_euler_latitudes <- rep(NA, length(separate_continents))#
			new_euler_longitudes <- rep(NA, length(separate_continents))#
			new_degrees_per_step <- rep(NA, length(separate_continents))#
#
			if (length(toKeep) != 0){#
				#Inherit previous poles and speeds for those clumps that remain the same#
				for (y in 1:length(toKeep)) {#
					new_euler_longitudes[match(toKeep[y],separate_continents)]<- euler_pole_longitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_euler_latitudes[match(toKeep[y],separate_continents)]<- euler_pole_latitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_degrees_per_step[match(toKeep[y],separate_continents)]<- degrees_per_step[match(toKeep[y],tail(linked, n=2)[[1]])]#
				}#
			}#
#
			# Make new Euler poles#
			new_euler_longitudes[is.na(new_euler_longitudes)]<- runif((length(separate_continents)-length(toKeep)), -180, 180)#
#
			changed_euler_latitudes<- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			while((sum(changed_euler_latitudes == 90) + sum(changed_euler_latitudes == -90)) > 0) changed_euler_latitudes <- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			new_euler_latitudes[is.na(new_euler_latitudes)] <- changed_euler_latitudes#
#
			# Get Great Circle distances from Euler pole to each continent centre:#
			for (l in 1:(length(separate_continents)-length(toKeep))) {#
				# Find the first NA to fill in:#
				changer <- match(NA, new_degrees_per_step)#
				#Find the contients that are in the clump whose speed is going to change#
				rows <- as.numeric(unlist(strsplit(separate_continents[changer], "&")))#
				#Find the new euler pole for that clump#
				euler_long <- new_euler_longitudes[changer]#
				euler_lat <- new_euler_latitudes[changer]#
				#Find the distances of each of the continents in the clump from their new euler pole#
				euler_GC_distances <- One2ManyGreatCircleDistance(euler_long, euler_lat, position[rows, t, 1], position[rows, t, 2])#
				#Find which of those is closest to the equator#
				furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
				# Randomly draw a continent speed:#
				continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# If a negative or zero speed is picked then redraw:#
				while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# Set degree change per step (effectively the speed):#
				new_degrees_per_step[changer] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
			}#
			euler_pole_longitudes <- new_euler_longitudes#
			euler_pole_latitudes <- new_euler_latitudes#
			degrees_per_step <- new_degrees_per_step#
		}#
#
#Need to add in the tree bit#
		#Move the animals with the continents#
		for (cont in 1:N_continents) {#
			#Find the rows that are in the continent of focus#
			moving <- which(rownames(organism_long_matrix)==cont)#
#
			if (length(moving)==0) {#
				next #
			} else {#
				#Find out how many degrees around the euler pole that continent went#
				organism_degrees <- organism_mover[cont,3]#
				#loops through all the organisms that are currently living#
				for (organism in 1:length(moving)) {#
					organism_row <- moving[organism]#
					if (is.na(organism_long_matrix[organism_row, ot + 1])) {#
						next#
					} else {#
						first_long <- organism_long_matrix[organism_row, ot + 1]#
						first_lat <- organism_lat_matrix[organism_row, ot + 1]#
						organism_distance <- GreatCircleDistanceFromLongLat(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						organism_bearing <- BearingBetweenTwoLongLatPoints(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						new_organism_bearing <- (organism_bearing + organism_degrees) %% 360#
						new_organism_loc <- EndPoint(organism_mover[cont,1], organism_mover[cont,2], new_organism_bearing, organism_distance)#
						organism_long_matrix[organism_row, ot + 1] <- new_organism_loc$long#
    					organism_lat_matrix[organism_row, ot + 1] <- new_organism_loc$lat#
					}#
				}#
			}#
		}#
		for (f in 1:organism_multiplier) {#
            if (sum(alive) == 0) stop("METEOR IMPACT!! EVERYTHING HAS GONE EXTINCT! AAAAHHHHHH!!!")#
            dt<-1#
            ot <- ot + dt#
            for (m in 1:nrow(organism_lat_matrix)) {#
                if (alive[m]) {#
                    starting<-c(organism_lat_matrix[m,ot],organism_long_matrix[m,ot])#
                    moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd))) #generates a random walk step and calculates new position#
                    on_cont <- as.numeric(rownames(organism_lat_matrix)[m])#
                    friends <- as.numeric(strsplit(tail(touching, n=1)[[1]][which_supercontinent(on_cont, tail(touching, n=1)[[1]])], "&")[[1]])#
                    dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    if (length(friends) > 1) {#
                    	all_dist <- vector(length = length(friends))#
                    	for (g in 1:length(friends)) {#
                    		all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    	}#
                    	while (min(all_dist) > radius) {#
                    		moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		temp_all_dist <- vector(length = length(friends))#
                    		for (g in 1:length(friends)) {#
                    			temp_all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    		}#
                    		all_dist <- temp_all_dist#
                    	}#
                    	new_cont <- friends[which(all_dist == min(all_dist))] #
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                    	rownames(organism_long_matrix)[m] <- new_cont#
                    	rownames(organism_lat_matrix)[m] <- new_cont#
                    	if(new_cont != on_cont) {#
                    		dispersals <- rbind(dispersals, c(on_cont, new_cont, m, t, ot+1))#
                    	}#
                    } else {#
                    	while (dist_from_center >= radius) {#
                    		moveto <- EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    	}#
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                	}#
                }#
            }#
#
            r <- runif(1)#
            if (r <= b/(b + d)) { ###4 #this creates a bifucation in the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                e <- matrix(edge[alive,], ncol = 2)#
                parent <- e[random_lineage,2]#
                x <- which(edge[,2] == parent)#
                new.rows.lat <- new.rows.long <- extra.rows#
                new.rows.lat[, ot+1] <- organism_lat_matrix[x, ot+1] #updates the long and lat matricies with new coordiantes for each lineage#
                new.rows.long[, ot+1] <- organism_long_matrix[x, ot+1]#
                rownames(new.rows.lat) <- rep(rownames(organism_lat_matrix)[x],2)#
                rownames(new.rows.long) <- rep(rownames(organism_long_matrix)[x],2)#
                organism_lat_matrix <- rbind(organism_lat_matrix,new.rows.lat)#
                organism_long_matrix <- rbind(organism_long_matrix,new.rows.long)#
                alive[alive][random_lineage] <- FALSE#
                edge <- rbind(edge, c(parent, next.node), c(parent, next.node + 1))#
                next.node <- next.node + 2#
                alive <- c(alive, TRUE, TRUE)#
                stem.depth <- c(stem.depth, ot, ot)#
                edge.length[x] <- ot - stem.depth[x]#
                edge.length<-c(edge.length, NA, NA)#
            } else {###4 This terminates one of the current lineages on the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                edge.length[alive][random_lineage] <- ot - stem.depth[alive][random_lineage]#
                alive[alive][random_lineage] <- FALSE#
            }###4#
        }#1A#
        if (any(progress == t)) {#
        	cat("- ")#
        }#
    }#
#
    #Things to do right at the end to turn it into a phylo object#
    edge.length[alive] <- ot - stem.depth[alive];#
    n <- -1#
    for (f in 1:max(edge)) {#
        if (any(edge[,1] == f)) {#
           	edge[which(edge[,1] == f), 1] <- n#
           	edge[which(edge[,2] == f), 2] <- n#
           	n <- n - 1;#
        }#
    }#
    edge[edge > 0] <- 1:sum(edge > 0)#
   	tip.label <- 1:sum(edge > 0)#
    mode(edge) <- "character"#
    mode(tip.label) <- "character"#
    obj <- list(edge = edge, edge.length = edge.length, tip.label=tip.label)#
    class(obj) <- "phylo"#
    obj <- old2new.phylo(obj)#
    obj$tip.label = paste("s", 1:Ntip(obj), sep = "")#
	# Add final time step to continental configurations:#
	names(linked)[length(linked)] <- paste(strsplit(names(linked)[length(linked)], ":")[[1]][1], ":", t, sep="")#
	output <- list(position, linked, touching, obj, organism_long_matrix, organism_lat_matrix)#
	names(output) <- c("continent_positions", "continent_clusters", "continent_overlaps", "tree", "organism_longitudes", "organism_latitudes")
# Subfunction to find out which supercontinent a circle belongs to:#
	which_supercontinent <- function(cont, sprconts){#
		cont <- as.character(cont)#
		result <- which(unlist(lapply(lapply(lapply(strsplit(sprconts, "&"), match, cont), sort), length)) == 1)#
		return(result)#
	}#
	# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)#
# Are any continents joined at start?:#
#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
#
	# Get list of separate continents:#
	separate_continents <- HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
#
	# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
	touching_continents <- HowManySeparateContinents((radius * 2), continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
# Assign Euler poles to each separate continent:#
	# Randomly draw longitudes for each separated continent:#
	euler_pole_longitudes <- runif(length(separate_continents), -180, 180)#
	# Randomly draw latitudes for each separated continent:#
	euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
	# Ensure no latitude is directly at a pole (North or South) by redrawing if any are found:#
	if((sum(euler_pole_latitudes == 90) + sum(euler_pole_latitudes == -90)) > 0) euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
#
# Assign speeds to each separate continent:#
	# Create empty vector to store degrees per step (effectively the speed of movement) for each continent:#
	degrees_per_step <- vector(mode="numeric")#
	# For each separate continent:#
	for(i in 1:length(separate_continents)) {#
		# Get Greate Circle distances from Euler pole to each continent centre:#
		euler_GC_distances <- One2ManyGreatCircleDistance(euler_pole_longitudes[i], euler_pole_latitudes[i], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Longitude"], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Latitude"])#
		# Find GC distance to furthest continent (closest to euler pole "equator") in cluster (as speed will be assigned based on this):#
		furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
		# Randomly draw a continent speed:#
		continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# If a negative or zero speed is picked then redraw:#
		while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# Set degree change per step (effectively the speed):#
		degrees_per_step[i] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
	}#
#
	#starting information for the tree#
	dispersals <- matrix(nrow=0, ncol=5)#
	begin_cont <- ceiling(runif(1, 0, N_continents))#
	life_begins <- EndPoint(continent_starting_points[begin_cont, "Longitude"], continent_starting_points[begin_cont, "Latitude"], runif(1,0,360), runif(1,0,radius))#
	extra.rows <- matrix(NA,nrow=2,ncol= (N_steps * organism_multiplier) + 1)#
	organism_lat_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_long_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_lat_matrix[,1] <- life_begins$lat#
    organism_long_matrix[,1] <- life_begins$lon#
    rownames(organism_lat_matrix) <- rep(begin_cont, 2)#
    rownames(organism_long_matrix) <- rep(begin_cont, 2)#
    edge <- rbind(c(1, 2), c(1, 3)) # this is a starting edge matrix#
    edge.length <- rep(NA, 2)#
    stem.depth <- numeric(2)#
    alive <- rep(TRUE, 2) # marker for live lineages#
    ot <- 0; # time(step) at any point in the tree#
    next.node <- 4#
#
	# Now need to move them!#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	linked <- list()#
	linked[[1]] <- separate_continents#
	names(linked)[[1]] <- "1:1"#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	touching <- list()#
	touching[[1]] <- touching_continents#
#
	#Array to store the positions of every continent at each time step#
	position <- array(NA, c(N_continents, N_steps + 1, 2), c("continent", "timestep", "coordinate"))#
	position[,1,1] <- continent_starting_points[,"Longitude"]#
	position[,1,2] <- continent_starting_points[,"Latitude"]#
#
	temp_position<-matrix(nrow = N_continents, ncol=2)#
#
	progress <- seq(1, N_steps, floor(N_steps/50))#
	cat("Starting time steps \n")#
	cat("Progress \n")#
	cat("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n")#
#
	#for loops to move everything#
	for (t in 2:(N_steps + 1)) {#
		#distances apart before they move#
		starting_distances <- GreatCircleDistanceMatrix(position[,t-1,1], position[,t-1,2])#
#
		for (k in 1:N_continents) {#
			#find current longlat of the circle k#
			start_long <- position[k, t-1, 1]#
			start_lat <- position[k, t-1, 2]#
#
			#Identify which supercontinent, and therefore which element of the euler pole and speed vectors, the circle k belongs to#
			where <- which_supercontinent(k, tail(linked, n=1)[[1]])#
#
			#Find distance of circle from pole#
			distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where], lat2=euler_pole_latitudes[where], Warn = FALSE)#
			#Find bearing of circle from pole#
			init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where], euler_pole_latitudes[where], start_long, start_lat)#
#
			#Find the new bearing of circle from pole according to the speed specified#
			new_bearing <- (init_bearing + degrees_per_step[where]) %% 360#
#
			#Find the new location of the circle#
			new_loc <- EndPoint(euler_pole_longitudes[where], euler_pole_latitudes[where], new_bearing, distance)#
#
			#Add the new loction to the position matrix#
			temp_position[k,1] <- new_loc$long#
			temp_position[k,2] <- new_loc$lat#
#
		}#
#
		#Matrix of the distances between each continent in their new positions, before these are set#
		new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
		comp1 <- vector()#
		comp2 <- vector()#
#
		#Making a vector of whether any continents have collided and should be linked#
		collisions<-matrix(nrow=0, ncol=2)#
		for (q in 1:(N_continents-1)) {#
			for (p in (q+1):N_continents) {#
				comp1 <- all.equal(new_distances[p,q],starting_distances[p,q])#
				comp2 <- new_distances[p,q] <= min_separation#
				if (comp1 != TRUE && comp2 == TRUE) {#
					collisions<-rbind(collisions,c(p,q))#
				}#
			}#
		}#
#
		#Matrix of euler poles and speeds for each individual continent for moving the animals later#
		organism_mover <- matrix(nrow=N_continents, ncol= 3)#
		for (clump in 1:length(tail(linked, n=1)[[1]])) {#
			which_conts <- as.numeric(strsplit(tail(linked, n=1)[[1]][[clump]], "&")[[1]])#
			organism_mover[which_conts,1] <- rep(euler_pole_longitudes[clump],length(which_conts))#
			organism_mover[which_conts,2] <- rep(euler_pole_latitudes[clump],length(which_conts))#
			#This bit will get overwritten if there are collisions#
			organism_mover[which_conts,3] <- rep(degrees_per_step[clump],length(which_conts))#
		}#
		perm_collisions <- matrix(nrow=0, ncol=2)#
#
		# Moving continents back if there has only been one collision#
		while(nrow(collisions) > 0) {#
#
			# Set up vector to store proportional changes after collisions#
			proportion <- vector()#
#
			# Find out proportions to reduce to for all potential collisions#
			for (coll in 1:nrow(collisions)) {#
				cont_1 <- collisions[coll,1]#
				cont_2 <- collisions[coll,2]#
				where_1 <- which_supercontinent(cont_1, tail(linked, n=1)[[1]])#
				where_2 <- which_supercontinent(cont_2, tail(linked, n=1)[[1]])#
				continent_1_euler_longitude = euler_pole_longitudes[where_1]#
				continent_1_euler_latitude = euler_pole_latitudes[where_1]#
				continent_2_euler_longitude = euler_pole_longitudes[where_2]#
				continent_2_euler_latitude = euler_pole_latitudes[where_2]#
				continent_1_degrees_per_step = degrees_per_step[where_1]#
				continent_2_degrees_per_step = degrees_per_step[where_2]#
				proportion[coll] <- ColliderReverser(min_separation, position[cont_1, t-1, 1], position[cont_1, t-1, 2], temp_position[cont_1,1], temp_position[cont_1,2], position[cont_2, t-1, 1], position[cont_2, t-1, 2], temp_position[cont_2,1], temp_position[cont_2,2], continent_1_euler_longitude, continent_1_euler_latitude, continent_2_euler_longitude, continent_2_euler_latitude, continent_1_degrees_per_step, continent_2_degrees_per_step, EarthRad = 6367.4447, Warn = FALSE)#
			}#
#
			# Select proportion to move for first collision#
			first_collision <- match(min(proportion),proportion)#
#
			# Find the two continents that collided first#
			cont_involved <- sort(collisions[first_collision, ])#
#
			# Add to matrix of definite collisions that cannot be separated in the next step#
			perm_collisions <- rbind(perm_collisions, cont_involved)#
#
			# Move first clump back#
			head_of_collision_1 <- cont_involved[1]#
			where_1 <- which_supercontinent(head_of_collision_1, tail(linked, n=1)[[1]])#
#
			#Find the other continents that were attached to the collider#
			all_involved <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_1], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents in one of the clumps#
			for (rev in 1:length(all_involved)) {#
				cont_to_rev <- all_involved[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_1], lat2=euler_pole_latitudes[where_1], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], start_long, start_lat)#
#
				#degrees to add#
				addition <- proportion[first_collision] * degrees_per_step[where_1]#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <- (init_bearing + addition) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
#
				organism_mover[cont_to_rev,3] <- addition#
			}#
#
			#Move the second clump back#
			head_of_collision_2 <- cont_involved[2]#
			where_2 <- which_supercontinent(head_of_collision_2, tail(linked, n=1)[[1]])#
			all_involved_2 <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_2], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents the other clump#
			for (rev in 1:length(all_involved_2)) {#
				cont_to_rev <- all_involved_2[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_2], lat2=euler_pole_latitudes[where_2], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], start_long, start_lat)#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <-  (init_bearing + (proportion[first_collision] * degrees_per_step[where_2])) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
			}#
#
			#Recalculate the new distances#
			new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
			comp1 <- vector()#
			comp2 <- vector()#
#
			# Check whether any other collisions have still occurred#
			collisions <- matrix(nrow=0, ncol=2)#
			for (q in 1:(N_continents - 1)) {#
				for (p in (q+1):N_continents) {#
					comp1 <- all.equal(new_distances[p, q], starting_distances[p, q])#
					comp2 <- new_distances[p, q] <= min_separation#
					if (comp1 != TRUE && comp2 == TRUE) {#
						# If collision has not already been recorded:#
						if(length(sort(match(paste(sort(c(q, p)), collapse=""), apply(perm_collisions, 1, paste, collapse="")))) == 0) {#
							# Record collision:#
							collisions <- rbind(collisions, c(p, q))#
						}#
					}#
				}#
			}#
		}#
#
		# When it finishes while loop can now 'ossify' the positions and move to selecting separations#
		position[, t, 1] <- temp_position[, 1]#
		position[, t, 2] <- temp_position[, 2]#
#
# Finding out if anything gets separated#
		# How many separate continents are there now? (after collisions may have occurred):#
		separate_continents <- HowManySeparateContinents(min_separation, position[,t,1], position[,t,2])#
		# Make random uniform draws for each continental cluster:#
		separation_draws <- runif(length(grep("&", separate_continents)))#
		# Case if a separation occurs (drawn value is equal to or exceeds stickiness):#
		if(any(separation_draws >= stickiness)) {#
			# Get clusters of continents to split apart:#
			clusters_to_split <- separate_continents[grep("&", separate_continents)][which(separation_draws >= stickiness)]#
			# For each cluster to split apart:#
			for(i in 1:length(clusters_to_split)) {#
				# Get numbers of continents involved:#
				cluster_continent_numbers <- sort(strsplit(clusters_to_split[i], "&")[[1]])#
				# Get longitudes of continents in cluster:#
				cluster_longitudes <- position[as.numeric(cluster_continent_numbers), t, 1]#
#
				# Get latitudes of continents in cluster:#
				cluster_latitudes <- position[as.numeric(cluster_continent_numbers), t, 2]#
				# Make protected links an empty matrix:#
				cluster_protected_links <- matrix(nrow = 0, ncol = 2)#
				# If there are recent collisions (that will potentially need to be excluded from new splits):#
				if(length(perm_collisions) > 0) {#
					# For each new collision:#
					for(j in 1:nrow(perm_collisions)) {#
						# If new collision occurs within the cluster:#
						if(length(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers)) == 2) {#
							# Add new collision to protected links list:#
							cluster_protected_links <- rbind(cluster_protected_links, perm_collisions[j, ])#
						}#
					}#
#
				}#
				# Get splits (new clusters) of separated cluster:#
				splits <- ContinentSplitter(min_separation, cluster_longitudes, cluster_latitudes, cluster_continent_numbers, cluster_protected_links, EarthRad)#
				# Update separate continents vector:#
				separate_continents <- sort(c(separate_continents[-match(clusters_to_split[i], separate_continents)], splits))#
			}#
		}#
#
# Now change the Euler poles and speeds#
		# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
		touching_continents <- HowManySeparateContinents((radius * 2), position[,t,1], position[,t,2])#
		if (paste(sort(touching_continents), collapse="") != paste(sort(tail(touching,n=1)[[1]]), collapse="")) {#
			touching <- c(touching, list(touching_continents))#
		}#
#
		# If the continental clustering has changed:#
		if (paste(sort(separate_continents), collapse="") != paste(sort(tail(linked,n=1)[[1]]), collapse="")) {#
			# Add new continental configuration to linked list#
			linked <- c(linked, list(separate_continents))#
#
			# Update time step for previous continental configuration:#
			names(linked)[(length(linked) - 1)] <- paste(strsplit(names(linked[(length(linked) - 1)]), ":")[[1]][1], ":", t - 1, sep="")#
			# Add time step to new continental configuration:#
			names(linked)[length(linked)] <- paste(t, ":", t, sep="")#
			# Select continents that are different to previous time step#
			toKeep <- c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]])[duplicated(c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]]))]#
#
			#Vectors for new poles and speeds#
			new_euler_latitudes <- rep(NA, length(separate_continents))#
			new_euler_longitudes <- rep(NA, length(separate_continents))#
			new_degrees_per_step <- rep(NA, length(separate_continents))#
#
			if (length(toKeep) != 0){#
				#Inherit previous poles and speeds for those clumps that remain the same#
				for (y in 1:length(toKeep)) {#
					new_euler_longitudes[match(toKeep[y],separate_continents)]<- euler_pole_longitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_euler_latitudes[match(toKeep[y],separate_continents)]<- euler_pole_latitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_degrees_per_step[match(toKeep[y],separate_continents)]<- degrees_per_step[match(toKeep[y],tail(linked, n=2)[[1]])]#
				}#
			}#
#
			# Make new Euler poles#
			new_euler_longitudes[is.na(new_euler_longitudes)]<- runif((length(separate_continents)-length(toKeep)), -180, 180)#
#
			changed_euler_latitudes<- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			while((sum(changed_euler_latitudes == 90) + sum(changed_euler_latitudes == -90)) > 0) changed_euler_latitudes <- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			new_euler_latitudes[is.na(new_euler_latitudes)] <- changed_euler_latitudes#
#
			# Get Great Circle distances from Euler pole to each continent centre:#
			for (l in 1:(length(separate_continents)-length(toKeep))) {#
				# Find the first NA to fill in:#
				changer <- match(NA, new_degrees_per_step)#
				#Find the contients that are in the clump whose speed is going to change#
				rows <- as.numeric(unlist(strsplit(separate_continents[changer], "&")))#
				#Find the new euler pole for that clump#
				euler_long <- new_euler_longitudes[changer]#
				euler_lat <- new_euler_latitudes[changer]#
				#Find the distances of each of the continents in the clump from their new euler pole#
				euler_GC_distances <- One2ManyGreatCircleDistance(euler_long, euler_lat, position[rows, t, 1], position[rows, t, 2])#
				#Find which of those is closest to the equator#
				furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
				# Randomly draw a continent speed:#
				continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# If a negative or zero speed is picked then redraw:#
				while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# Set degree change per step (effectively the speed):#
				new_degrees_per_step[changer] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
			}#
			euler_pole_longitudes <- new_euler_longitudes#
			euler_pole_latitudes <- new_euler_latitudes#
			degrees_per_step <- new_degrees_per_step#
		}#
#
#Need to add in the tree bit#
		#Move the animals with the continents#
		for (cont in 1:N_continents) {#
			#Find the rows that are in the continent of focus#
			moving <- which(rownames(organism_long_matrix)==cont)#
#
			if (length(moving)==0) {#
				next #
			} else {#
				#Find out how many degrees around the euler pole that continent went#
				organism_degrees <- organism_mover[cont,3]#
				#loops through all the organisms that are currently living#
				for (organism in 1:length(moving)) {#
					organism_row <- moving[organism]#
					if (is.na(organism_long_matrix[organism_row, ot + 1])) {#
						next#
					} else {#
						first_long <- organism_long_matrix[organism_row, ot + 1]#
						first_lat <- organism_lat_matrix[organism_row, ot + 1]#
						organism_distance <- GreatCircleDistanceFromLongLat(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						organism_bearing <- BearingBetweenTwoLongLatPoints(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						new_organism_bearing <- (organism_bearing + organism_degrees) %% 360#
						new_organism_loc <- EndPoint(organism_mover[cont,1], organism_mover[cont,2], new_organism_bearing, organism_distance)#
						organism_long_matrix[organism_row, ot + 1] <- new_organism_loc$long#
    					organism_lat_matrix[organism_row, ot + 1] <- new_organism_loc$lat#
					}#
				}#
			}#
		}#
		for (f in 1:organism_multiplier) {#
            if (sum(alive) == 0) stop("METEOR IMPACT!! EVERYTHING HAS GONE EXTINCT! AAAAHHHHHH!!!")#
            dt<-1#
            ot <- ot + dt#
            for (m in 1:nrow(organism_lat_matrix)) {#
                if (alive[m]) {#
                    starting<-c(organism_lat_matrix[m,ot],organism_long_matrix[m,ot])#
                    moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd))) #generates a random walk step and calculates new position#
                    on_cont <- as.numeric(rownames(organism_lat_matrix)[m])#
                    friends <- as.numeric(strsplit(tail(touching, n=1)[[1]][which_supercontinent(on_cont, tail(touching, n=1)[[1]])], "&")[[1]])#
                    dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    if (length(friends) > 1) {#
                    	all_dist <- vector(length = length(friends))#
                    	for (g in 1:length(friends)) {#
                    		all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    	}#
                    	while (min(all_dist) > radius) {#
                    		moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		temp_all_dist <- vector(length = length(friends))#
                    		for (g in 1:length(friends)) {#
                    			temp_all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    		}#
                    		all_dist <- temp_all_dist#
                    	}#
                    	new_cont <- friends[which(all_dist == min(all_dist))] #
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                    	rownames(organism_long_matrix)[m] <- new_cont#
                    	rownames(organism_lat_matrix)[m] <- new_cont#
                    	if(new_cont != on_cont) {#
                    		dispersals <- rbind(dispersals, c(on_cont, new_cont, m, t, ot+1))#
                    	}#
                    } else {#
                    	while (dist_from_center >= radius) {#
                    		moveto <- EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    	}#
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                	}#
                }#
            }#
#
            r <- runif(1)#
            if (r <= b/(b + d)) { ###4 #this creates a bifucation in the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                e <- matrix(edge[alive,], ncol = 2)#
                parent <- e[random_lineage,2]#
                x <- which(edge[,2] == parent)#
                new.rows.lat <- new.rows.long <- extra.rows#
                new.rows.lat[, ot+1] <- organism_lat_matrix[x, ot+1] #updates the long and lat matricies with new coordiantes for each lineage#
                new.rows.long[, ot+1] <- organism_long_matrix[x, ot+1]#
                rownames(new.rows.lat) <- rep(rownames(organism_lat_matrix)[x],2)#
                rownames(new.rows.long) <- rep(rownames(organism_long_matrix)[x],2)#
                organism_lat_matrix <- rbind(organism_lat_matrix,new.rows.lat)#
                organism_long_matrix <- rbind(organism_long_matrix,new.rows.long)#
                alive[alive][random_lineage] <- FALSE#
                edge <- rbind(edge, c(parent, next.node), c(parent, next.node + 1))#
                next.node <- next.node + 2#
                alive <- c(alive, TRUE, TRUE)#
                stem.depth <- c(stem.depth, ot, ot)#
                edge.length[x] <- ot - stem.depth[x]#
                edge.length<-c(edge.length, NA, NA)#
            } else {###4 This terminates one of the current lineages on the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                edge.length[alive][random_lineage] <- ot - stem.depth[alive][random_lineage]#
                alive[alive][random_lineage] <- FALSE#
            }###4#
        }#1A#
        if (any(progress == t)) {#
        	cat("- ")#
        }#
    }#
#
    #Things to do right at the end to turn it into a phylo object#
    edge.length[alive] <- ot - stem.depth[alive];#
    n <- -1#
    for (f in 1:max(edge)) {#
        if (any(edge[,1] == f)) {#
           	edge[which(edge[,1] == f), 1] <- n#
           	edge[which(edge[,2] == f), 2] <- n#
           	n <- n - 1;#
        }#
    }#
    edge[edge > 0] <- 1:sum(edge > 0)#
   	tip.label <- 1:sum(edge > 0)#
    mode(edge) <- "character"#
    mode(tip.label) <- "character"#
    obj <- list(edge = edge, edge.length = edge.length, tip.label=tip.label)#
    class(obj) <- "phylo"#
    obj <- old2new.phylo(obj)#
    obj$tip.label = paste("s", 1:Ntip(obj), sep = "")#
	# Add final time step to continental configurations:#
	names(linked)[length(linked)] <- paste(strsplit(names(linked)[length(linked)], ":")[[1]][1], ":", t, sep="")#
	output <- list(position, linked, touching, obj, organism_long_matrix, organism_lat_matrix)#
	names(output) <- c("continent_positions", "continent_clusters", "continent_overlaps", "tree", "organism_longitudes", "organism_latitudes")
# Subfunction to find out which supercontinent a circle belongs to:#
	which_supercontinent <- function(cont, sprconts){#
		cont <- as.character(cont)#
		result <- which(unlist(lapply(lapply(lapply(strsplit(sprconts, "&"), match, cont), sort), length)) == 1)#
		return(result)#
	}#
	# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)#
# Are any continents joined at start?:#
#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
#
	# Get list of separate continents:#
	separate_continents <- HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
#
	# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
	touching_continents <- HowManySeparateContinents((radius * 2), continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
# Assign Euler poles to each separate continent:#
	# Randomly draw longitudes for each separated continent:#
	euler_pole_longitudes <- runif(length(separate_continents), -180, 180)#
	# Randomly draw latitudes for each separated continent:#
	euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
	# Ensure no latitude is directly at a pole (North or South) by redrawing if any are found:#
	if((sum(euler_pole_latitudes == 90) + sum(euler_pole_latitudes == -90)) > 0) euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
#
# Assign speeds to each separate continent:#
	# Create empty vector to store degrees per step (effectively the speed of movement) for each continent:#
	degrees_per_step <- vector(mode="numeric")#
	# For each separate continent:#
	for(i in 1:length(separate_continents)) {#
		# Get Greate Circle distances from Euler pole to each continent centre:#
		euler_GC_distances <- One2ManyGreatCircleDistance(euler_pole_longitudes[i], euler_pole_latitudes[i], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Longitude"], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Latitude"])#
		# Find GC distance to furthest continent (closest to euler pole "equator") in cluster (as speed will be assigned based on this):#
		furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
		# Randomly draw a continent speed:#
		continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# If a negative or zero speed is picked then redraw:#
		while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# Set degree change per step (effectively the speed):#
		degrees_per_step[i] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
	}#
#
	#starting information for the tree#
	dispersals <- matrix(nrow=0, ncol=5)#
	begin_cont <- ceiling(runif(1, 0, N_continents))#
	life_begins <- EndPoint(continent_starting_points[begin_cont, "Longitude"], continent_starting_points[begin_cont, "Latitude"], runif(1,0,360), runif(1,0,radius))#
	extra.rows <- matrix(NA,nrow=2,ncol= (N_steps * organism_multiplier) + 1)#
	organism_lat_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_long_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_lat_matrix[,1] <- life_begins$lat#
    organism_long_matrix[,1] <- life_begins$lon#
    rownames(organism_lat_matrix) <- rep(begin_cont, 2)#
    rownames(organism_long_matrix) <- rep(begin_cont, 2)#
    edge <- rbind(c(1, 2), c(1, 3)) # this is a starting edge matrix#
    edge.length <- rep(NA, 2)#
    stem.depth <- numeric(2)#
    alive <- rep(TRUE, 2) # marker for live lineages#
    ot <- 0; # time(step) at any point in the tree#
    next.node <- 4#
#
	# Now need to move them!#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	linked <- list()#
	linked[[1]] <- separate_continents#
	names(linked)[[1]] <- "1:1"#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	touching <- list()#
	touching[[1]] <- touching_continents#
#
	#Array to store the positions of every continent at each time step#
	position <- array(NA, c(N_continents, N_steps + 1, 2), c("continent", "timestep", "coordinate"))#
	position[,1,1] <- continent_starting_points[,"Longitude"]#
	position[,1,2] <- continent_starting_points[,"Latitude"]#
#
	temp_position<-matrix(nrow = N_continents, ncol=2)#
#
	progress <- seq(1, N_steps, floor(N_steps/50))#
	cat("Starting time steps \n")#
	cat("Progress \n")#
	cat("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n")#
#
	#for loops to move everything#
	for (t in 2:(N_steps + 1)) {#
		#distances apart before they move#
		starting_distances <- GreatCircleDistanceMatrix(position[,t-1,1], position[,t-1,2])#
#
		for (k in 1:N_continents) {#
			#find current longlat of the circle k#
			start_long <- position[k, t-1, 1]#
			start_lat <- position[k, t-1, 2]#
#
			#Identify which supercontinent, and therefore which element of the euler pole and speed vectors, the circle k belongs to#
			where <- which_supercontinent(k, tail(linked, n=1)[[1]])#
#
			#Find distance of circle from pole#
			distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where], lat2=euler_pole_latitudes[where], Warn = FALSE)#
			#Find bearing of circle from pole#
			init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where], euler_pole_latitudes[where], start_long, start_lat)#
#
			#Find the new bearing of circle from pole according to the speed specified#
			new_bearing <- (init_bearing + degrees_per_step[where]) %% 360#
#
			#Find the new location of the circle#
			new_loc <- EndPoint(euler_pole_longitudes[where], euler_pole_latitudes[where], new_bearing, distance)#
#
			#Add the new loction to the position matrix#
			temp_position[k,1] <- new_loc$long#
			temp_position[k,2] <- new_loc$lat#
#
		}#
#
		#Matrix of the distances between each continent in their new positions, before these are set#
		new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
		comp1 <- vector()#
		comp2 <- vector()#
#
		#Making a vector of whether any continents have collided and should be linked#
		collisions<-matrix(nrow=0, ncol=2)#
		for (q in 1:(N_continents-1)) {#
			for (p in (q+1):N_continents) {#
				comp1 <- all.equal(new_distances[p,q],starting_distances[p,q])#
				comp2 <- new_distances[p,q] <= min_separation#
				if (comp1 != TRUE && comp2 == TRUE) {#
					collisions<-rbind(collisions,c(p,q))#
				}#
			}#
		}#
#
		#Matrix of euler poles and speeds for each individual continent for moving the animals later#
		organism_mover <- matrix(nrow=N_continents, ncol= 3)#
		for (clump in 1:length(tail(linked, n=1)[[1]])) {#
			which_conts <- as.numeric(strsplit(tail(linked, n=1)[[1]][[clump]], "&")[[1]])#
			organism_mover[which_conts,1] <- rep(euler_pole_longitudes[clump],length(which_conts))#
			organism_mover[which_conts,2] <- rep(euler_pole_latitudes[clump],length(which_conts))#
			#This bit will get overwritten if there are collisions#
			organism_mover[which_conts,3] <- rep(degrees_per_step[clump],length(which_conts))#
		}#
		perm_collisions <- matrix(nrow=0, ncol=2)#
#
		# Moving continents back if there has only been one collision#
		while(nrow(collisions) > 0) {#
#
			# Set up vector to store proportional changes after collisions#
			proportion <- vector()#
#
			# Find out proportions to reduce to for all potential collisions#
			for (coll in 1:nrow(collisions)) {#
				cont_1 <- collisions[coll,1]#
				cont_2 <- collisions[coll,2]#
				where_1 <- which_supercontinent(cont_1, tail(linked, n=1)[[1]])#
				where_2 <- which_supercontinent(cont_2, tail(linked, n=1)[[1]])#
				continent_1_euler_longitude = euler_pole_longitudes[where_1]#
				continent_1_euler_latitude = euler_pole_latitudes[where_1]#
				continent_2_euler_longitude = euler_pole_longitudes[where_2]#
				continent_2_euler_latitude = euler_pole_latitudes[where_2]#
				continent_1_degrees_per_step = degrees_per_step[where_1]#
				continent_2_degrees_per_step = degrees_per_step[where_2]#
				proportion[coll] <- ColliderReverser(min_separation, position[cont_1, t-1, 1], position[cont_1, t-1, 2], temp_position[cont_1,1], temp_position[cont_1,2], position[cont_2, t-1, 1], position[cont_2, t-1, 2], temp_position[cont_2,1], temp_position[cont_2,2], continent_1_euler_longitude, continent_1_euler_latitude, continent_2_euler_longitude, continent_2_euler_latitude, continent_1_degrees_per_step, continent_2_degrees_per_step, EarthRad = 6367.4447, Warn = FALSE)#
			}#
#
			# Select proportion to move for first collision#
			first_collision <- match(min(proportion),proportion)#
#
			# Find the two continents that collided first#
			cont_involved <- sort(collisions[first_collision, ])#
#
			# Add to matrix of definite collisions that cannot be separated in the next step#
			perm_collisions <- rbind(perm_collisions, cont_involved)#
#
			# Move first clump back#
			head_of_collision_1 <- cont_involved[1]#
			where_1 <- which_supercontinent(head_of_collision_1, tail(linked, n=1)[[1]])#
#
			#Find the other continents that were attached to the collider#
			all_involved <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_1], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents in one of the clumps#
			for (rev in 1:length(all_involved)) {#
				cont_to_rev <- all_involved[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_1], lat2=euler_pole_latitudes[where_1], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], start_long, start_lat)#
#
				#degrees to add#
				addition <- proportion[first_collision] * degrees_per_step[where_1]#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <- (init_bearing + addition) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
#
				organism_mover[cont_to_rev,3] <- addition#
			}#
#
			#Move the second clump back#
			head_of_collision_2 <- cont_involved[2]#
			where_2 <- which_supercontinent(head_of_collision_2, tail(linked, n=1)[[1]])#
			all_involved_2 <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_2], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents the other clump#
			for (rev in 1:length(all_involved_2)) {#
				cont_to_rev <- all_involved_2[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_2], lat2=euler_pole_latitudes[where_2], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], start_long, start_lat)#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <-  (init_bearing + (proportion[first_collision] * degrees_per_step[where_2])) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
			}#
#
			#Recalculate the new distances#
			new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
			comp1 <- vector()#
			comp2 <- vector()#
#
			# Check whether any other collisions have still occurred#
			collisions <- matrix(nrow=0, ncol=2)#
			for (q in 1:(N_continents - 1)) {#
				for (p in (q+1):N_continents) {#
					comp1 <- all.equal(new_distances[p, q], starting_distances[p, q])#
					comp2 <- new_distances[p, q] <= min_separation#
					if (comp1 != TRUE && comp2 == TRUE) {#
						# If collision has not already been recorded:#
						if(length(sort(match(paste(sort(c(q, p)), collapse=""), apply(perm_collisions, 1, paste, collapse="")))) == 0) {#
							# Record collision:#
							collisions <- rbind(collisions, c(p, q))#
						}#
					}#
				}#
			}#
		}#
#
		# When it finishes while loop can now 'ossify' the positions and move to selecting separations#
		position[, t, 1] <- temp_position[, 1]#
		position[, t, 2] <- temp_position[, 2]#
#
# Finding out if anything gets separated#
		# How many separate continents are there now? (after collisions may have occurred):#
		separate_continents <- HowManySeparateContinents(min_separation, position[,t,1], position[,t,2])#
		# Make random uniform draws for each continental cluster:#
		separation_draws <- runif(length(grep("&", separate_continents)))#
		# Case if a separation occurs (drawn value is equal to or exceeds stickiness):#
		if(any(separation_draws >= stickiness)) {#
			# Get clusters of continents to split apart:#
			clusters_to_split <- separate_continents[grep("&", separate_continents)][which(separation_draws >= stickiness)]#
			# For each cluster to split apart:#
			for(i in 1:length(clusters_to_split)) {#
				# Get numbers of continents involved:#
				cluster_continent_numbers <- sort(strsplit(clusters_to_split[i], "&")[[1]])#
				# Get longitudes of continents in cluster:#
				cluster_longitudes <- position[as.numeric(cluster_continent_numbers), t, 1]#
#
				# Get latitudes of continents in cluster:#
				cluster_latitudes <- position[as.numeric(cluster_continent_numbers), t, 2]#
				# Make protected links an empty matrix:#
				cluster_protected_links <- matrix(nrow = 0, ncol = 2)#
				# If there are recent collisions (that will potentially need to be excluded from new splits):#
				if(length(perm_collisions) > 0) {#
					# For each new collision:#
					for(j in 1:nrow(perm_collisions)) {#
						# If new collision occurs within the cluster:#
						if(length(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers)) == 2) {#
							# Add new collision to protected links list:#
							cluster_protected_links <- rbind(cluster_protected_links, perm_collisions[j, ])#
						}#
					}#
#
				}#
				# Get splits (new clusters) of separated cluster:#
				splits <- ContinentSplitter(min_separation, cluster_longitudes, cluster_latitudes, cluster_continent_numbers, cluster_protected_links, EarthRad)#
				# Update separate continents vector:#
				separate_continents <- sort(c(separate_continents[-match(clusters_to_split[i], separate_continents)], splits))#
			}#
		}#
#
# Now change the Euler poles and speeds#
		# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
		touching_continents <- HowManySeparateContinents((radius * 2), position[,t,1], position[,t,2])#
		if (paste(sort(touching_continents), collapse="") != paste(sort(tail(touching,n=1)[[1]]), collapse="")) {#
			touching <- c(touching, list(touching_continents))#
		}#
#
		# If the continental clustering has changed:#
		if (paste(sort(separate_continents), collapse="") != paste(sort(tail(linked,n=1)[[1]]), collapse="")) {#
			# Add new continental configuration to linked list#
			linked <- c(linked, list(separate_continents))#
#
			# Update time step for previous continental configuration:#
			names(linked)[(length(linked) - 1)] <- paste(strsplit(names(linked[(length(linked) - 1)]), ":")[[1]][1], ":", t - 1, sep="")#
			# Add time step to new continental configuration:#
			names(linked)[length(linked)] <- paste(t, ":", t, sep="")#
			# Select continents that are different to previous time step#
			toKeep <- c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]])[duplicated(c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]]))]#
#
			#Vectors for new poles and speeds#
			new_euler_latitudes <- rep(NA, length(separate_continents))#
			new_euler_longitudes <- rep(NA, length(separate_continents))#
			new_degrees_per_step <- rep(NA, length(separate_continents))#
#
			if (length(toKeep) != 0){#
				#Inherit previous poles and speeds for those clumps that remain the same#
				for (y in 1:length(toKeep)) {#
					new_euler_longitudes[match(toKeep[y],separate_continents)]<- euler_pole_longitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_euler_latitudes[match(toKeep[y],separate_continents)]<- euler_pole_latitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_degrees_per_step[match(toKeep[y],separate_continents)]<- degrees_per_step[match(toKeep[y],tail(linked, n=2)[[1]])]#
				}#
			}#
#
			# Make new Euler poles#
			new_euler_longitudes[is.na(new_euler_longitudes)]<- runif((length(separate_continents)-length(toKeep)), -180, 180)#
#
			changed_euler_latitudes<- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			while((sum(changed_euler_latitudes == 90) + sum(changed_euler_latitudes == -90)) > 0) changed_euler_latitudes <- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			new_euler_latitudes[is.na(new_euler_latitudes)] <- changed_euler_latitudes#
#
			# Get Great Circle distances from Euler pole to each continent centre:#
			for (l in 1:(length(separate_continents)-length(toKeep))) {#
				# Find the first NA to fill in:#
				changer <- match(NA, new_degrees_per_step)#
				#Find the contients that are in the clump whose speed is going to change#
				rows <- as.numeric(unlist(strsplit(separate_continents[changer], "&")))#
				#Find the new euler pole for that clump#
				euler_long <- new_euler_longitudes[changer]#
				euler_lat <- new_euler_latitudes[changer]#
				#Find the distances of each of the continents in the clump from their new euler pole#
				euler_GC_distances <- One2ManyGreatCircleDistance(euler_long, euler_lat, position[rows, t, 1], position[rows, t, 2])#
				#Find which of those is closest to the equator#
				furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
				# Randomly draw a continent speed:#
				continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# If a negative or zero speed is picked then redraw:#
				while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# Set degree change per step (effectively the speed):#
				new_degrees_per_step[changer] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
			}#
			euler_pole_longitudes <- new_euler_longitudes#
			euler_pole_latitudes <- new_euler_latitudes#
			degrees_per_step <- new_degrees_per_step#
		}#
#
#Need to add in the tree bit#
		#Move the animals with the continents#
		for (cont in 1:N_continents) {#
			#Find the rows that are in the continent of focus#
			moving <- which(rownames(organism_long_matrix)==cont)#
#
			if (length(moving)==0) {#
				next #
			} else {#
				#Find out how many degrees around the euler pole that continent went#
				organism_degrees <- organism_mover[cont,3]#
				#loops through all the organisms that are currently living#
				for (organism in 1:length(moving)) {#
					organism_row <- moving[organism]#
					if (is.na(organism_long_matrix[organism_row, ot + 1])) {#
						next#
					} else {#
						first_long <- organism_long_matrix[organism_row, ot + 1]#
						first_lat <- organism_lat_matrix[organism_row, ot + 1]#
						organism_distance <- GreatCircleDistanceFromLongLat(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						organism_bearing <- BearingBetweenTwoLongLatPoints(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						new_organism_bearing <- (organism_bearing + organism_degrees) %% 360#
						new_organism_loc <- EndPoint(organism_mover[cont,1], organism_mover[cont,2], new_organism_bearing, organism_distance)#
						organism_long_matrix[organism_row, ot + 1] <- new_organism_loc$long#
    					organism_lat_matrix[organism_row, ot + 1] <- new_organism_loc$lat#
					}#
				}#
			}#
		}#
		for (f in 1:organism_multiplier) {#
            if (sum(alive) == 0) stop("METEOR IMPACT!! EVERYTHING HAS GONE EXTINCT! AAAAHHHHHH!!!")#
            dt<-1#
            ot <- ot + dt#
            for (m in 1:nrow(organism_lat_matrix)) {#
                if (alive[m]) {#
                    starting<-c(organism_lat_matrix[m,ot],organism_long_matrix[m,ot])#
                    moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd))) #generates a random walk step and calculates new position#
                    on_cont <- as.numeric(rownames(organism_lat_matrix)[m])#
                    friends <- as.numeric(strsplit(tail(touching, n=1)[[1]][which_supercontinent(on_cont, tail(touching, n=1)[[1]])], "&")[[1]])#
                    dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    if (length(friends) > 1) {#
                    	all_dist <- vector(length = length(friends))#
                    	for (g in 1:length(friends)) {#
                    		all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    	}#
                    	while (min(all_dist) > radius) {#
                    		moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		temp_all_dist <- vector(length = length(friends))#
                    		for (g in 1:length(friends)) {#
                    			temp_all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    		}#
                    		all_dist <- temp_all_dist#
                    	}#
                    	new_cont <- friends[which(all_dist == min(all_dist))] #
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                    	rownames(organism_long_matrix)[m] <- new_cont#
                    	rownames(organism_lat_matrix)[m] <- new_cont#
                    	if(new_cont != on_cont) {#
                    		dispersals <- rbind(dispersals, c(on_cont, new_cont, m, t, ot+1))#
                    	}#
                    } else {#
                    	while (dist_from_center >= radius) {#
                    		moveto <- EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    	}#
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                	}#
                }#
            }#
#
            r <- runif(1)#
            if (r <= b/(b + d)) { ###4 #this creates a bifucation in the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                e <- matrix(edge[alive,], ncol = 2)#
                parent <- e[random_lineage,2]#
                x <- which(edge[,2] == parent)#
                new.rows.lat <- new.rows.long <- extra.rows#
                new.rows.lat[, ot+1] <- organism_lat_matrix[x, ot+1] #updates the long and lat matricies with new coordiantes for each lineage#
                new.rows.long[, ot+1] <- organism_long_matrix[x, ot+1]#
                rownames(new.rows.lat) <- rep(rownames(organism_lat_matrix)[x],2)#
                rownames(new.rows.long) <- rep(rownames(organism_long_matrix)[x],2)#
                organism_lat_matrix <- rbind(organism_lat_matrix,new.rows.lat)#
                organism_long_matrix <- rbind(organism_long_matrix,new.rows.long)#
                alive[alive][random_lineage] <- FALSE#
                edge <- rbind(edge, c(parent, next.node), c(parent, next.node + 1))#
                next.node <- next.node + 2#
                alive <- c(alive, TRUE, TRUE)#
                stem.depth <- c(stem.depth, ot, ot)#
                edge.length[x] <- ot - stem.depth[x]#
                edge.length<-c(edge.length, NA, NA)#
            } else {###4 This terminates one of the current lineages on the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                edge.length[alive][random_lineage] <- ot - stem.depth[alive][random_lineage]#
                alive[alive][random_lineage] <- FALSE#
            }###4#
        }#1A#
        if (any(progress == t)) {#
        	cat("- ")#
        }#
    }#
#
    #Things to do right at the end to turn it into a phylo object#
    edge.length[alive] <- ot - stem.depth[alive];#
    n <- -1#
    for (f in 1:max(edge)) {#
        if (any(edge[,1] == f)) {#
           	edge[which(edge[,1] == f), 1] <- n#
           	edge[which(edge[,2] == f), 2] <- n#
           	n <- n - 1;#
        }#
    }#
    edge[edge > 0] <- 1:sum(edge > 0)#
   	tip.label <- 1:sum(edge > 0)#
    mode(edge) <- "character"#
    mode(tip.label) <- "character"#
    obj <- list(edge = edge, edge.length = edge.length, tip.label=tip.label)#
    class(obj) <- "phylo"#
    obj <- old2new.phylo(obj)#
    obj$tip.label = paste("s", 1:Ntip(obj), sep = "")#
	# Add final time step to continental configurations:#
	names(linked)[length(linked)] <- paste(strsplit(names(linked)[length(linked)], ":")[[1]][1], ":", t, sep="")#
	output <- list(position, linked, touching, obj, organism_long_matrix, organism_lat_matrix)#
	names(output) <- c("continent_positions", "continent_clusters", "continent_overlaps", "tree", "organism_longitudes", "organism_latitudes")
try<-output
plot(try$organism_longitudes[1,], try$organism_latitudes[1,], xlim=c(-180, 180), ylim=c(-90, 90), type = "l")
plot(try$organism_longitudes[1,], try$organism_latitudes[1,], xlim=c(-180, 180), ylim=c(-90, 90), type = "l")
for (i in 1:nrow(try$organism_longitudes))   lines(try$organism_longitudes[i,], try$organism_latitudes[i,])
for(i in 1:N_continents) points(try$continent_positions[i,,1], try$continent_positions[i,,2], col=rainbow(N_steps))
touching
linked
N_steps = 500; organism_multiplier = 1; N_continents = 12; radius = 2000; start_configuration = "supercontinent"; squishiness = 0.25; stickiness = 0.95; continent_speed_mean = 5; continent_speed_sd = 2; organism_step_sd = 200; b = 0.1; d = 0.05; EarthRad = 6367.4447; polar = FALSE
N_steps = 500; organism_multiplier = 1; N_continents = 12; radius = 2000; start_configuration = "random separate"; squishiness = 0.25; stickiness = 0.95; continent_speed_mean = 5; continent_speed_sd = 2; organism_step_sd = 200; b = 0.1; d = 0.05; EarthRad = 6367.4447; polar = FALSE
# Subfunction to find out which supercontinent a circle belongs to:#
	which_supercontinent <- function(cont, sprconts){#
		cont <- as.character(cont)#
		result <- which(unlist(lapply(lapply(lapply(strsplit(sprconts, "&"), match, cont), sort), length)) == 1)#
		return(result)#
	}#
	# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)#
# Are any continents joined at start?:#
#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
#
	# Get list of separate continents:#
	separate_continents <- HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
#
	# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
	touching_continents <- HowManySeparateContinents((radius * 2), continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
# Assign Euler poles to each separate continent:#
	# Randomly draw longitudes for each separated continent:#
	euler_pole_longitudes <- runif(length(separate_continents), -180, 180)#
	# Randomly draw latitudes for each separated continent:#
	euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
	# Ensure no latitude is directly at a pole (North or South) by redrawing if any are found:#
	if((sum(euler_pole_latitudes == 90) + sum(euler_pole_latitudes == -90)) > 0) euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
#
# Assign speeds to each separate continent:#
	# Create empty vector to store degrees per step (effectively the speed of movement) for each continent:#
	degrees_per_step <- vector(mode="numeric")#
	# For each separate continent:#
	for(i in 1:length(separate_continents)) {#
		# Get Greate Circle distances from Euler pole to each continent centre:#
		euler_GC_distances <- One2ManyGreatCircleDistance(euler_pole_longitudes[i], euler_pole_latitudes[i], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Longitude"], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Latitude"])#
		# Find GC distance to furthest continent (closest to euler pole "equator") in cluster (as speed will be assigned based on this):#
		furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
		# Randomly draw a continent speed:#
		continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# If a negative or zero speed is picked then redraw:#
		while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# Set degree change per step (effectively the speed):#
		degrees_per_step[i] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
	}#
#
	#starting information for the tree#
	dispersals <- matrix(nrow=0, ncol=5)#
	begin_cont <- ceiling(runif(1, 0, N_continents))#
	life_begins <- EndPoint(continent_starting_points[begin_cont, "Longitude"], continent_starting_points[begin_cont, "Latitude"], runif(1,0,360), runif(1,0,radius))#
	extra.rows <- matrix(NA,nrow=2,ncol= (N_steps * organism_multiplier) + 1)#
	organism_lat_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_long_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_lat_matrix[,1] <- life_begins$lat#
    organism_long_matrix[,1] <- life_begins$lon#
    rownames(organism_lat_matrix) <- rep(begin_cont, 2)#
    rownames(organism_long_matrix) <- rep(begin_cont, 2)#
    edge <- rbind(c(1, 2), c(1, 3)) # this is a starting edge matrix#
    edge.length <- rep(NA, 2)#
    stem.depth <- numeric(2)#
    alive <- rep(TRUE, 2) # marker for live lineages#
    ot <- 0; # time(step) at any point in the tree#
    next.node <- 4#
#
	# Now need to move them!#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	linked <- list()#
	linked[[1]] <- separate_continents#
	names(linked)[[1]] <- "1:1"#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	touching <- list()#
	touching[[1]] <- touching_continents#
#
	#Array to store the positions of every continent at each time step#
	position <- array(NA, c(N_continents, N_steps + 1, 2), c("continent", "timestep", "coordinate"))#
	position[,1,1] <- continent_starting_points[,"Longitude"]#
	position[,1,2] <- continent_starting_points[,"Latitude"]#
#
	temp_position<-matrix(nrow = N_continents, ncol=2)#
#
	progress <- seq(1, N_steps, floor(N_steps/50))#
	cat("Starting time steps \n")#
	cat("Progress \n")#
	cat("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n")#
#
	#for loops to move everything#
	for (t in 2:(N_steps + 1)) {#
		#distances apart before they move#
		starting_distances <- GreatCircleDistanceMatrix(position[,t-1,1], position[,t-1,2])#
#
		for (k in 1:N_continents) {#
			#find current longlat of the circle k#
			start_long <- position[k, t-1, 1]#
			start_lat <- position[k, t-1, 2]#
#
			#Identify which supercontinent, and therefore which element of the euler pole and speed vectors, the circle k belongs to#
			where <- which_supercontinent(k, tail(linked, n=1)[[1]])#
#
			#Find distance of circle from pole#
			distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where], lat2=euler_pole_latitudes[where], Warn = FALSE)#
			#Find bearing of circle from pole#
			init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where], euler_pole_latitudes[where], start_long, start_lat)#
#
			#Find the new bearing of circle from pole according to the speed specified#
			new_bearing <- (init_bearing + degrees_per_step[where]) %% 360#
#
			#Find the new location of the circle#
			new_loc <- EndPoint(euler_pole_longitudes[where], euler_pole_latitudes[where], new_bearing, distance)#
#
			#Add the new loction to the position matrix#
			temp_position[k,1] <- new_loc$long#
			temp_position[k,2] <- new_loc$lat#
#
		}#
#
		#Matrix of the distances between each continent in their new positions, before these are set#
		new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
		comp1 <- vector()#
		comp2 <- vector()#
#
		#Making a vector of whether any continents have collided and should be linked#
		collisions<-matrix(nrow=0, ncol=2)#
		for (q in 1:(N_continents-1)) {#
			for (p in (q+1):N_continents) {#
				comp1 <- all.equal(new_distances[p,q],starting_distances[p,q])#
				comp2 <- new_distances[p,q] <= min_separation#
				if (comp1 != TRUE && comp2 == TRUE) {#
					collisions<-rbind(collisions,c(p,q))#
				}#
			}#
		}#
#
		#Matrix of euler poles and speeds for each individual continent for moving the animals later#
		organism_mover <- matrix(nrow=N_continents, ncol= 3)#
		for (clump in 1:length(tail(linked, n=1)[[1]])) {#
			which_conts <- as.numeric(strsplit(tail(linked, n=1)[[1]][[clump]], "&")[[1]])#
			organism_mover[which_conts,1] <- rep(euler_pole_longitudes[clump],length(which_conts))#
			organism_mover[which_conts,2] <- rep(euler_pole_latitudes[clump],length(which_conts))#
			#This bit will get overwritten if there are collisions#
			organism_mover[which_conts,3] <- rep(degrees_per_step[clump],length(which_conts))#
		}#
		perm_collisions <- matrix(nrow=0, ncol=2)#
#
		# Moving continents back if there has only been one collision#
		while(nrow(collisions) > 0) {#
#
			# Set up vector to store proportional changes after collisions#
			proportion <- vector()#
#
			# Find out proportions to reduce to for all potential collisions#
			for (coll in 1:nrow(collisions)) {#
				cont_1 <- collisions[coll,1]#
				cont_2 <- collisions[coll,2]#
				where_1 <- which_supercontinent(cont_1, tail(linked, n=1)[[1]])#
				where_2 <- which_supercontinent(cont_2, tail(linked, n=1)[[1]])#
				continent_1_euler_longitude = euler_pole_longitudes[where_1]#
				continent_1_euler_latitude = euler_pole_latitudes[where_1]#
				continent_2_euler_longitude = euler_pole_longitudes[where_2]#
				continent_2_euler_latitude = euler_pole_latitudes[where_2]#
				continent_1_degrees_per_step = degrees_per_step[where_1]#
				continent_2_degrees_per_step = degrees_per_step[where_2]#
				proportion[coll] <- ColliderReverser(min_separation, position[cont_1, t-1, 1], position[cont_1, t-1, 2], temp_position[cont_1,1], temp_position[cont_1,2], position[cont_2, t-1, 1], position[cont_2, t-1, 2], temp_position[cont_2,1], temp_position[cont_2,2], continent_1_euler_longitude, continent_1_euler_latitude, continent_2_euler_longitude, continent_2_euler_latitude, continent_1_degrees_per_step, continent_2_degrees_per_step, EarthRad = 6367.4447, Warn = FALSE)#
			}#
#
			# Select proportion to move for first collision#
			first_collision <- match(min(proportion),proportion)#
#
			# Find the two continents that collided first#
			cont_involved <- sort(collisions[first_collision, ])#
#
			# Add to matrix of definite collisions that cannot be separated in the next step#
			perm_collisions <- rbind(perm_collisions, cont_involved)#
#
			# Move first clump back#
			head_of_collision_1 <- cont_involved[1]#
			where_1 <- which_supercontinent(head_of_collision_1, tail(linked, n=1)[[1]])#
#
			#Find the other continents that were attached to the collider#
			all_involved <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_1], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents in one of the clumps#
			for (rev in 1:length(all_involved)) {#
				cont_to_rev <- all_involved[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_1], lat2=euler_pole_latitudes[where_1], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], start_long, start_lat)#
#
				#degrees to add#
				addition <- proportion[first_collision] * degrees_per_step[where_1]#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <- (init_bearing + addition) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
#
				organism_mover[cont_to_rev,3] <- addition#
			}#
#
			#Move the second clump back#
			head_of_collision_2 <- cont_involved[2]#
			where_2 <- which_supercontinent(head_of_collision_2, tail(linked, n=1)[[1]])#
			all_involved_2 <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_2], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents the other clump#
			for (rev in 1:length(all_involved_2)) {#
				cont_to_rev <- all_involved_2[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_2], lat2=euler_pole_latitudes[where_2], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], start_long, start_lat)#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <-  (init_bearing + (proportion[first_collision] * degrees_per_step[where_2])) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
			}#
#
			#Recalculate the new distances#
			new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
			comp1 <- vector()#
			comp2 <- vector()#
#
			# Check whether any other collisions have still occurred#
			collisions <- matrix(nrow=0, ncol=2)#
			for (q in 1:(N_continents - 1)) {#
				for (p in (q+1):N_continents) {#
					comp1 <- all.equal(new_distances[p, q], starting_distances[p, q])#
					comp2 <- new_distances[p, q] <= min_separation#
					if (comp1 != TRUE && comp2 == TRUE) {#
						# If collision has not already been recorded:#
						if(length(sort(match(paste(sort(c(q, p)), collapse=""), apply(perm_collisions, 1, paste, collapse="")))) == 0) {#
							# Record collision:#
							collisions <- rbind(collisions, c(p, q))#
						}#
					}#
				}#
			}#
		}#
#
		# When it finishes while loop can now 'ossify' the positions and move to selecting separations#
		position[, t, 1] <- temp_position[, 1]#
		position[, t, 2] <- temp_position[, 2]#
#
# Finding out if anything gets separated#
		# How many separate continents are there now? (after collisions may have occurred):#
		separate_continents <- HowManySeparateContinents(min_separation, position[,t,1], position[,t,2])#
		# Make random uniform draws for each continental cluster:#
		separation_draws <- runif(length(grep("&", separate_continents)))#
		# Case if a separation occurs (drawn value is equal to or exceeds stickiness):#
		if(any(separation_draws >= stickiness)) {#
			# Get clusters of continents to split apart:#
			clusters_to_split <- separate_continents[grep("&", separate_continents)][which(separation_draws >= stickiness)]#
			# For each cluster to split apart:#
			for(i in 1:length(clusters_to_split)) {#
				# Get numbers of continents involved:#
				cluster_continent_numbers <- sort(strsplit(clusters_to_split[i], "&")[[1]])#
				# Get longitudes of continents in cluster:#
				cluster_longitudes <- position[as.numeric(cluster_continent_numbers), t, 1]#
#
				# Get latitudes of continents in cluster:#
				cluster_latitudes <- position[as.numeric(cluster_continent_numbers), t, 2]#
				# Make protected links an empty matrix:#
				cluster_protected_links <- matrix(nrow = 0, ncol = 2)#
				# If there are recent collisions (that will potentially need to be excluded from new splits):#
				if(length(perm_collisions) > 0) {#
					# For each new collision:#
					for(j in 1:nrow(perm_collisions)) {#
						# If new collision occurs within the cluster:#
						if(length(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers)) == 2) {#
							# Add new collision to protected links list:#
							cluster_protected_links <- rbind(cluster_protected_links, perm_collisions[j, ])#
						}#
					}#
#
				}#
				# Get splits (new clusters) of separated cluster:#
				splits <- ContinentSplitter(min_separation, cluster_longitudes, cluster_latitudes, cluster_continent_numbers, cluster_protected_links, EarthRad)#
				# Update separate continents vector:#
				separate_continents <- sort(c(separate_continents[-match(clusters_to_split[i], separate_continents)], splits))#
			}#
		}#
#
# Now change the Euler poles and speeds#
		# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
		touching_continents <- HowManySeparateContinents((radius * 2), position[,t,1], position[,t,2])#
		if (paste(sort(touching_continents), collapse="") != paste(sort(tail(touching,n=1)[[1]]), collapse="")) {#
			touching <- c(touching, list(touching_continents))#
		}#
#
		# If the continental clustering has changed:#
		if (paste(sort(separate_continents), collapse="") != paste(sort(tail(linked,n=1)[[1]]), collapse="")) {#
			# Add new continental configuration to linked list#
			linked <- c(linked, list(separate_continents))#
#
			# Update time step for previous continental configuration:#
			names(linked)[(length(linked) - 1)] <- paste(strsplit(names(linked[(length(linked) - 1)]), ":")[[1]][1], ":", t - 1, sep="")#
			# Add time step to new continental configuration:#
			names(linked)[length(linked)] <- paste(t, ":", t, sep="")#
			# Select continents that are different to previous time step#
			toKeep <- c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]])[duplicated(c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]]))]#
#
			#Vectors for new poles and speeds#
			new_euler_latitudes <- rep(NA, length(separate_continents))#
			new_euler_longitudes <- rep(NA, length(separate_continents))#
			new_degrees_per_step <- rep(NA, length(separate_continents))#
#
			if (length(toKeep) != 0){#
				#Inherit previous poles and speeds for those clumps that remain the same#
				for (y in 1:length(toKeep)) {#
					new_euler_longitudes[match(toKeep[y],separate_continents)]<- euler_pole_longitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_euler_latitudes[match(toKeep[y],separate_continents)]<- euler_pole_latitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_degrees_per_step[match(toKeep[y],separate_continents)]<- degrees_per_step[match(toKeep[y],tail(linked, n=2)[[1]])]#
				}#
			}#
#
			# Make new Euler poles#
			new_euler_longitudes[is.na(new_euler_longitudes)]<- runif((length(separate_continents)-length(toKeep)), -180, 180)#
#
			changed_euler_latitudes<- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			while((sum(changed_euler_latitudes == 90) + sum(changed_euler_latitudes == -90)) > 0) changed_euler_latitudes <- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			new_euler_latitudes[is.na(new_euler_latitudes)] <- changed_euler_latitudes#
#
			# Get Great Circle distances from Euler pole to each continent centre:#
			for (l in 1:(length(separate_continents)-length(toKeep))) {#
				# Find the first NA to fill in:#
				changer <- match(NA, new_degrees_per_step)#
				#Find the contients that are in the clump whose speed is going to change#
				rows <- as.numeric(unlist(strsplit(separate_continents[changer], "&")))#
				#Find the new euler pole for that clump#
				euler_long <- new_euler_longitudes[changer]#
				euler_lat <- new_euler_latitudes[changer]#
				#Find the distances of each of the continents in the clump from their new euler pole#
				euler_GC_distances <- One2ManyGreatCircleDistance(euler_long, euler_lat, position[rows, t, 1], position[rows, t, 2])#
				#Find which of those is closest to the equator#
				furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
				# Randomly draw a continent speed:#
				continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# If a negative or zero speed is picked then redraw:#
				while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# Set degree change per step (effectively the speed):#
				new_degrees_per_step[changer] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
			}#
			euler_pole_longitudes <- new_euler_longitudes#
			euler_pole_latitudes <- new_euler_latitudes#
			degrees_per_step <- new_degrees_per_step#
		}#
#
#Need to add in the tree bit#
		#Move the animals with the continents#
		for (cont in 1:N_continents) {#
			#Find the rows that are in the continent of focus#
			moving <- which(rownames(organism_long_matrix)==cont)#
#
			if (length(moving)==0) {#
				next #
			} else {#
				#Find out how many degrees around the euler pole that continent went#
				organism_degrees <- organism_mover[cont,3]#
				#loops through all the organisms that are currently living#
				for (organism in 1:length(moving)) {#
					organism_row <- moving[organism]#
					if (is.na(organism_long_matrix[organism_row, ot + 1])) {#
						next#
					} else {#
						first_long <- organism_long_matrix[organism_row, ot + 1]#
						first_lat <- organism_lat_matrix[organism_row, ot + 1]#
						organism_distance <- GreatCircleDistanceFromLongLat(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						organism_bearing <- BearingBetweenTwoLongLatPoints(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						new_organism_bearing <- (organism_bearing + organism_degrees) %% 360#
						new_organism_loc <- EndPoint(organism_mover[cont,1], organism_mover[cont,2], new_organism_bearing, organism_distance)#
						organism_long_matrix[organism_row, ot + 1] <- new_organism_loc$long#
    					organism_lat_matrix[organism_row, ot + 1] <- new_organism_loc$lat#
					}#
				}#
			}#
		}#
		for (f in 1:organism_multiplier) {#
            if (sum(alive) == 0) stop("METEOR IMPACT!! EVERYTHING HAS GONE EXTINCT! AAAAHHHHHH!!!")#
            dt<-1#
            ot <- ot + dt#
            for (m in 1:nrow(organism_lat_matrix)) {#
                if (alive[m]) {#
                    starting<-c(organism_lat_matrix[m,ot],organism_long_matrix[m,ot])#
                    moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd))) #generates a random walk step and calculates new position#
                    on_cont <- as.numeric(rownames(organism_lat_matrix)[m])#
                    friends <- as.numeric(strsplit(tail(touching, n=1)[[1]][which_supercontinent(on_cont, tail(touching, n=1)[[1]])], "&")[[1]])#
                    dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    if (length(friends) > 1) {#
                    	all_dist <- vector(length = length(friends))#
                    	for (g in 1:length(friends)) {#
                    		all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    	}#
                    	while (min(all_dist) > radius) {#
                    		moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		temp_all_dist <- vector(length = length(friends))#
                    		for (g in 1:length(friends)) {#
                    			temp_all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    		}#
                    		all_dist <- temp_all_dist#
                    	}#
                    	new_cont <- friends[which(all_dist == min(all_dist))] #
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                    	rownames(organism_long_matrix)[m] <- new_cont#
                    	rownames(organism_lat_matrix)[m] <- new_cont#
                    	if(new_cont != on_cont) {#
                    		dispersals <- rbind(dispersals, c(on_cont, new_cont, m, t, ot+1))#
                    	}#
                    } else {#
                    	while (dist_from_center >= radius) {#
                    		moveto <- EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    	}#
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                	}#
                }#
            }#
#
            r <- runif(1)#
            if (r <= b/(b + d)) { ###4 #this creates a bifucation in the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                e <- matrix(edge[alive,], ncol = 2)#
                parent <- e[random_lineage,2]#
                x <- which(edge[,2] == parent)#
                new.rows.lat <- new.rows.long <- extra.rows#
                new.rows.lat[, ot+1] <- organism_lat_matrix[x, ot+1] #updates the long and lat matricies with new coordiantes for each lineage#
                new.rows.long[, ot+1] <- organism_long_matrix[x, ot+1]#
                rownames(new.rows.lat) <- rep(rownames(organism_lat_matrix)[x],2)#
                rownames(new.rows.long) <- rep(rownames(organism_long_matrix)[x],2)#
                organism_lat_matrix <- rbind(organism_lat_matrix,new.rows.lat)#
                organism_long_matrix <- rbind(organism_long_matrix,new.rows.long)#
                alive[alive][random_lineage] <- FALSE#
                edge <- rbind(edge, c(parent, next.node), c(parent, next.node + 1))#
                next.node <- next.node + 2#
                alive <- c(alive, TRUE, TRUE)#
                stem.depth <- c(stem.depth, ot, ot)#
                edge.length[x] <- ot - stem.depth[x]#
                edge.length<-c(edge.length, NA, NA)#
            } else {###4 This terminates one of the current lineages on the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                edge.length[alive][random_lineage] <- ot - stem.depth[alive][random_lineage]#
                alive[alive][random_lineage] <- FALSE#
            }###4#
        }#1A#
        if (any(progress == t)) {#
        	cat("- ")#
        }#
    }#
#
    #Things to do right at the end to turn it into a phylo object#
    edge.length[alive] <- ot - stem.depth[alive];#
    n <- -1#
    for (f in 1:max(edge)) {#
        if (any(edge[,1] == f)) {#
           	edge[which(edge[,1] == f), 1] <- n#
           	edge[which(edge[,2] == f), 2] <- n#
           	n <- n - 1;#
        }#
    }#
    edge[edge > 0] <- 1:sum(edge > 0)#
   	tip.label <- 1:sum(edge > 0)#
    mode(edge) <- "character"#
    mode(tip.label) <- "character"#
    obj <- list(edge = edge, edge.length = edge.length, tip.label=tip.label)#
    class(obj) <- "phylo"#
    obj <- old2new.phylo(obj)#
    obj$tip.label = paste("s", 1:Ntip(obj), sep = "")#
	# Add final time step to continental configurations:#
	names(linked)[length(linked)] <- paste(strsplit(names(linked)[length(linked)], ":")[[1]][1], ":", t, sep="")#
	output <- list(position, linked, touching, obj, organism_long_matrix, organism_lat_matrix)#
	names(output) <- c("continent_positions", "continent_clusters", "continent_overlaps", "tree", "organism_longitudes", "organism_latitudes")
try<-output
plot(try$organism_longitudes[1,], try$organism_latitudes[1,], xlim=c(-180, 180), ylim=c(-90, 90), type = "l")
for (i in 1:nrow(try$organism_longitudes))   lines(try$organism_longitudes[i,], try$organism_latitudes[i,])
for(i in 1:N_continents) points(try$continent_positions[i,,1], try$continent_positions[i,,2], col=rainbow(N_steps))
touching
# Subfunction to find out which supercontinent a circle belongs to:#
	which_supercontinent <- function(cont, sprconts){#
		cont <- as.character(cont)#
		result <- which(unlist(lapply(lapply(lapply(strsplit(sprconts, "&"), match, cont), sort), length)) == 1)#
		return(result)#
	}#
	# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)#
# Are any continents joined at start?:#
#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
#
	# Get list of separate continents:#
	separate_continents <- HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
#
	# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
	touching_continents <- HowManySeparateContinents((radius * 2), continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
# Assign Euler poles to each separate continent:#
	# Randomly draw longitudes for each separated continent:#
	euler_pole_longitudes <- runif(length(separate_continents), -180, 180)#
	# Randomly draw latitudes for each separated continent:#
	euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
	# Ensure no latitude is directly at a pole (North or South) by redrawing if any are found:#
	if((sum(euler_pole_latitudes == 90) + sum(euler_pole_latitudes == -90)) > 0) euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
#
# Assign speeds to each separate continent:#
	# Create empty vector to store degrees per step (effectively the speed of movement) for each continent:#
	degrees_per_step <- vector(mode="numeric")#
	# For each separate continent:#
	for(i in 1:length(separate_continents)) {#
		# Get Greate Circle distances from Euler pole to each continent centre:#
		euler_GC_distances <- One2ManyGreatCircleDistance(euler_pole_longitudes[i], euler_pole_latitudes[i], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Longitude"], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Latitude"])#
		# Find GC distance to furthest continent (closest to euler pole "equator") in cluster (as speed will be assigned based on this):#
		furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
		# Randomly draw a continent speed:#
		continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# If a negative or zero speed is picked then redraw:#
		while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# Set degree change per step (effectively the speed):#
		degrees_per_step[i] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
	}#
#
	#starting information for the tree#
	dispersals <- matrix(nrow=0, ncol=5)#
	begin_cont <- ceiling(runif(1, 0, N_continents))#
	life_begins <- EndPoint(continent_starting_points[begin_cont, "Longitude"], continent_starting_points[begin_cont, "Latitude"], runif(1,0,360), runif(1,0,radius))#
	extra.rows <- matrix(NA,nrow=2,ncol= (N_steps * organism_multiplier) + 1)#
	organism_lat_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_long_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_lat_matrix[,1] <- life_begins$lat#
    organism_long_matrix[,1] <- life_begins$lon#
    rownames(organism_lat_matrix) <- rep(begin_cont, 2)#
    rownames(organism_long_matrix) <- rep(begin_cont, 2)#
    edge <- rbind(c(1, 2), c(1, 3)) # this is a starting edge matrix#
    edge.length <- rep(NA, 2)#
    stem.depth <- numeric(2)#
    alive <- rep(TRUE, 2) # marker for live lineages#
    ot <- 0; # time(step) at any point in the tree#
    next.node <- 4#
#
	# Now need to move them!#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	linked <- list()#
	linked[[1]] <- separate_continents#
	names(linked)[[1]] <- "1:1"#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	touching <- list()#
	touching[[1]] <- touching_continents#
#
	#Array to store the positions of every continent at each time step#
	position <- array(NA, c(N_continents, N_steps + 1, 2), c("continent", "timestep", "coordinate"))#
	position[,1,1] <- continent_starting_points[,"Longitude"]#
	position[,1,2] <- continent_starting_points[,"Latitude"]#
#
	temp_position<-matrix(nrow = N_continents, ncol=2)#
#
	progress <- seq(1, N_steps, floor(N_steps/50))#
	cat("Starting time steps \n")#
	cat("Progress \n")#
	cat("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n")#
#
	#for loops to move everything#
	for (t in 2:(N_steps + 1)) {#
		#distances apart before they move#
		starting_distances <- GreatCircleDistanceMatrix(position[,t-1,1], position[,t-1,2])#
#
		for (k in 1:N_continents) {#
			#find current longlat of the circle k#
			start_long <- position[k, t-1, 1]#
			start_lat <- position[k, t-1, 2]#
#
			#Identify which supercontinent, and therefore which element of the euler pole and speed vectors, the circle k belongs to#
			where <- which_supercontinent(k, tail(linked, n=1)[[1]])#
#
			#Find distance of circle from pole#
			distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where], lat2=euler_pole_latitudes[where], Warn = FALSE)#
			#Find bearing of circle from pole#
			init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where], euler_pole_latitudes[where], start_long, start_lat)#
#
			#Find the new bearing of circle from pole according to the speed specified#
			new_bearing <- (init_bearing + degrees_per_step[where]) %% 360#
#
			#Find the new location of the circle#
			new_loc <- EndPoint(euler_pole_longitudes[where], euler_pole_latitudes[where], new_bearing, distance)#
#
			#Add the new loction to the position matrix#
			temp_position[k,1] <- new_loc$long#
			temp_position[k,2] <- new_loc$lat#
#
		}#
#
		#Matrix of the distances between each continent in their new positions, before these are set#
		new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
		comp1 <- vector()#
		comp2 <- vector()#
#
		#Making a vector of whether any continents have collided and should be linked#
		collisions<-matrix(nrow=0, ncol=2)#
		for (q in 1:(N_continents-1)) {#
			for (p in (q+1):N_continents) {#
				comp1 <- all.equal(new_distances[p,q],starting_distances[p,q])#
				comp2 <- new_distances[p,q] <= min_separation#
				if (comp1 != TRUE && comp2 == TRUE) {#
					collisions<-rbind(collisions,c(p,q))#
				}#
			}#
		}#
#
		#Matrix of euler poles and speeds for each individual continent for moving the animals later#
		organism_mover <- matrix(nrow=N_continents, ncol= 3)#
		for (clump in 1:length(tail(linked, n=1)[[1]])) {#
			which_conts <- as.numeric(strsplit(tail(linked, n=1)[[1]][[clump]], "&")[[1]])#
			organism_mover[which_conts,1] <- rep(euler_pole_longitudes[clump],length(which_conts))#
			organism_mover[which_conts,2] <- rep(euler_pole_latitudes[clump],length(which_conts))#
			#This bit will get overwritten if there are collisions#
			organism_mover[which_conts,3] <- rep(degrees_per_step[clump],length(which_conts))#
		}#
		perm_collisions <- matrix(nrow=0, ncol=2)#
#
		# Moving continents back if there has only been one collision#
		while(nrow(collisions) > 0) {#
#
			# Set up vector to store proportional changes after collisions#
			proportion <- vector()#
#
			# Find out proportions to reduce to for all potential collisions#
			for (coll in 1:nrow(collisions)) {#
				cont_1 <- collisions[coll,1]#
				cont_2 <- collisions[coll,2]#
				where_1 <- which_supercontinent(cont_1, tail(linked, n=1)[[1]])#
				where_2 <- which_supercontinent(cont_2, tail(linked, n=1)[[1]])#
				continent_1_euler_longitude = euler_pole_longitudes[where_1]#
				continent_1_euler_latitude = euler_pole_latitudes[where_1]#
				continent_2_euler_longitude = euler_pole_longitudes[where_2]#
				continent_2_euler_latitude = euler_pole_latitudes[where_2]#
				continent_1_degrees_per_step = degrees_per_step[where_1]#
				continent_2_degrees_per_step = degrees_per_step[where_2]#
				proportion[coll] <- ColliderReverser(min_separation, position[cont_1, t-1, 1], position[cont_1, t-1, 2], temp_position[cont_1,1], temp_position[cont_1,2], position[cont_2, t-1, 1], position[cont_2, t-1, 2], temp_position[cont_2,1], temp_position[cont_2,2], continent_1_euler_longitude, continent_1_euler_latitude, continent_2_euler_longitude, continent_2_euler_latitude, continent_1_degrees_per_step, continent_2_degrees_per_step, EarthRad = 6367.4447, Warn = FALSE)#
			}#
#
			# Select proportion to move for first collision#
			first_collision <- match(min(proportion),proportion)#
#
			# Find the two continents that collided first#
			cont_involved <- sort(collisions[first_collision, ])#
#
			# Add to matrix of definite collisions that cannot be separated in the next step#
			perm_collisions <- rbind(perm_collisions, cont_involved)#
#
			# Move first clump back#
			head_of_collision_1 <- cont_involved[1]#
			where_1 <- which_supercontinent(head_of_collision_1, tail(linked, n=1)[[1]])#
#
			#Find the other continents that were attached to the collider#
			all_involved <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_1], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents in one of the clumps#
			for (rev in 1:length(all_involved)) {#
				cont_to_rev <- all_involved[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_1], lat2=euler_pole_latitudes[where_1], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], start_long, start_lat)#
#
				#degrees to add#
				addition <- proportion[first_collision] * degrees_per_step[where_1]#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <- (init_bearing + addition) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
#
				organism_mover[cont_to_rev,3] <- addition#
			}#
#
			#Move the second clump back#
			head_of_collision_2 <- cont_involved[2]#
			where_2 <- which_supercontinent(head_of_collision_2, tail(linked, n=1)[[1]])#
			all_involved_2 <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_2], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents the other clump#
			for (rev in 1:length(all_involved_2)) {#
				cont_to_rev <- all_involved_2[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_2], lat2=euler_pole_latitudes[where_2], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], start_long, start_lat)#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <-  (init_bearing + (proportion[first_collision] * degrees_per_step[where_2])) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
			}#
#
			#Recalculate the new distances#
			new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
			comp1 <- vector()#
			comp2 <- vector()#
#
			# Check whether any other collisions have still occurred#
			collisions <- matrix(nrow=0, ncol=2)#
			for (q in 1:(N_continents - 1)) {#
				for (p in (q+1):N_continents) {#
					comp1 <- all.equal(new_distances[p, q], starting_distances[p, q])#
					comp2 <- new_distances[p, q] <= min_separation#
					if (comp1 != TRUE && comp2 == TRUE) {#
						# If collision has not already been recorded:#
						if(length(sort(match(paste(sort(c(q, p)), collapse=""), apply(perm_collisions, 1, paste, collapse="")))) == 0) {#
							# Record collision:#
							collisions <- rbind(collisions, c(p, q))#
						}#
					}#
				}#
			}#
		}#
#
		# When it finishes while loop can now 'ossify' the positions and move to selecting separations#
		position[, t, 1] <- temp_position[, 1]#
		position[, t, 2] <- temp_position[, 2]#
#
# Finding out if anything gets separated#
		# How many separate continents are there now? (after collisions may have occurred):#
		separate_continents <- HowManySeparateContinents(min_separation, position[,t,1], position[,t,2])#
		# Make random uniform draws for each continental cluster:#
		separation_draws <- runif(length(grep("&", separate_continents)))#
		# Case if a separation occurs (drawn value is equal to or exceeds stickiness):#
		if(any(separation_draws >= stickiness)) {#
			# Get clusters of continents to split apart:#
			clusters_to_split <- separate_continents[grep("&", separate_continents)][which(separation_draws >= stickiness)]#
			# For each cluster to split apart:#
			for(i in 1:length(clusters_to_split)) {#
				# Get numbers of continents involved:#
				cluster_continent_numbers <- sort(strsplit(clusters_to_split[i], "&")[[1]])#
				# Get longitudes of continents in cluster:#
				cluster_longitudes <- position[as.numeric(cluster_continent_numbers), t, 1]#
#
				# Get latitudes of continents in cluster:#
				cluster_latitudes <- position[as.numeric(cluster_continent_numbers), t, 2]#
				# Make protected links an empty matrix:#
				cluster_protected_links <- matrix(nrow = 0, ncol = 2)#
				# If there are recent collisions (that will potentially need to be excluded from new splits):#
				if(length(perm_collisions) > 0) {#
					# For each new collision:#
					for(j in 1:nrow(perm_collisions)) {#
						# If new collision occurs within the cluster:#
						if(length(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers)) == 2) {#
							# Add new collision to protected links list:#
							cluster_protected_links <- rbind(cluster_protected_links, perm_collisions[j, ])#
						}#
					}#
#
				}#
				# Get splits (new clusters) of separated cluster:#
				splits <- ContinentSplitter(min_separation, cluster_longitudes, cluster_latitudes, cluster_continent_numbers, cluster_protected_links, EarthRad)#
				# Update separate continents vector:#
				separate_continents <- sort(c(separate_continents[-match(clusters_to_split[i], separate_continents)], splits))#
			}#
		}#
#
# Now change the Euler poles and speeds#
		# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
		touching_continents <- HowManySeparateContinents((radius * 2), position[,t,1], position[,t,2])#
		if (paste(sort(touching_continents), collapse="") != paste(sort(tail(touching,n=1)[[1]]), collapse="")) {#
			touching <- c(touching, list(touching_continents))#
		}#
#
		# If the continental clustering has changed:#
		if (paste(sort(separate_continents), collapse="") != paste(sort(tail(linked,n=1)[[1]]), collapse="")) {#
			# Add new continental configuration to linked list#
			linked <- c(linked, list(separate_continents))#
#
			# Update time step for previous continental configuration:#
			names(linked)[(length(linked) - 1)] <- paste(strsplit(names(linked[(length(linked) - 1)]), ":")[[1]][1], ":", t - 1, sep="")#
			# Add time step to new continental configuration:#
			names(linked)[length(linked)] <- paste(t, ":", t, sep="")#
			# Select continents that are different to previous time step#
			toKeep <- c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]])[duplicated(c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]]))]#
#
			#Vectors for new poles and speeds#
			new_euler_latitudes <- rep(NA, length(separate_continents))#
			new_euler_longitudes <- rep(NA, length(separate_continents))#
			new_degrees_per_step <- rep(NA, length(separate_continents))#
#
			if (length(toKeep) != 0){#
				#Inherit previous poles and speeds for those clumps that remain the same#
				for (y in 1:length(toKeep)) {#
					new_euler_longitudes[match(toKeep[y],separate_continents)]<- euler_pole_longitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_euler_latitudes[match(toKeep[y],separate_continents)]<- euler_pole_latitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_degrees_per_step[match(toKeep[y],separate_continents)]<- degrees_per_step[match(toKeep[y],tail(linked, n=2)[[1]])]#
				}#
			}#
#
			# Make new Euler poles#
			new_euler_longitudes[is.na(new_euler_longitudes)]<- runif((length(separate_continents)-length(toKeep)), -180, 180)#
#
			changed_euler_latitudes<- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			while((sum(changed_euler_latitudes == 90) + sum(changed_euler_latitudes == -90)) > 0) changed_euler_latitudes <- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			new_euler_latitudes[is.na(new_euler_latitudes)] <- changed_euler_latitudes#
#
			# Get Great Circle distances from Euler pole to each continent centre:#
			for (l in 1:(length(separate_continents)-length(toKeep))) {#
				# Find the first NA to fill in:#
				changer <- match(NA, new_degrees_per_step)#
				#Find the contients that are in the clump whose speed is going to change#
				rows <- as.numeric(unlist(strsplit(separate_continents[changer], "&")))#
				#Find the new euler pole for that clump#
				euler_long <- new_euler_longitudes[changer]#
				euler_lat <- new_euler_latitudes[changer]#
				#Find the distances of each of the continents in the clump from their new euler pole#
				euler_GC_distances <- One2ManyGreatCircleDistance(euler_long, euler_lat, position[rows, t, 1], position[rows, t, 2])#
				#Find which of those is closest to the equator#
				furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
				# Randomly draw a continent speed:#
				continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# If a negative or zero speed is picked then redraw:#
				while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# Set degree change per step (effectively the speed):#
				new_degrees_per_step[changer] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
			}#
			euler_pole_longitudes <- new_euler_longitudes#
			euler_pole_latitudes <- new_euler_latitudes#
			degrees_per_step <- new_degrees_per_step#
		}#
#
#Need to add in the tree bit#
		#Move the animals with the continents#
		for (cont in 1:N_continents) {#
			#Find the rows that are in the continent of focus#
			moving <- which(rownames(organism_long_matrix)==cont)#
#
			if (length(moving)==0) {#
				next #
			} else {#
				#Find out how many degrees around the euler pole that continent went#
				organism_degrees <- organism_mover[cont,3]#
				#loops through all the organisms that are currently living#
				for (organism in 1:length(moving)) {#
					organism_row <- moving[organism]#
					if (is.na(organism_long_matrix[organism_row, ot + 1])) {#
						next#
					} else {#
						first_long <- organism_long_matrix[organism_row, ot + 1]#
						first_lat <- organism_lat_matrix[organism_row, ot + 1]#
						organism_distance <- GreatCircleDistanceFromLongLat(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						organism_bearing <- BearingBetweenTwoLongLatPoints(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						new_organism_bearing <- (organism_bearing + organism_degrees) %% 360#
						new_organism_loc <- EndPoint(organism_mover[cont,1], organism_mover[cont,2], new_organism_bearing, organism_distance)#
						organism_long_matrix[organism_row, ot + 1] <- new_organism_loc$long#
    					organism_lat_matrix[organism_row, ot + 1] <- new_organism_loc$lat#
					}#
				}#
			}#
		}#
		for (f in 1:organism_multiplier) {#
            if (sum(alive) == 0) stop("METEOR IMPACT!! EVERYTHING HAS GONE EXTINCT! AAAAHHHHHH!!!")#
            dt<-1#
            ot <- ot + dt#
            for (m in 1:nrow(organism_lat_matrix)) {#
                if (alive[m]) {#
                    starting<-c(organism_lat_matrix[m,ot],organism_long_matrix[m,ot])#
                    moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd))) #generates a random walk step and calculates new position#
                    on_cont <- as.numeric(rownames(organism_lat_matrix)[m])#
                    friends <- as.numeric(strsplit(tail(touching, n=1)[[1]][which_supercontinent(on_cont, tail(touching, n=1)[[1]])], "&")[[1]])#
                    dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    if (length(friends) > 1) {#
                    	all_dist <- vector(length = length(friends))#
                    	for (g in 1:length(friends)) {#
                    		all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    	}#
                    	while (min(all_dist) > radius) {#
                    		moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		temp_all_dist <- vector(length = length(friends))#
                    		for (g in 1:length(friends)) {#
                    			temp_all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    		}#
                    		all_dist <- temp_all_dist#
                    	}#
                    	new_cont <- friends[which(all_dist == min(all_dist))] #
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                    	rownames(organism_long_matrix)[m] <- new_cont#
                    	rownames(organism_lat_matrix)[m] <- new_cont#
                    	if(new_cont != on_cont) {#
                    		dispersals <- rbind(dispersals, c(on_cont, new_cont, m, t, ot+1))#
                    	}#
                    } else {#
                    	while (dist_from_center >= radius) {#
                    		moveto <- EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    	}#
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                	}#
                }#
            }#
#
            r <- runif(1)#
            if (r <= b/(b + d)) { ###4 #this creates a bifucation in the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                e <- matrix(edge[alive,], ncol = 2)#
                parent <- e[random_lineage,2]#
                x <- which(edge[,2] == parent)#
                new.rows.lat <- new.rows.long <- extra.rows#
                new.rows.lat[, ot+1] <- organism_lat_matrix[x, ot+1] #updates the long and lat matricies with new coordiantes for each lineage#
                new.rows.long[, ot+1] <- organism_long_matrix[x, ot+1]#
                rownames(new.rows.lat) <- rep(rownames(organism_lat_matrix)[x],2)#
                rownames(new.rows.long) <- rep(rownames(organism_long_matrix)[x],2)#
                organism_lat_matrix <- rbind(organism_lat_matrix,new.rows.lat)#
                organism_long_matrix <- rbind(organism_long_matrix,new.rows.long)#
                alive[alive][random_lineage] <- FALSE#
                edge <- rbind(edge, c(parent, next.node), c(parent, next.node + 1))#
                next.node <- next.node + 2#
                alive <- c(alive, TRUE, TRUE)#
                stem.depth <- c(stem.depth, ot, ot)#
                edge.length[x] <- ot - stem.depth[x]#
                edge.length<-c(edge.length, NA, NA)#
            } else {###4 This terminates one of the current lineages on the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                edge.length[alive][random_lineage] <- ot - stem.depth[alive][random_lineage]#
                alive[alive][random_lineage] <- FALSE#
            }###4#
        }#1A#
        if (any(progress == t)) {#
        	cat("- ")#
        }#
    }#
#
    #Things to do right at the end to turn it into a phylo object#
    edge.length[alive] <- ot - stem.depth[alive];#
    n <- -1#
    for (f in 1:max(edge)) {#
        if (any(edge[,1] == f)) {#
           	edge[which(edge[,1] == f), 1] <- n#
           	edge[which(edge[,2] == f), 2] <- n#
           	n <- n - 1;#
        }#
    }#
    edge[edge > 0] <- 1:sum(edge > 0)#
   	tip.label <- 1:sum(edge > 0)#
    mode(edge) <- "character"#
    mode(tip.label) <- "character"#
    obj <- list(edge = edge, edge.length = edge.length, tip.label=tip.label)#
    class(obj) <- "phylo"#
    obj <- old2new.phylo(obj)#
    obj$tip.label = paste("s", 1:Ntip(obj), sep = "")#
	# Add final time step to continental configurations:#
	names(linked)[length(linked)] <- paste(strsplit(names(linked)[length(linked)], ":")[[1]][1], ":", t, sep="")#
	output <- list(position, linked, touching, obj, organism_long_matrix, organism_lat_matrix)#
	names(output) <- c("continent_positions", "continent_clusters", "continent_overlaps", "tree", "organism_longitudes", "organism_latitudes")
# Subfunction to find out which supercontinent a circle belongs to:#
	which_supercontinent <- function(cont, sprconts){#
		cont <- as.character(cont)#
		result <- which(unlist(lapply(lapply(lapply(strsplit(sprconts, "&"), match, cont), sort), length)) == 1)#
		return(result)#
	}#
	# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)#
# Are any continents joined at start?:#
#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
#
	# Get list of separate continents:#
	separate_continents <- HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
#
	# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
	touching_continents <- HowManySeparateContinents((radius * 2), continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
# Assign Euler poles to each separate continent:#
	# Randomly draw longitudes for each separated continent:#
	euler_pole_longitudes <- runif(length(separate_continents), -180, 180)#
	# Randomly draw latitudes for each separated continent:#
	euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
	# Ensure no latitude is directly at a pole (North or South) by redrawing if any are found:#
	if((sum(euler_pole_latitudes == 90) + sum(euler_pole_latitudes == -90)) > 0) euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
#
# Assign speeds to each separate continent:#
	# Create empty vector to store degrees per step (effectively the speed of movement) for each continent:#
	degrees_per_step <- vector(mode="numeric")#
	# For each separate continent:#
	for(i in 1:length(separate_continents)) {#
		# Get Greate Circle distances from Euler pole to each continent centre:#
		euler_GC_distances <- One2ManyGreatCircleDistance(euler_pole_longitudes[i], euler_pole_latitudes[i], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Longitude"], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Latitude"])#
		# Find GC distance to furthest continent (closest to euler pole "equator") in cluster (as speed will be assigned based on this):#
		furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
		# Randomly draw a continent speed:#
		continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# If a negative or zero speed is picked then redraw:#
		while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# Set degree change per step (effectively the speed):#
		degrees_per_step[i] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
	}#
#
	#starting information for the tree#
	dispersals <- matrix(nrow=0, ncol=5)#
	begin_cont <- ceiling(runif(1, 0, N_continents))#
	life_begins <- EndPoint(continent_starting_points[begin_cont, "Longitude"], continent_starting_points[begin_cont, "Latitude"], runif(1,0,360), runif(1,0,radius))#
	extra.rows <- matrix(NA,nrow=2,ncol= (N_steps * organism_multiplier) + 1)#
	organism_lat_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_long_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_lat_matrix[,1] <- life_begins$lat#
    organism_long_matrix[,1] <- life_begins$lon#
    rownames(organism_lat_matrix) <- rep(begin_cont, 2)#
    rownames(organism_long_matrix) <- rep(begin_cont, 2)#
    edge <- rbind(c(1, 2), c(1, 3)) # this is a starting edge matrix#
    edge.length <- rep(NA, 2)#
    stem.depth <- numeric(2)#
    alive <- rep(TRUE, 2) # marker for live lineages#
    ot <- 0; # time(step) at any point in the tree#
    next.node <- 4#
#
	# Now need to move them!#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	linked <- list()#
	linked[[1]] <- separate_continents#
	names(linked)[[1]] <- "1:1"#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	touching <- list()#
	touching[[1]] <- touching_continents#
#
	#Array to store the positions of every continent at each time step#
	position <- array(NA, c(N_continents, N_steps + 1, 2), c("continent", "timestep", "coordinate"))#
	position[,1,1] <- continent_starting_points[,"Longitude"]#
	position[,1,2] <- continent_starting_points[,"Latitude"]#
#
	temp_position<-matrix(nrow = N_continents, ncol=2)#
#
	progress <- seq(1, N_steps, floor(N_steps/50))#
	cat("Starting time steps \n")#
	cat("Progress \n")#
	cat("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n")#
#
	#for loops to move everything#
	for (t in 2:(N_steps + 1)) {#
		#distances apart before they move#
		starting_distances <- GreatCircleDistanceMatrix(position[,t-1,1], position[,t-1,2])#
#
		for (k in 1:N_continents) {#
			#find current longlat of the circle k#
			start_long <- position[k, t-1, 1]#
			start_lat <- position[k, t-1, 2]#
#
			#Identify which supercontinent, and therefore which element of the euler pole and speed vectors, the circle k belongs to#
			where <- which_supercontinent(k, tail(linked, n=1)[[1]])#
#
			#Find distance of circle from pole#
			distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where], lat2=euler_pole_latitudes[where], Warn = FALSE)#
			#Find bearing of circle from pole#
			init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where], euler_pole_latitudes[where], start_long, start_lat)#
#
			#Find the new bearing of circle from pole according to the speed specified#
			new_bearing <- (init_bearing + degrees_per_step[where]) %% 360#
#
			#Find the new location of the circle#
			new_loc <- EndPoint(euler_pole_longitudes[where], euler_pole_latitudes[where], new_bearing, distance)#
#
			#Add the new loction to the position matrix#
			temp_position[k,1] <- new_loc$long#
			temp_position[k,2] <- new_loc$lat#
#
		}#
#
		#Matrix of the distances between each continent in their new positions, before these are set#
		new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
		comp1 <- vector()#
		comp2 <- vector()#
#
		#Making a vector of whether any continents have collided and should be linked#
		collisions<-matrix(nrow=0, ncol=2)#
		for (q in 1:(N_continents-1)) {#
			for (p in (q+1):N_continents) {#
				comp1 <- all.equal(new_distances[p,q],starting_distances[p,q])#
				comp2 <- new_distances[p,q] <= min_separation#
				if (comp1 != TRUE && comp2 == TRUE) {#
					collisions<-rbind(collisions,c(p,q))#
				}#
			}#
		}#
#
		#Matrix of euler poles and speeds for each individual continent for moving the animals later#
		organism_mover <- matrix(nrow=N_continents, ncol= 3)#
		for (clump in 1:length(tail(linked, n=1)[[1]])) {#
			which_conts <- as.numeric(strsplit(tail(linked, n=1)[[1]][[clump]], "&")[[1]])#
			organism_mover[which_conts,1] <- rep(euler_pole_longitudes[clump],length(which_conts))#
			organism_mover[which_conts,2] <- rep(euler_pole_latitudes[clump],length(which_conts))#
			#This bit will get overwritten if there are collisions#
			organism_mover[which_conts,3] <- rep(degrees_per_step[clump],length(which_conts))#
		}#
		perm_collisions <- matrix(nrow=0, ncol=2)#
#
		# Moving continents back if there has only been one collision#
		while(nrow(collisions) > 0) {#
#
			# Set up vector to store proportional changes after collisions#
			proportion <- vector()#
#
			# Find out proportions to reduce to for all potential collisions#
			for (coll in 1:nrow(collisions)) {#
				cont_1 <- collisions[coll,1]#
				cont_2 <- collisions[coll,2]#
				where_1 <- which_supercontinent(cont_1, tail(linked, n=1)[[1]])#
				where_2 <- which_supercontinent(cont_2, tail(linked, n=1)[[1]])#
				continent_1_euler_longitude = euler_pole_longitudes[where_1]#
				continent_1_euler_latitude = euler_pole_latitudes[where_1]#
				continent_2_euler_longitude = euler_pole_longitudes[where_2]#
				continent_2_euler_latitude = euler_pole_latitudes[where_2]#
				continent_1_degrees_per_step = degrees_per_step[where_1]#
				continent_2_degrees_per_step = degrees_per_step[where_2]#
				proportion[coll] <- ColliderReverser(min_separation, position[cont_1, t-1, 1], position[cont_1, t-1, 2], temp_position[cont_1,1], temp_position[cont_1,2], position[cont_2, t-1, 1], position[cont_2, t-1, 2], temp_position[cont_2,1], temp_position[cont_2,2], continent_1_euler_longitude, continent_1_euler_latitude, continent_2_euler_longitude, continent_2_euler_latitude, continent_1_degrees_per_step, continent_2_degrees_per_step, EarthRad = 6367.4447, Warn = FALSE)#
			}#
#
			# Select proportion to move for first collision#
			first_collision <- match(min(proportion),proportion)#
#
			# Find the two continents that collided first#
			cont_involved <- sort(collisions[first_collision, ])#
#
			# Add to matrix of definite collisions that cannot be separated in the next step#
			perm_collisions <- rbind(perm_collisions, cont_involved)#
#
			# Move first clump back#
			head_of_collision_1 <- cont_involved[1]#
			where_1 <- which_supercontinent(head_of_collision_1, tail(linked, n=1)[[1]])#
#
			#Find the other continents that were attached to the collider#
			all_involved <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_1], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents in one of the clumps#
			for (rev in 1:length(all_involved)) {#
				cont_to_rev <- all_involved[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_1], lat2=euler_pole_latitudes[where_1], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], start_long, start_lat)#
#
				#degrees to add#
				addition <- proportion[first_collision] * degrees_per_step[where_1]#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <- (init_bearing + addition) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
#
				organism_mover[cont_to_rev,3] <- addition#
			}#
#
			#Move the second clump back#
			head_of_collision_2 <- cont_involved[2]#
			where_2 <- which_supercontinent(head_of_collision_2, tail(linked, n=1)[[1]])#
			all_involved_2 <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_2], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents the other clump#
			for (rev in 1:length(all_involved_2)) {#
				cont_to_rev <- all_involved_2[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_2], lat2=euler_pole_latitudes[where_2], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], start_long, start_lat)#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <-  (init_bearing + (proportion[first_collision] * degrees_per_step[where_2])) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
			}#
#
			#Recalculate the new distances#
			new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
			comp1 <- vector()#
			comp2 <- vector()#
#
			# Check whether any other collisions have still occurred#
			collisions <- matrix(nrow=0, ncol=2)#
			for (q in 1:(N_continents - 1)) {#
				for (p in (q+1):N_continents) {#
					comp1 <- all.equal(new_distances[p, q], starting_distances[p, q])#
					comp2 <- new_distances[p, q] <= min_separation#
					if (comp1 != TRUE && comp2 == TRUE) {#
						# If collision has not already been recorded:#
						if(length(sort(match(paste(sort(c(q, p)), collapse=""), apply(perm_collisions, 1, paste, collapse="")))) == 0) {#
							# Record collision:#
							collisions <- rbind(collisions, c(p, q))#
						}#
					}#
				}#
			}#
		}#
#
		# When it finishes while loop can now 'ossify' the positions and move to selecting separations#
		position[, t, 1] <- temp_position[, 1]#
		position[, t, 2] <- temp_position[, 2]#
#
# Finding out if anything gets separated#
		# How many separate continents are there now? (after collisions may have occurred):#
		separate_continents <- HowManySeparateContinents(min_separation, position[,t,1], position[,t,2])#
		# Make random uniform draws for each continental cluster:#
		separation_draws <- runif(length(grep("&", separate_continents)))#
		# Case if a separation occurs (drawn value is equal to or exceeds stickiness):#
		if(any(separation_draws >= stickiness)) {#
			# Get clusters of continents to split apart:#
			clusters_to_split <- separate_continents[grep("&", separate_continents)][which(separation_draws >= stickiness)]#
			# For each cluster to split apart:#
			for(i in 1:length(clusters_to_split)) {#
				# Get numbers of continents involved:#
				cluster_continent_numbers <- sort(strsplit(clusters_to_split[i], "&")[[1]])#
				# Get longitudes of continents in cluster:#
				cluster_longitudes <- position[as.numeric(cluster_continent_numbers), t, 1]#
#
				# Get latitudes of continents in cluster:#
				cluster_latitudes <- position[as.numeric(cluster_continent_numbers), t, 2]#
				# Make protected links an empty matrix:#
				cluster_protected_links <- matrix(nrow = 0, ncol = 2)#
				# If there are recent collisions (that will potentially need to be excluded from new splits):#
				if(length(perm_collisions) > 0) {#
					# For each new collision:#
					for(j in 1:nrow(perm_collisions)) {#
						# If new collision occurs within the cluster:#
						if(length(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers)) == 2) {#
							# Add new collision to protected links list:#
							cluster_protected_links <- rbind(cluster_protected_links, perm_collisions[j, ])#
						}#
					}#
#
				}#
				# Get splits (new clusters) of separated cluster:#
				splits <- ContinentSplitter(min_separation, cluster_longitudes, cluster_latitudes, cluster_continent_numbers, cluster_protected_links, EarthRad)#
				# Update separate continents vector:#
				separate_continents <- sort(c(separate_continents[-match(clusters_to_split[i], separate_continents)], splits))#
			}#
		}#
#
# Now change the Euler poles and speeds#
		# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
		touching_continents <- HowManySeparateContinents((radius * 2), position[,t,1], position[,t,2])#
		if (paste(sort(touching_continents), collapse="") != paste(sort(tail(touching,n=1)[[1]]), collapse="")) {#
			touching <- c(touching, list(touching_continents))#
		}#
#
		# If the continental clustering has changed:#
		if (paste(sort(separate_continents), collapse="") != paste(sort(tail(linked,n=1)[[1]]), collapse="")) {#
			# Add new continental configuration to linked list#
			linked <- c(linked, list(separate_continents))#
#
			# Update time step for previous continental configuration:#
			names(linked)[(length(linked) - 1)] <- paste(strsplit(names(linked[(length(linked) - 1)]), ":")[[1]][1], ":", t - 1, sep="")#
			# Add time step to new continental configuration:#
			names(linked)[length(linked)] <- paste(t, ":", t, sep="")#
			# Select continents that are different to previous time step#
			toKeep <- c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]])[duplicated(c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]]))]#
#
			#Vectors for new poles and speeds#
			new_euler_latitudes <- rep(NA, length(separate_continents))#
			new_euler_longitudes <- rep(NA, length(separate_continents))#
			new_degrees_per_step <- rep(NA, length(separate_continents))#
#
			if (length(toKeep) != 0){#
				#Inherit previous poles and speeds for those clumps that remain the same#
				for (y in 1:length(toKeep)) {#
					new_euler_longitudes[match(toKeep[y],separate_continents)]<- euler_pole_longitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_euler_latitudes[match(toKeep[y],separate_continents)]<- euler_pole_latitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_degrees_per_step[match(toKeep[y],separate_continents)]<- degrees_per_step[match(toKeep[y],tail(linked, n=2)[[1]])]#
				}#
			}#
#
			# Make new Euler poles#
			new_euler_longitudes[is.na(new_euler_longitudes)]<- runif((length(separate_continents)-length(toKeep)), -180, 180)#
#
			changed_euler_latitudes<- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			while((sum(changed_euler_latitudes == 90) + sum(changed_euler_latitudes == -90)) > 0) changed_euler_latitudes <- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			new_euler_latitudes[is.na(new_euler_latitudes)] <- changed_euler_latitudes#
#
			# Get Great Circle distances from Euler pole to each continent centre:#
			for (l in 1:(length(separate_continents)-length(toKeep))) {#
				# Find the first NA to fill in:#
				changer <- match(NA, new_degrees_per_step)#
				#Find the contients that are in the clump whose speed is going to change#
				rows <- as.numeric(unlist(strsplit(separate_continents[changer], "&")))#
				#Find the new euler pole for that clump#
				euler_long <- new_euler_longitudes[changer]#
				euler_lat <- new_euler_latitudes[changer]#
				#Find the distances of each of the continents in the clump from their new euler pole#
				euler_GC_distances <- One2ManyGreatCircleDistance(euler_long, euler_lat, position[rows, t, 1], position[rows, t, 2])#
				#Find which of those is closest to the equator#
				furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
				# Randomly draw a continent speed:#
				continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# If a negative or zero speed is picked then redraw:#
				while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# Set degree change per step (effectively the speed):#
				new_degrees_per_step[changer] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
			}#
			euler_pole_longitudes <- new_euler_longitudes#
			euler_pole_latitudes <- new_euler_latitudes#
			degrees_per_step <- new_degrees_per_step#
		}#
#
#Need to add in the tree bit#
		#Move the animals with the continents#
		for (cont in 1:N_continents) {#
			#Find the rows that are in the continent of focus#
			moving <- which(rownames(organism_long_matrix)==cont)#
#
			if (length(moving)==0) {#
				next #
			} else {#
				#Find out how many degrees around the euler pole that continent went#
				organism_degrees <- organism_mover[cont,3]#
				#loops through all the organisms that are currently living#
				for (organism in 1:length(moving)) {#
					organism_row <- moving[organism]#
					if (is.na(organism_long_matrix[organism_row, ot + 1])) {#
						next#
					} else {#
						first_long <- organism_long_matrix[organism_row, ot + 1]#
						first_lat <- organism_lat_matrix[organism_row, ot + 1]#
						organism_distance <- GreatCircleDistanceFromLongLat(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						organism_bearing <- BearingBetweenTwoLongLatPoints(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						new_organism_bearing <- (organism_bearing + organism_degrees) %% 360#
						new_organism_loc <- EndPoint(organism_mover[cont,1], organism_mover[cont,2], new_organism_bearing, organism_distance)#
						organism_long_matrix[organism_row, ot + 1] <- new_organism_loc$long#
    					organism_lat_matrix[organism_row, ot + 1] <- new_organism_loc$lat#
					}#
				}#
			}#
		}#
		for (f in 1:organism_multiplier) {#
            if (sum(alive) == 0) stop("METEOR IMPACT!! EVERYTHING HAS GONE EXTINCT! AAAAHHHHHH!!!")#
            dt<-1#
            ot <- ot + dt#
            for (m in 1:nrow(organism_lat_matrix)) {#
                if (alive[m]) {#
                    starting<-c(organism_lat_matrix[m,ot],organism_long_matrix[m,ot])#
                    moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd))) #generates a random walk step and calculates new position#
                    on_cont <- as.numeric(rownames(organism_lat_matrix)[m])#
                    friends <- as.numeric(strsplit(tail(touching, n=1)[[1]][which_supercontinent(on_cont, tail(touching, n=1)[[1]])], "&")[[1]])#
                    dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    if (length(friends) > 1) {#
                    	all_dist <- vector(length = length(friends))#
                    	for (g in 1:length(friends)) {#
                    		all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    	}#
                    	while (min(all_dist) > radius) {#
                    		moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		temp_all_dist <- vector(length = length(friends))#
                    		for (g in 1:length(friends)) {#
                    			temp_all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    		}#
                    		all_dist <- temp_all_dist#
                    	}#
                    	new_cont <- friends[which(all_dist == min(all_dist))] #
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                    	rownames(organism_long_matrix)[m] <- new_cont#
                    	rownames(organism_lat_matrix)[m] <- new_cont#
                    	if(new_cont != on_cont) {#
                    		dispersals <- rbind(dispersals, c(on_cont, new_cont, m, t, ot+1))#
                    	}#
                    } else {#
                    	while (dist_from_center >= radius) {#
                    		moveto <- EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    	}#
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                	}#
                }#
            }#
#
            r <- runif(1)#
            if (r <= b/(b + d)) { ###4 #this creates a bifucation in the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                e <- matrix(edge[alive,], ncol = 2)#
                parent <- e[random_lineage,2]#
                x <- which(edge[,2] == parent)#
                new.rows.lat <- new.rows.long <- extra.rows#
                new.rows.lat[, ot+1] <- organism_lat_matrix[x, ot+1] #updates the long and lat matricies with new coordiantes for each lineage#
                new.rows.long[, ot+1] <- organism_long_matrix[x, ot+1]#
                rownames(new.rows.lat) <- rep(rownames(organism_lat_matrix)[x],2)#
                rownames(new.rows.long) <- rep(rownames(organism_long_matrix)[x],2)#
                organism_lat_matrix <- rbind(organism_lat_matrix,new.rows.lat)#
                organism_long_matrix <- rbind(organism_long_matrix,new.rows.long)#
                alive[alive][random_lineage] <- FALSE#
                edge <- rbind(edge, c(parent, next.node), c(parent, next.node + 1))#
                next.node <- next.node + 2#
                alive <- c(alive, TRUE, TRUE)#
                stem.depth <- c(stem.depth, ot, ot)#
                edge.length[x] <- ot - stem.depth[x]#
                edge.length<-c(edge.length, NA, NA)#
            } else {###4 This terminates one of the current lineages on the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                edge.length[alive][random_lineage] <- ot - stem.depth[alive][random_lineage]#
                alive[alive][random_lineage] <- FALSE#
            }###4#
        }#1A#
        if (any(progress == t)) {#
        	cat("- ")#
        }#
    }#
#
    #Things to do right at the end to turn it into a phylo object#
    edge.length[alive] <- ot - stem.depth[alive];#
    n <- -1#
    for (f in 1:max(edge)) {#
        if (any(edge[,1] == f)) {#
           	edge[which(edge[,1] == f), 1] <- n#
           	edge[which(edge[,2] == f), 2] <- n#
           	n <- n - 1;#
        }#
    }#
    edge[edge > 0] <- 1:sum(edge > 0)#
   	tip.label <- 1:sum(edge > 0)#
    mode(edge) <- "character"#
    mode(tip.label) <- "character"#
    obj <- list(edge = edge, edge.length = edge.length, tip.label=tip.label)#
    class(obj) <- "phylo"#
    obj <- old2new.phylo(obj)#
    obj$tip.label = paste("s", 1:Ntip(obj), sep = "")#
	# Add final time step to continental configurations:#
	names(linked)[length(linked)] <- paste(strsplit(names(linked)[length(linked)], ":")[[1]][1], ":", t, sep="")#
	output <- list(position, linked, touching, obj, organism_long_matrix, organism_lat_matrix)#
	names(output) <- c("continent_positions", "continent_clusters", "continent_overlaps", "tree", "organism_longitudes", "organism_latitudes")
# Subfunction to find out which supercontinent a circle belongs to:#
	which_supercontinent <- function(cont, sprconts){#
		cont <- as.character(cont)#
		result <- which(unlist(lapply(lapply(lapply(strsplit(sprconts, "&"), match, cont), sort), length)) == 1)#
		return(result)#
	}#
	# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)#
# Are any continents joined at start?:#
#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
#
	# Get list of separate continents:#
	separate_continents <- HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
#
	# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
	touching_continents <- HowManySeparateContinents((radius * 2), continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
# Assign Euler poles to each separate continent:#
	# Randomly draw longitudes for each separated continent:#
	euler_pole_longitudes <- runif(length(separate_continents), -180, 180)#
	# Randomly draw latitudes for each separated continent:#
	euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
	# Ensure no latitude is directly at a pole (North or South) by redrawing if any are found:#
	if((sum(euler_pole_latitudes == 90) + sum(euler_pole_latitudes == -90)) > 0) euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
#
# Assign speeds to each separate continent:#
	# Create empty vector to store degrees per step (effectively the speed of movement) for each continent:#
	degrees_per_step <- vector(mode="numeric")#
	# For each separate continent:#
	for(i in 1:length(separate_continents)) {#
		# Get Greate Circle distances from Euler pole to each continent centre:#
		euler_GC_distances <- One2ManyGreatCircleDistance(euler_pole_longitudes[i], euler_pole_latitudes[i], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Longitude"], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Latitude"])#
		# Find GC distance to furthest continent (closest to euler pole "equator") in cluster (as speed will be assigned based on this):#
		furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
		# Randomly draw a continent speed:#
		continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# If a negative or zero speed is picked then redraw:#
		while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# Set degree change per step (effectively the speed):#
		degrees_per_step[i] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
	}#
#
	#starting information for the tree#
	dispersals <- matrix(nrow=0, ncol=5)#
	begin_cont <- ceiling(runif(1, 0, N_continents))#
	life_begins <- EndPoint(continent_starting_points[begin_cont, "Longitude"], continent_starting_points[begin_cont, "Latitude"], runif(1,0,360), runif(1,0,radius))#
	extra.rows <- matrix(NA,nrow=2,ncol= (N_steps * organism_multiplier) + 1)#
	organism_lat_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_long_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_lat_matrix[,1] <- life_begins$lat#
    organism_long_matrix[,1] <- life_begins$lon#
    rownames(organism_lat_matrix) <- rep(begin_cont, 2)#
    rownames(organism_long_matrix) <- rep(begin_cont, 2)#
    edge <- rbind(c(1, 2), c(1, 3)) # this is a starting edge matrix#
    edge.length <- rep(NA, 2)#
    stem.depth <- numeric(2)#
    alive <- rep(TRUE, 2) # marker for live lineages#
    ot <- 0; # time(step) at any point in the tree#
    next.node <- 4#
#
	# Now need to move them!#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	linked <- list()#
	linked[[1]] <- separate_continents#
	names(linked)[[1]] <- "1:1"#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	touching <- list()#
	touching[[1]] <- touching_continents#
#
	#Array to store the positions of every continent at each time step#
	position <- array(NA, c(N_continents, N_steps + 1, 2), c("continent", "timestep", "coordinate"))#
	position[,1,1] <- continent_starting_points[,"Longitude"]#
	position[,1,2] <- continent_starting_points[,"Latitude"]#
#
	temp_position<-matrix(nrow = N_continents, ncol=2)#
#
	progress <- seq(1, N_steps, floor(N_steps/50))#
	cat("Starting time steps \n")#
	cat("Progress \n")#
	cat("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n")#
#
	#for loops to move everything#
	for (t in 2:(N_steps + 1)) {#
		#distances apart before they move#
		starting_distances <- GreatCircleDistanceMatrix(position[,t-1,1], position[,t-1,2])#
#
		for (k in 1:N_continents) {#
			#find current longlat of the circle k#
			start_long <- position[k, t-1, 1]#
			start_lat <- position[k, t-1, 2]#
#
			#Identify which supercontinent, and therefore which element of the euler pole and speed vectors, the circle k belongs to#
			where <- which_supercontinent(k, tail(linked, n=1)[[1]])#
#
			#Find distance of circle from pole#
			distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where], lat2=euler_pole_latitudes[where], Warn = FALSE)#
			#Find bearing of circle from pole#
			init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where], euler_pole_latitudes[where], start_long, start_lat)#
#
			#Find the new bearing of circle from pole according to the speed specified#
			new_bearing <- (init_bearing + degrees_per_step[where]) %% 360#
#
			#Find the new location of the circle#
			new_loc <- EndPoint(euler_pole_longitudes[where], euler_pole_latitudes[where], new_bearing, distance)#
#
			#Add the new loction to the position matrix#
			temp_position[k,1] <- new_loc$long#
			temp_position[k,2] <- new_loc$lat#
#
		}#
#
		#Matrix of the distances between each continent in their new positions, before these are set#
		new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
		comp1 <- vector()#
		comp2 <- vector()#
#
		#Making a vector of whether any continents have collided and should be linked#
		collisions<-matrix(nrow=0, ncol=2)#
		for (q in 1:(N_continents-1)) {#
			for (p in (q+1):N_continents) {#
				comp1 <- all.equal(new_distances[p,q],starting_distances[p,q])#
				comp2 <- new_distances[p,q] <= min_separation#
				if (comp1 != TRUE && comp2 == TRUE) {#
					collisions<-rbind(collisions,c(p,q))#
				}#
			}#
		}#
#
		#Matrix of euler poles and speeds for each individual continent for moving the animals later#
		organism_mover <- matrix(nrow=N_continents, ncol= 3)#
		for (clump in 1:length(tail(linked, n=1)[[1]])) {#
			which_conts <- as.numeric(strsplit(tail(linked, n=1)[[1]][[clump]], "&")[[1]])#
			organism_mover[which_conts,1] <- rep(euler_pole_longitudes[clump],length(which_conts))#
			organism_mover[which_conts,2] <- rep(euler_pole_latitudes[clump],length(which_conts))#
			#This bit will get overwritten if there are collisions#
			organism_mover[which_conts,3] <- rep(degrees_per_step[clump],length(which_conts))#
		}#
		perm_collisions <- matrix(nrow=0, ncol=2)#
#
		# Moving continents back if there has only been one collision#
		while(nrow(collisions) > 0) {#
#
			# Set up vector to store proportional changes after collisions#
			proportion <- vector()#
#
			# Find out proportions to reduce to for all potential collisions#
			for (coll in 1:nrow(collisions)) {#
				cont_1 <- collisions[coll,1]#
				cont_2 <- collisions[coll,2]#
				where_1 <- which_supercontinent(cont_1, tail(linked, n=1)[[1]])#
				where_2 <- which_supercontinent(cont_2, tail(linked, n=1)[[1]])#
				continent_1_euler_longitude = euler_pole_longitudes[where_1]#
				continent_1_euler_latitude = euler_pole_latitudes[where_1]#
				continent_2_euler_longitude = euler_pole_longitudes[where_2]#
				continent_2_euler_latitude = euler_pole_latitudes[where_2]#
				continent_1_degrees_per_step = degrees_per_step[where_1]#
				continent_2_degrees_per_step = degrees_per_step[where_2]#
				proportion[coll] <- ColliderReverser(min_separation, position[cont_1, t-1, 1], position[cont_1, t-1, 2], temp_position[cont_1,1], temp_position[cont_1,2], position[cont_2, t-1, 1], position[cont_2, t-1, 2], temp_position[cont_2,1], temp_position[cont_2,2], continent_1_euler_longitude, continent_1_euler_latitude, continent_2_euler_longitude, continent_2_euler_latitude, continent_1_degrees_per_step, continent_2_degrees_per_step, EarthRad = 6367.4447, Warn = FALSE)#
			}#
#
			# Select proportion to move for first collision#
			first_collision <- match(min(proportion),proportion)#
#
			# Find the two continents that collided first#
			cont_involved <- sort(collisions[first_collision, ])#
#
			# Add to matrix of definite collisions that cannot be separated in the next step#
			perm_collisions <- rbind(perm_collisions, cont_involved)#
#
			# Move first clump back#
			head_of_collision_1 <- cont_involved[1]#
			where_1 <- which_supercontinent(head_of_collision_1, tail(linked, n=1)[[1]])#
#
			#Find the other continents that were attached to the collider#
			all_involved <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_1], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents in one of the clumps#
			for (rev in 1:length(all_involved)) {#
				cont_to_rev <- all_involved[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_1], lat2=euler_pole_latitudes[where_1], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], start_long, start_lat)#
#
				#degrees to add#
				addition <- proportion[first_collision] * degrees_per_step[where_1]#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <- (init_bearing + addition) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
#
				organism_mover[cont_to_rev,3] <- addition#
			}#
#
			#Move the second clump back#
			head_of_collision_2 <- cont_involved[2]#
			where_2 <- which_supercontinent(head_of_collision_2, tail(linked, n=1)[[1]])#
			all_involved_2 <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_2], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents the other clump#
			for (rev in 1:length(all_involved_2)) {#
				cont_to_rev <- all_involved_2[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_2], lat2=euler_pole_latitudes[where_2], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], start_long, start_lat)#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <-  (init_bearing + (proportion[first_collision] * degrees_per_step[where_2])) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
			}#
#
			#Recalculate the new distances#
			new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
			comp1 <- vector()#
			comp2 <- vector()#
#
			# Check whether any other collisions have still occurred#
			collisions <- matrix(nrow=0, ncol=2)#
			for (q in 1:(N_continents - 1)) {#
				for (p in (q+1):N_continents) {#
					comp1 <- all.equal(new_distances[p, q], starting_distances[p, q])#
					comp2 <- new_distances[p, q] <= min_separation#
					if (comp1 != TRUE && comp2 == TRUE) {#
						# If collision has not already been recorded:#
						if(length(sort(match(paste(sort(c(q, p)), collapse=""), apply(perm_collisions, 1, paste, collapse="")))) == 0) {#
							# Record collision:#
							collisions <- rbind(collisions, c(p, q))#
						}#
					}#
				}#
			}#
		}#
#
		# When it finishes while loop can now 'ossify' the positions and move to selecting separations#
		position[, t, 1] <- temp_position[, 1]#
		position[, t, 2] <- temp_position[, 2]#
#
# Finding out if anything gets separated#
		# How many separate continents are there now? (after collisions may have occurred):#
		separate_continents <- HowManySeparateContinents(min_separation, position[,t,1], position[,t,2])#
		# Make random uniform draws for each continental cluster:#
		separation_draws <- runif(length(grep("&", separate_continents)))#
		# Case if a separation occurs (drawn value is equal to or exceeds stickiness):#
		if(any(separation_draws >= stickiness)) {#
			# Get clusters of continents to split apart:#
			clusters_to_split <- separate_continents[grep("&", separate_continents)][which(separation_draws >= stickiness)]#
			# For each cluster to split apart:#
			for(i in 1:length(clusters_to_split)) {#
				# Get numbers of continents involved:#
				cluster_continent_numbers <- sort(strsplit(clusters_to_split[i], "&")[[1]])#
				# Get longitudes of continents in cluster:#
				cluster_longitudes <- position[as.numeric(cluster_continent_numbers), t, 1]#
#
				# Get latitudes of continents in cluster:#
				cluster_latitudes <- position[as.numeric(cluster_continent_numbers), t, 2]#
				# Make protected links an empty matrix:#
				cluster_protected_links <- matrix(nrow = 0, ncol = 2)#
				# If there are recent collisions (that will potentially need to be excluded from new splits):#
				if(length(perm_collisions) > 0) {#
					# For each new collision:#
					for(j in 1:nrow(perm_collisions)) {#
						# If new collision occurs within the cluster:#
						if(length(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers)) == 2) {#
							# Add new collision to protected links list:#
							cluster_protected_links <- rbind(cluster_protected_links, perm_collisions[j, ])#
						}#
					}#
#
				}#
				# Get splits (new clusters) of separated cluster:#
				splits <- ContinentSplitter(min_separation, cluster_longitudes, cluster_latitudes, cluster_continent_numbers, cluster_protected_links, EarthRad)#
				# Update separate continents vector:#
				separate_continents <- sort(c(separate_continents[-match(clusters_to_split[i], separate_continents)], splits))#
			}#
		}#
#
# Now change the Euler poles and speeds#
		# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
		touching_continents <- HowManySeparateContinents((radius * 2), position[,t,1], position[,t,2])#
		if (paste(sort(touching_continents), collapse="") != paste(sort(tail(touching,n=1)[[1]]), collapse="")) {#
			touching <- c(touching, list(touching_continents))#
		}#
#
		# If the continental clustering has changed:#
		if (paste(sort(separate_continents), collapse="") != paste(sort(tail(linked,n=1)[[1]]), collapse="")) {#
			# Add new continental configuration to linked list#
			linked <- c(linked, list(separate_continents))#
#
			# Update time step for previous continental configuration:#
			names(linked)[(length(linked) - 1)] <- paste(strsplit(names(linked[(length(linked) - 1)]), ":")[[1]][1], ":", t - 1, sep="")#
			# Add time step to new continental configuration:#
			names(linked)[length(linked)] <- paste(t, ":", t, sep="")#
			# Select continents that are different to previous time step#
			toKeep <- c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]])[duplicated(c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]]))]#
#
			#Vectors for new poles and speeds#
			new_euler_latitudes <- rep(NA, length(separate_continents))#
			new_euler_longitudes <- rep(NA, length(separate_continents))#
			new_degrees_per_step <- rep(NA, length(separate_continents))#
#
			if (length(toKeep) != 0){#
				#Inherit previous poles and speeds for those clumps that remain the same#
				for (y in 1:length(toKeep)) {#
					new_euler_longitudes[match(toKeep[y],separate_continents)]<- euler_pole_longitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_euler_latitudes[match(toKeep[y],separate_continents)]<- euler_pole_latitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_degrees_per_step[match(toKeep[y],separate_continents)]<- degrees_per_step[match(toKeep[y],tail(linked, n=2)[[1]])]#
				}#
			}#
#
			# Make new Euler poles#
			new_euler_longitudes[is.na(new_euler_longitudes)]<- runif((length(separate_continents)-length(toKeep)), -180, 180)#
#
			changed_euler_latitudes<- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			while((sum(changed_euler_latitudes == 90) + sum(changed_euler_latitudes == -90)) > 0) changed_euler_latitudes <- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			new_euler_latitudes[is.na(new_euler_latitudes)] <- changed_euler_latitudes#
#
			# Get Great Circle distances from Euler pole to each continent centre:#
			for (l in 1:(length(separate_continents)-length(toKeep))) {#
				# Find the first NA to fill in:#
				changer <- match(NA, new_degrees_per_step)#
				#Find the contients that are in the clump whose speed is going to change#
				rows <- as.numeric(unlist(strsplit(separate_continents[changer], "&")))#
				#Find the new euler pole for that clump#
				euler_long <- new_euler_longitudes[changer]#
				euler_lat <- new_euler_latitudes[changer]#
				#Find the distances of each of the continents in the clump from their new euler pole#
				euler_GC_distances <- One2ManyGreatCircleDistance(euler_long, euler_lat, position[rows, t, 1], position[rows, t, 2])#
				#Find which of those is closest to the equator#
				furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
				# Randomly draw a continent speed:#
				continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# If a negative or zero speed is picked then redraw:#
				while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# Set degree change per step (effectively the speed):#
				new_degrees_per_step[changer] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
			}#
			euler_pole_longitudes <- new_euler_longitudes#
			euler_pole_latitudes <- new_euler_latitudes#
			degrees_per_step <- new_degrees_per_step#
		}#
#
#Need to add in the tree bit#
		#Move the animals with the continents#
		for (cont in 1:N_continents) {#
			#Find the rows that are in the continent of focus#
			moving <- which(rownames(organism_long_matrix)==cont)#
#
			if (length(moving)==0) {#
				next #
			} else {#
				#Find out how many degrees around the euler pole that continent went#
				organism_degrees <- organism_mover[cont,3]#
				#loops through all the organisms that are currently living#
				for (organism in 1:length(moving)) {#
					organism_row <- moving[organism]#
					if (is.na(organism_long_matrix[organism_row, ot + 1])) {#
						next#
					} else {#
						first_long <- organism_long_matrix[organism_row, ot + 1]#
						first_lat <- organism_lat_matrix[organism_row, ot + 1]#
						organism_distance <- GreatCircleDistanceFromLongLat(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						organism_bearing <- BearingBetweenTwoLongLatPoints(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						new_organism_bearing <- (organism_bearing + organism_degrees) %% 360#
						new_organism_loc <- EndPoint(organism_mover[cont,1], organism_mover[cont,2], new_organism_bearing, organism_distance)#
						organism_long_matrix[organism_row, ot + 1] <- new_organism_loc$long#
    					organism_lat_matrix[organism_row, ot + 1] <- new_organism_loc$lat#
					}#
				}#
			}#
		}#
		for (f in 1:organism_multiplier) {#
            if (sum(alive) == 0) stop("METEOR IMPACT!! EVERYTHING HAS GONE EXTINCT! AAAAHHHHHH!!!")#
            dt<-1#
            ot <- ot + dt#
            for (m in 1:nrow(organism_lat_matrix)) {#
                if (alive[m]) {#
                    starting<-c(organism_lat_matrix[m,ot],organism_long_matrix[m,ot])#
                    moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd))) #generates a random walk step and calculates new position#
                    on_cont <- as.numeric(rownames(organism_lat_matrix)[m])#
                    friends <- as.numeric(strsplit(tail(touching, n=1)[[1]][which_supercontinent(on_cont, tail(touching, n=1)[[1]])], "&")[[1]])#
                    dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    if (length(friends) > 1) {#
                    	all_dist <- vector(length = length(friends))#
                    	for (g in 1:length(friends)) {#
                    		all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    	}#
                    	while (min(all_dist) > radius) {#
                    		moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		temp_all_dist <- vector(length = length(friends))#
                    		for (g in 1:length(friends)) {#
                    			temp_all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    		}#
                    		all_dist <- temp_all_dist#
                    	}#
                    	new_cont <- friends[which(all_dist == min(all_dist))] #
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                    	rownames(organism_long_matrix)[m] <- new_cont#
                    	rownames(organism_lat_matrix)[m] <- new_cont#
                    	if(new_cont != on_cont) {#
                    		dispersals <- rbind(dispersals, c(on_cont, new_cont, m, t, ot+1))#
                    	}#
                    } else {#
                    	while (dist_from_center >= radius) {#
                    		moveto <- EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    	}#
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                	}#
                }#
            }#
#
            r <- runif(1)#
            if (r <= b/(b + d)) { ###4 #this creates a bifucation in the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                e <- matrix(edge[alive,], ncol = 2)#
                parent <- e[random_lineage,2]#
                x <- which(edge[,2] == parent)#
                new.rows.lat <- new.rows.long <- extra.rows#
                new.rows.lat[, ot+1] <- organism_lat_matrix[x, ot+1] #updates the long and lat matricies with new coordiantes for each lineage#
                new.rows.long[, ot+1] <- organism_long_matrix[x, ot+1]#
                rownames(new.rows.lat) <- rep(rownames(organism_lat_matrix)[x],2)#
                rownames(new.rows.long) <- rep(rownames(organism_long_matrix)[x],2)#
                organism_lat_matrix <- rbind(organism_lat_matrix,new.rows.lat)#
                organism_long_matrix <- rbind(organism_long_matrix,new.rows.long)#
                alive[alive][random_lineage] <- FALSE#
                edge <- rbind(edge, c(parent, next.node), c(parent, next.node + 1))#
                next.node <- next.node + 2#
                alive <- c(alive, TRUE, TRUE)#
                stem.depth <- c(stem.depth, ot, ot)#
                edge.length[x] <- ot - stem.depth[x]#
                edge.length<-c(edge.length, NA, NA)#
            } else {###4 This terminates one of the current lineages on the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                edge.length[alive][random_lineage] <- ot - stem.depth[alive][random_lineage]#
                alive[alive][random_lineage] <- FALSE#
            }###4#
        }#1A#
        if (any(progress == t)) {#
        	cat("- ")#
        }#
    }#
#
    #Things to do right at the end to turn it into a phylo object#
    edge.length[alive] <- ot - stem.depth[alive];#
    n <- -1#
    for (f in 1:max(edge)) {#
        if (any(edge[,1] == f)) {#
           	edge[which(edge[,1] == f), 1] <- n#
           	edge[which(edge[,2] == f), 2] <- n#
           	n <- n - 1;#
        }#
    }#
    edge[edge > 0] <- 1:sum(edge > 0)#
   	tip.label <- 1:sum(edge > 0)#
    mode(edge) <- "character"#
    mode(tip.label) <- "character"#
    obj <- list(edge = edge, edge.length = edge.length, tip.label=tip.label)#
    class(obj) <- "phylo"#
    obj <- old2new.phylo(obj)#
    obj$tip.label = paste("s", 1:Ntip(obj), sep = "")#
	# Add final time step to continental configurations:#
	names(linked)[length(linked)] <- paste(strsplit(names(linked)[length(linked)], ":")[[1]][1], ":", t, sep="")#
	output <- list(position, linked, touching, obj, organism_long_matrix, organism_lat_matrix)#
	names(output) <- c("continent_positions", "continent_clusters", "continent_overlaps", "tree", "organism_longitudes", "organism_latitudes")
# Subfunction to find out which supercontinent a circle belongs to:#
	which_supercontinent <- function(cont, sprconts){#
		cont <- as.character(cont)#
		result <- which(unlist(lapply(lapply(lapply(strsplit(sprconts, "&"), match, cont), sort), length)) == 1)#
		return(result)#
	}#
	# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)#
# Are any continents joined at start?:#
#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
#
	# Get list of separate continents:#
	separate_continents <- HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
#
	# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
	touching_continents <- HowManySeparateContinents((radius * 2), continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
# Assign Euler poles to each separate continent:#
	# Randomly draw longitudes for each separated continent:#
	euler_pole_longitudes <- runif(length(separate_continents), -180, 180)#
	# Randomly draw latitudes for each separated continent:#
	euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
	# Ensure no latitude is directly at a pole (North or South) by redrawing if any are found:#
	if((sum(euler_pole_latitudes == 90) + sum(euler_pole_latitudes == -90)) > 0) euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
#
# Assign speeds to each separate continent:#
	# Create empty vector to store degrees per step (effectively the speed of movement) for each continent:#
	degrees_per_step <- vector(mode="numeric")#
	# For each separate continent:#
	for(i in 1:length(separate_continents)) {#
		# Get Greate Circle distances from Euler pole to each continent centre:#
		euler_GC_distances <- One2ManyGreatCircleDistance(euler_pole_longitudes[i], euler_pole_latitudes[i], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Longitude"], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Latitude"])#
		# Find GC distance to furthest continent (closest to euler pole "equator") in cluster (as speed will be assigned based on this):#
		furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
		# Randomly draw a continent speed:#
		continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# If a negative or zero speed is picked then redraw:#
		while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# Set degree change per step (effectively the speed):#
		degrees_per_step[i] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
	}#
#
	#starting information for the tree#
	dispersals <- matrix(nrow=0, ncol=5)#
	begin_cont <- ceiling(runif(1, 0, N_continents))#
	life_begins <- EndPoint(continent_starting_points[begin_cont, "Longitude"], continent_starting_points[begin_cont, "Latitude"], runif(1,0,360), runif(1,0,radius))#
	extra.rows <- matrix(NA,nrow=2,ncol= (N_steps * organism_multiplier) + 1)#
	organism_lat_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_long_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_lat_matrix[,1] <- life_begins$lat#
    organism_long_matrix[,1] <- life_begins$lon#
    rownames(organism_lat_matrix) <- rep(begin_cont, 2)#
    rownames(organism_long_matrix) <- rep(begin_cont, 2)#
    edge <- rbind(c(1, 2), c(1, 3)) # this is a starting edge matrix#
    edge.length <- rep(NA, 2)#
    stem.depth <- numeric(2)#
    alive <- rep(TRUE, 2) # marker for live lineages#
    ot <- 0; # time(step) at any point in the tree#
    next.node <- 4#
#
	# Now need to move them!#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	linked <- list()#
	linked[[1]] <- separate_continents#
	names(linked)[[1]] <- "1:1"#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	touching <- list()#
	touching[[1]] <- touching_continents#
#
	#Array to store the positions of every continent at each time step#
	position <- array(NA, c(N_continents, N_steps + 1, 2), c("continent", "timestep", "coordinate"))#
	position[,1,1] <- continent_starting_points[,"Longitude"]#
	position[,1,2] <- continent_starting_points[,"Latitude"]#
#
	temp_position<-matrix(nrow = N_continents, ncol=2)#
#
	progress <- seq(1, N_steps, floor(N_steps/50))#
	cat("Starting time steps \n")#
	cat("Progress \n")#
	cat("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n")#
#
	#for loops to move everything#
	for (t in 2:(N_steps + 1)) {#
		#distances apart before they move#
		starting_distances <- GreatCircleDistanceMatrix(position[,t-1,1], position[,t-1,2])#
#
		for (k in 1:N_continents) {#
			#find current longlat of the circle k#
			start_long <- position[k, t-1, 1]#
			start_lat <- position[k, t-1, 2]#
#
			#Identify which supercontinent, and therefore which element of the euler pole and speed vectors, the circle k belongs to#
			where <- which_supercontinent(k, tail(linked, n=1)[[1]])#
#
			#Find distance of circle from pole#
			distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where], lat2=euler_pole_latitudes[where], Warn = FALSE)#
			#Find bearing of circle from pole#
			init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where], euler_pole_latitudes[where], start_long, start_lat)#
#
			#Find the new bearing of circle from pole according to the speed specified#
			new_bearing <- (init_bearing + degrees_per_step[where]) %% 360#
#
			#Find the new location of the circle#
			new_loc <- EndPoint(euler_pole_longitudes[where], euler_pole_latitudes[where], new_bearing, distance)#
#
			#Add the new loction to the position matrix#
			temp_position[k,1] <- new_loc$long#
			temp_position[k,2] <- new_loc$lat#
#
		}#
#
		#Matrix of the distances between each continent in their new positions, before these are set#
		new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
		comp1 <- vector()#
		comp2 <- vector()#
#
		#Making a vector of whether any continents have collided and should be linked#
		collisions<-matrix(nrow=0, ncol=2)#
		for (q in 1:(N_continents-1)) {#
			for (p in (q+1):N_continents) {#
				comp1 <- all.equal(new_distances[p,q],starting_distances[p,q])#
				comp2 <- new_distances[p,q] <= min_separation#
				if (comp1 != TRUE && comp2 == TRUE) {#
					collisions<-rbind(collisions,c(p,q))#
				}#
			}#
		}#
#
		#Matrix of euler poles and speeds for each individual continent for moving the animals later#
		organism_mover <- matrix(nrow=N_continents, ncol= 3)#
		for (clump in 1:length(tail(linked, n=1)[[1]])) {#
			which_conts <- as.numeric(strsplit(tail(linked, n=1)[[1]][[clump]], "&")[[1]])#
			organism_mover[which_conts,1] <- rep(euler_pole_longitudes[clump],length(which_conts))#
			organism_mover[which_conts,2] <- rep(euler_pole_latitudes[clump],length(which_conts))#
			#This bit will get overwritten if there are collisions#
			organism_mover[which_conts,3] <- rep(degrees_per_step[clump],length(which_conts))#
		}#
		perm_collisions <- matrix(nrow=0, ncol=2)#
#
		# Moving continents back if there has only been one collision#
		while(nrow(collisions) > 0) {#
#
			# Set up vector to store proportional changes after collisions#
			proportion <- vector()#
#
			# Find out proportions to reduce to for all potential collisions#
			for (coll in 1:nrow(collisions)) {#
				cont_1 <- collisions[coll,1]#
				cont_2 <- collisions[coll,2]#
				where_1 <- which_supercontinent(cont_1, tail(linked, n=1)[[1]])#
				where_2 <- which_supercontinent(cont_2, tail(linked, n=1)[[1]])#
				continent_1_euler_longitude = euler_pole_longitudes[where_1]#
				continent_1_euler_latitude = euler_pole_latitudes[where_1]#
				continent_2_euler_longitude = euler_pole_longitudes[where_2]#
				continent_2_euler_latitude = euler_pole_latitudes[where_2]#
				continent_1_degrees_per_step = degrees_per_step[where_1]#
				continent_2_degrees_per_step = degrees_per_step[where_2]#
				proportion[coll] <- ColliderReverser(min_separation, position[cont_1, t-1, 1], position[cont_1, t-1, 2], temp_position[cont_1,1], temp_position[cont_1,2], position[cont_2, t-1, 1], position[cont_2, t-1, 2], temp_position[cont_2,1], temp_position[cont_2,2], continent_1_euler_longitude, continent_1_euler_latitude, continent_2_euler_longitude, continent_2_euler_latitude, continent_1_degrees_per_step, continent_2_degrees_per_step, EarthRad = 6367.4447, Warn = FALSE)#
			}#
#
			# Select proportion to move for first collision#
			first_collision <- match(min(proportion),proportion)#
#
			# Find the two continents that collided first#
			cont_involved <- sort(collisions[first_collision, ])#
#
			# Add to matrix of definite collisions that cannot be separated in the next step#
			perm_collisions <- rbind(perm_collisions, cont_involved)#
#
			# Move first clump back#
			head_of_collision_1 <- cont_involved[1]#
			where_1 <- which_supercontinent(head_of_collision_1, tail(linked, n=1)[[1]])#
#
			#Find the other continents that were attached to the collider#
			all_involved <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_1], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents in one of the clumps#
			for (rev in 1:length(all_involved)) {#
				cont_to_rev <- all_involved[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_1], lat2=euler_pole_latitudes[where_1], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], start_long, start_lat)#
#
				#degrees to add#
				addition <- proportion[first_collision] * degrees_per_step[where_1]#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <- (init_bearing + addition) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
#
				organism_mover[cont_to_rev,3] <- addition#
			}#
#
			#Move the second clump back#
			head_of_collision_2 <- cont_involved[2]#
			where_2 <- which_supercontinent(head_of_collision_2, tail(linked, n=1)[[1]])#
			all_involved_2 <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_2], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents the other clump#
			for (rev in 1:length(all_involved_2)) {#
				cont_to_rev <- all_involved_2[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_2], lat2=euler_pole_latitudes[where_2], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], start_long, start_lat)#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <-  (init_bearing + (proportion[first_collision] * degrees_per_step[where_2])) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
			}#
#
			#Recalculate the new distances#
			new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
			comp1 <- vector()#
			comp2 <- vector()#
#
			# Check whether any other collisions have still occurred#
			collisions <- matrix(nrow=0, ncol=2)#
			for (q in 1:(N_continents - 1)) {#
				for (p in (q+1):N_continents) {#
					comp1 <- all.equal(new_distances[p, q], starting_distances[p, q])#
					comp2 <- new_distances[p, q] <= min_separation#
					if (comp1 != TRUE && comp2 == TRUE) {#
						# If collision has not already been recorded:#
						if(length(sort(match(paste(sort(c(q, p)), collapse=""), apply(perm_collisions, 1, paste, collapse="")))) == 0) {#
							# Record collision:#
							collisions <- rbind(collisions, c(p, q))#
						}#
					}#
				}#
			}#
		}#
#
		# When it finishes while loop can now 'ossify' the positions and move to selecting separations#
		position[, t, 1] <- temp_position[, 1]#
		position[, t, 2] <- temp_position[, 2]#
#
# Finding out if anything gets separated#
		# How many separate continents are there now? (after collisions may have occurred):#
		separate_continents <- HowManySeparateContinents(min_separation, position[,t,1], position[,t,2])#
		# Make random uniform draws for each continental cluster:#
		separation_draws <- runif(length(grep("&", separate_continents)))#
		# Case if a separation occurs (drawn value is equal to or exceeds stickiness):#
		if(any(separation_draws >= stickiness)) {#
			# Get clusters of continents to split apart:#
			clusters_to_split <- separate_continents[grep("&", separate_continents)][which(separation_draws >= stickiness)]#
			# For each cluster to split apart:#
			for(i in 1:length(clusters_to_split)) {#
				# Get numbers of continents involved:#
				cluster_continent_numbers <- sort(strsplit(clusters_to_split[i], "&")[[1]])#
				# Get longitudes of continents in cluster:#
				cluster_longitudes <- position[as.numeric(cluster_continent_numbers), t, 1]#
#
				# Get latitudes of continents in cluster:#
				cluster_latitudes <- position[as.numeric(cluster_continent_numbers), t, 2]#
				# Make protected links an empty matrix:#
				cluster_protected_links <- matrix(nrow = 0, ncol = 2)#
				# If there are recent collisions (that will potentially need to be excluded from new splits):#
				if(length(perm_collisions) > 0) {#
					# For each new collision:#
					for(j in 1:nrow(perm_collisions)) {#
						# If new collision occurs within the cluster:#
						if(length(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers)) == 2) {#
							# Add new collision to protected links list:#
							cluster_protected_links <- rbind(cluster_protected_links, perm_collisions[j, ])#
						}#
					}#
#
				}#
				# Get splits (new clusters) of separated cluster:#
				splits <- ContinentSplitter(min_separation, cluster_longitudes, cluster_latitudes, cluster_continent_numbers, cluster_protected_links, EarthRad)#
				# Update separate continents vector:#
				separate_continents <- sort(c(separate_continents[-match(clusters_to_split[i], separate_continents)], splits))#
			}#
		}#
#
# Now change the Euler poles and speeds#
		# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
		touching_continents <- HowManySeparateContinents((radius * 2), position[,t,1], position[,t,2])#
		if (paste(sort(touching_continents), collapse="") != paste(sort(tail(touching,n=1)[[1]]), collapse="")) {#
			touching <- c(touching, list(touching_continents))#
		}#
#
		# If the continental clustering has changed:#
		if (paste(sort(separate_continents), collapse="") != paste(sort(tail(linked,n=1)[[1]]), collapse="")) {#
			# Add new continental configuration to linked list#
			linked <- c(linked, list(separate_continents))#
#
			# Update time step for previous continental configuration:#
			names(linked)[(length(linked) - 1)] <- paste(strsplit(names(linked[(length(linked) - 1)]), ":")[[1]][1], ":", t - 1, sep="")#
			# Add time step to new continental configuration:#
			names(linked)[length(linked)] <- paste(t, ":", t, sep="")#
			# Select continents that are different to previous time step#
			toKeep <- c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]])[duplicated(c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]]))]#
#
			#Vectors for new poles and speeds#
			new_euler_latitudes <- rep(NA, length(separate_continents))#
			new_euler_longitudes <- rep(NA, length(separate_continents))#
			new_degrees_per_step <- rep(NA, length(separate_continents))#
#
			if (length(toKeep) != 0){#
				#Inherit previous poles and speeds for those clumps that remain the same#
				for (y in 1:length(toKeep)) {#
					new_euler_longitudes[match(toKeep[y],separate_continents)]<- euler_pole_longitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_euler_latitudes[match(toKeep[y],separate_continents)]<- euler_pole_latitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_degrees_per_step[match(toKeep[y],separate_continents)]<- degrees_per_step[match(toKeep[y],tail(linked, n=2)[[1]])]#
				}#
			}#
#
			# Make new Euler poles#
			new_euler_longitudes[is.na(new_euler_longitudes)]<- runif((length(separate_continents)-length(toKeep)), -180, 180)#
#
			changed_euler_latitudes<- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			while((sum(changed_euler_latitudes == 90) + sum(changed_euler_latitudes == -90)) > 0) changed_euler_latitudes <- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			new_euler_latitudes[is.na(new_euler_latitudes)] <- changed_euler_latitudes#
#
			# Get Great Circle distances from Euler pole to each continent centre:#
			for (l in 1:(length(separate_continents)-length(toKeep))) {#
				# Find the first NA to fill in:#
				changer <- match(NA, new_degrees_per_step)#
				#Find the contients that are in the clump whose speed is going to change#
				rows <- as.numeric(unlist(strsplit(separate_continents[changer], "&")))#
				#Find the new euler pole for that clump#
				euler_long <- new_euler_longitudes[changer]#
				euler_lat <- new_euler_latitudes[changer]#
				#Find the distances of each of the continents in the clump from their new euler pole#
				euler_GC_distances <- One2ManyGreatCircleDistance(euler_long, euler_lat, position[rows, t, 1], position[rows, t, 2])#
				#Find which of those is closest to the equator#
				furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
				# Randomly draw a continent speed:#
				continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# If a negative or zero speed is picked then redraw:#
				while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# Set degree change per step (effectively the speed):#
				new_degrees_per_step[changer] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
			}#
			euler_pole_longitudes <- new_euler_longitudes#
			euler_pole_latitudes <- new_euler_latitudes#
			degrees_per_step <- new_degrees_per_step#
		}#
#
#Need to add in the tree bit#
		#Move the animals with the continents#
		for (cont in 1:N_continents) {#
			#Find the rows that are in the continent of focus#
			moving <- which(rownames(organism_long_matrix)==cont)#
#
			if (length(moving)==0) {#
				next #
			} else {#
				#Find out how many degrees around the euler pole that continent went#
				organism_degrees <- organism_mover[cont,3]#
				#loops through all the organisms that are currently living#
				for (organism in 1:length(moving)) {#
					organism_row <- moving[organism]#
					if (is.na(organism_long_matrix[organism_row, ot + 1])) {#
						next#
					} else {#
						first_long <- organism_long_matrix[organism_row, ot + 1]#
						first_lat <- organism_lat_matrix[organism_row, ot + 1]#
						organism_distance <- GreatCircleDistanceFromLongLat(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						organism_bearing <- BearingBetweenTwoLongLatPoints(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						new_organism_bearing <- (organism_bearing + organism_degrees) %% 360#
						new_organism_loc <- EndPoint(organism_mover[cont,1], organism_mover[cont,2], new_organism_bearing, organism_distance)#
						organism_long_matrix[organism_row, ot + 1] <- new_organism_loc$long#
    					organism_lat_matrix[organism_row, ot + 1] <- new_organism_loc$lat#
					}#
				}#
			}#
		}#
		for (f in 1:organism_multiplier) {#
            if (sum(alive) == 0) stop("METEOR IMPACT!! EVERYTHING HAS GONE EXTINCT! AAAAHHHHHH!!!")#
            dt<-1#
            ot <- ot + dt#
            for (m in 1:nrow(organism_lat_matrix)) {#
                if (alive[m]) {#
                    starting<-c(organism_lat_matrix[m,ot],organism_long_matrix[m,ot])#
                    moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd))) #generates a random walk step and calculates new position#
                    on_cont <- as.numeric(rownames(organism_lat_matrix)[m])#
                    friends <- as.numeric(strsplit(tail(touching, n=1)[[1]][which_supercontinent(on_cont, tail(touching, n=1)[[1]])], "&")[[1]])#
                    dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    if (length(friends) > 1) {#
                    	all_dist <- vector(length = length(friends))#
                    	for (g in 1:length(friends)) {#
                    		all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    	}#
                    	while (min(all_dist) > radius) {#
                    		moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		temp_all_dist <- vector(length = length(friends))#
                    		for (g in 1:length(friends)) {#
                    			temp_all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    		}#
                    		all_dist <- temp_all_dist#
                    	}#
                    	new_cont <- friends[which(all_dist == min(all_dist))] #
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                    	rownames(organism_long_matrix)[m] <- new_cont#
                    	rownames(organism_lat_matrix)[m] <- new_cont#
                    	if(new_cont != on_cont) {#
                    		dispersals <- rbind(dispersals, c(on_cont, new_cont, m, t, ot+1))#
                    	}#
                    } else {#
                    	while (dist_from_center >= radius) {#
                    		moveto <- EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    	}#
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                	}#
                }#
            }#
#
            r <- runif(1)#
            if (r <= b/(b + d)) { ###4 #this creates a bifucation in the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                e <- matrix(edge[alive,], ncol = 2)#
                parent <- e[random_lineage,2]#
                x <- which(edge[,2] == parent)#
                new.rows.lat <- new.rows.long <- extra.rows#
                new.rows.lat[, ot+1] <- organism_lat_matrix[x, ot+1] #updates the long and lat matricies with new coordiantes for each lineage#
                new.rows.long[, ot+1] <- organism_long_matrix[x, ot+1]#
                rownames(new.rows.lat) <- rep(rownames(organism_lat_matrix)[x],2)#
                rownames(new.rows.long) <- rep(rownames(organism_long_matrix)[x],2)#
                organism_lat_matrix <- rbind(organism_lat_matrix,new.rows.lat)#
                organism_long_matrix <- rbind(organism_long_matrix,new.rows.long)#
                alive[alive][random_lineage] <- FALSE#
                edge <- rbind(edge, c(parent, next.node), c(parent, next.node + 1))#
                next.node <- next.node + 2#
                alive <- c(alive, TRUE, TRUE)#
                stem.depth <- c(stem.depth, ot, ot)#
                edge.length[x] <- ot - stem.depth[x]#
                edge.length<-c(edge.length, NA, NA)#
            } else {###4 This terminates one of the current lineages on the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                edge.length[alive][random_lineage] <- ot - stem.depth[alive][random_lineage]#
                alive[alive][random_lineage] <- FALSE#
            }###4#
        }#1A#
        if (any(progress == t)) {#
        	cat("- ")#
        }#
    }#
#
    #Things to do right at the end to turn it into a phylo object#
    edge.length[alive] <- ot - stem.depth[alive];#
    n <- -1#
    for (f in 1:max(edge)) {#
        if (any(edge[,1] == f)) {#
           	edge[which(edge[,1] == f), 1] <- n#
           	edge[which(edge[,2] == f), 2] <- n#
           	n <- n - 1;#
        }#
    }#
    edge[edge > 0] <- 1:sum(edge > 0)#
   	tip.label <- 1:sum(edge > 0)#
    mode(edge) <- "character"#
    mode(tip.label) <- "character"#
    obj <- list(edge = edge, edge.length = edge.length, tip.label=tip.label)#
    class(obj) <- "phylo"#
    obj <- old2new.phylo(obj)#
    obj$tip.label = paste("s", 1:Ntip(obj), sep = "")#
	# Add final time step to continental configurations:#
	names(linked)[length(linked)] <- paste(strsplit(names(linked)[length(linked)], ":")[[1]][1], ":", t, sep="")#
	output <- list(position, linked, touching, obj, organism_long_matrix, organism_lat_matrix)#
	names(output) <- c("continent_positions", "continent_clusters", "continent_overlaps", "tree", "organism_longitudes", "organism_latitudes")
try <- output#
plot(try$organism_longitudes[1,], try$organism_latitudes[1,], xlim=c(-180, 180), ylim=c(-90, 90), type = "l")#
for (i in 1:nrow(try$organism_longitudes))   lines(try$organism_longitudes[i,], try$organism_latitudes[i,])#
for(i in 1:N_continents) points(try$continent_positions[i,,1], try$continent_positions[i,,2], col=rainbow(N_steps))
linked
touching
dispersals
object.size(output)
dispersals
# Subfunction to find out which supercontinent a circle belongs to:#
	which_supercontinent <- function(cont, sprconts){#
		cont <- as.character(cont)#
		result <- which(unlist(lapply(lapply(lapply(strsplit(sprconts, "&"), match, cont), sort), length)) == 1)#
		return(result)#
	}#
	# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)#
# Are any continents joined at start?:#
#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
#
	# Get list of separate continents:#
	separate_continents <- HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
#
	# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
	touching_continents <- HowManySeparateContinents((radius * 2), continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
# Assign Euler poles to each separate continent:#
	# Randomly draw longitudes for each separated continent:#
	euler_pole_longitudes <- runif(length(separate_continents), -180, 180)#
	# Randomly draw latitudes for each separated continent:#
	euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
	# Ensure no latitude is directly at a pole (North or South) by redrawing if any are found:#
	if((sum(euler_pole_latitudes == 90) + sum(euler_pole_latitudes == -90)) > 0) euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
#
# Assign speeds to each separate continent:#
	# Create empty vector to store degrees per step (effectively the speed of movement) for each continent:#
	degrees_per_step <- vector(mode="numeric")#
	# For each separate continent:#
	for(i in 1:length(separate_continents)) {#
		# Get Greate Circle distances from Euler pole to each continent centre:#
		euler_GC_distances <- One2ManyGreatCircleDistance(euler_pole_longitudes[i], euler_pole_latitudes[i], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Longitude"], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Latitude"])#
		# Find GC distance to furthest continent (closest to euler pole "equator") in cluster (as speed will be assigned based on this):#
		furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
		# Randomly draw a continent speed:#
		continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# If a negative or zero speed is picked then redraw:#
		while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# Set degree change per step (effectively the speed):#
		degrees_per_step[i] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
	}#
#
	#starting information for the tree#
	dispersals <- matrix(nrow = 0, ncol = 5, dimnames = list(c(), c("From_continent", "To_continent", "Branch", "Continent_time_step", "Animal_time_step")))#
	begin_cont <- ceiling(runif(1, 0, N_continents))#
	life_begins <- EndPoint(continent_starting_points[begin_cont, "Longitude"], continent_starting_points[begin_cont, "Latitude"], runif(1,0,360), runif(1,0,radius))#
	extra.rows <- matrix(NA,nrow=2,ncol= (N_steps * organism_multiplier) + 1)#
	organism_lat_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_long_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_lat_matrix[,1] <- life_begins$lat#
    organism_long_matrix[,1] <- life_begins$lon#
    rownames(organism_lat_matrix) <- rep(begin_cont, 2)#
    rownames(organism_long_matrix) <- rep(begin_cont, 2)#
    edge <- rbind(c(1, 2), c(1, 3)) # this is a starting edge matrix#
    edge.length <- rep(NA, 2)#
    stem.depth <- numeric(2)#
    alive <- rep(TRUE, 2) # marker for live lineages#
    ot <- 0; # time(step) at any point in the tree#
    next.node <- 4#
#
	# Now need to move them!#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	linked <- list()#
	linked[[1]] <- separate_continents#
	names(linked)[[1]] <- "1:1"#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	touching <- list()#
	touching[[1]] <- touching_continents#
#
	#Array to store the positions of every continent at each time step#
	position <- array(NA, c(N_continents, N_steps + 1, 2), c("continent", "timestep", "coordinate"))#
	position[,1,1] <- continent_starting_points[,"Longitude"]#
	position[,1,2] <- continent_starting_points[,"Latitude"]#
#
	temp_position<-matrix(nrow = N_continents, ncol=2)#
#
	progress <- seq(1, N_steps, floor(N_steps/50))#
	cat("Starting time steps \n")#
	cat("Progress \n")#
	cat("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n")#
#
	#for loops to move everything#
	for (t in 2:(N_steps + 1)) {#
		#distances apart before they move#
		starting_distances <- GreatCircleDistanceMatrix(position[,t-1,1], position[,t-1,2])#
#
		for (k in 1:N_continents) {#
			#find current longlat of the circle k#
			start_long <- position[k, t-1, 1]#
			start_lat <- position[k, t-1, 2]#
#
			#Identify which supercontinent, and therefore which element of the euler pole and speed vectors, the circle k belongs to#
			where <- which_supercontinent(k, tail(linked, n=1)[[1]])#
#
			#Find distance of circle from pole#
			distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where], lat2=euler_pole_latitudes[where], Warn = FALSE)#
			#Find bearing of circle from pole#
			init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where], euler_pole_latitudes[where], start_long, start_lat)#
#
			#Find the new bearing of circle from pole according to the speed specified#
			new_bearing <- (init_bearing + degrees_per_step[where]) %% 360#
#
			#Find the new location of the circle#
			new_loc <- EndPoint(euler_pole_longitudes[where], euler_pole_latitudes[where], new_bearing, distance)#
#
			#Add the new loction to the position matrix#
			temp_position[k,1] <- new_loc$long#
			temp_position[k,2] <- new_loc$lat#
#
		}#
#
		#Matrix of the distances between each continent in their new positions, before these are set#
		new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
		comp1 <- vector()#
		comp2 <- vector()#
#
		#Making a vector of whether any continents have collided and should be linked#
		collisions<-matrix(nrow=0, ncol=2)#
		for (q in 1:(N_continents-1)) {#
			for (p in (q+1):N_continents) {#
				comp1 <- all.equal(new_distances[p,q],starting_distances[p,q])#
				comp2 <- new_distances[p,q] <= min_separation#
				if (comp1 != TRUE && comp2 == TRUE) {#
					collisions<-rbind(collisions,c(p,q))#
				}#
			}#
		}#
#
		#Matrix of euler poles and speeds for each individual continent for moving the animals later#
		organism_mover <- matrix(nrow=N_continents, ncol= 3)#
		for (clump in 1:length(tail(linked, n=1)[[1]])) {#
			which_conts <- as.numeric(strsplit(tail(linked, n=1)[[1]][[clump]], "&")[[1]])#
			organism_mover[which_conts,1] <- rep(euler_pole_longitudes[clump],length(which_conts))#
			organism_mover[which_conts,2] <- rep(euler_pole_latitudes[clump],length(which_conts))#
			#This bit will get overwritten if there are collisions#
			organism_mover[which_conts,3] <- rep(degrees_per_step[clump],length(which_conts))#
		}#
		perm_collisions <- matrix(nrow=0, ncol=2)#
#
		# Moving continents back if there has only been one collision#
		while(nrow(collisions) > 0) {#
#
			# Set up vector to store proportional changes after collisions#
			proportion <- vector()#
#
			# Find out proportions to reduce to for all potential collisions#
			for (coll in 1:nrow(collisions)) {#
				cont_1 <- collisions[coll,1]#
				cont_2 <- collisions[coll,2]#
				where_1 <- which_supercontinent(cont_1, tail(linked, n=1)[[1]])#
				where_2 <- which_supercontinent(cont_2, tail(linked, n=1)[[1]])#
				continent_1_euler_longitude = euler_pole_longitudes[where_1]#
				continent_1_euler_latitude = euler_pole_latitudes[where_1]#
				continent_2_euler_longitude = euler_pole_longitudes[where_2]#
				continent_2_euler_latitude = euler_pole_latitudes[where_2]#
				continent_1_degrees_per_step = degrees_per_step[where_1]#
				continent_2_degrees_per_step = degrees_per_step[where_2]#
				proportion[coll] <- ColliderReverser(min_separation, position[cont_1, t-1, 1], position[cont_1, t-1, 2], temp_position[cont_1,1], temp_position[cont_1,2], position[cont_2, t-1, 1], position[cont_2, t-1, 2], temp_position[cont_2,1], temp_position[cont_2,2], continent_1_euler_longitude, continent_1_euler_latitude, continent_2_euler_longitude, continent_2_euler_latitude, continent_1_degrees_per_step, continent_2_degrees_per_step, EarthRad = 6367.4447, Warn = FALSE)#
			}#
#
			# Select proportion to move for first collision#
			first_collision <- match(min(proportion),proportion)#
#
			# Find the two continents that collided first#
			cont_involved <- sort(collisions[first_collision, ])#
#
			# Add to matrix of definite collisions that cannot be separated in the next step#
			perm_collisions <- rbind(perm_collisions, cont_involved)#
#
			# Move first clump back#
			head_of_collision_1 <- cont_involved[1]#
			where_1 <- which_supercontinent(head_of_collision_1, tail(linked, n=1)[[1]])#
#
			#Find the other continents that were attached to the collider#
			all_involved <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_1], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents in one of the clumps#
			for (rev in 1:length(all_involved)) {#
				cont_to_rev <- all_involved[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_1], lat2=euler_pole_latitudes[where_1], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], start_long, start_lat)#
#
				#degrees to add#
				addition <- proportion[first_collision] * degrees_per_step[where_1]#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <- (init_bearing + addition) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
#
				organism_mover[cont_to_rev,3] <- addition#
			}#
#
			#Move the second clump back#
			head_of_collision_2 <- cont_involved[2]#
			where_2 <- which_supercontinent(head_of_collision_2, tail(linked, n=1)[[1]])#
			all_involved_2 <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_2], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents the other clump#
			for (rev in 1:length(all_involved_2)) {#
				cont_to_rev <- all_involved_2[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_2], lat2=euler_pole_latitudes[where_2], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], start_long, start_lat)#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <-  (init_bearing + (proportion[first_collision] * degrees_per_step[where_2])) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
			}#
#
			#Recalculate the new distances#
			new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
			comp1 <- vector()#
			comp2 <- vector()#
#
			# Check whether any other collisions have still occurred#
			collisions <- matrix(nrow=0, ncol=2)#
			for (q in 1:(N_continents - 1)) {#
				for (p in (q+1):N_continents) {#
					comp1 <- all.equal(new_distances[p, q], starting_distances[p, q])#
					comp2 <- new_distances[p, q] <= min_separation#
					if (comp1 != TRUE && comp2 == TRUE) {#
						# If collision has not already been recorded:#
						if(length(sort(match(paste(sort(c(q, p)), collapse=""), apply(perm_collisions, 1, paste, collapse="")))) == 0) {#
							# Record collision:#
							collisions <- rbind(collisions, c(p, q))#
						}#
					}#
				}#
			}#
		}#
#
		# When it finishes while loop can now 'ossify' the positions and move to selecting separations#
		position[, t, 1] <- temp_position[, 1]#
		position[, t, 2] <- temp_position[, 2]#
#
# Finding out if anything gets separated#
		# How many separate continents are there now? (after collisions may have occurred):#
		separate_continents <- HowManySeparateContinents(min_separation, position[,t,1], position[,t,2])#
		# Make random uniform draws for each continental cluster:#
		separation_draws <- runif(length(grep("&", separate_continents)))#
		# Case if a separation occurs (drawn value is equal to or exceeds stickiness):#
		if(any(separation_draws >= stickiness)) {#
			# Get clusters of continents to split apart:#
			clusters_to_split <- separate_continents[grep("&", separate_continents)][which(separation_draws >= stickiness)]#
			# For each cluster to split apart:#
			for(i in 1:length(clusters_to_split)) {#
				# Get numbers of continents involved:#
				cluster_continent_numbers <- sort(strsplit(clusters_to_split[i], "&")[[1]])#
				# Get longitudes of continents in cluster:#
				cluster_longitudes <- position[as.numeric(cluster_continent_numbers), t, 1]#
#
				# Get latitudes of continents in cluster:#
				cluster_latitudes <- position[as.numeric(cluster_continent_numbers), t, 2]#
				# Make protected links an empty matrix:#
				cluster_protected_links <- matrix(nrow = 0, ncol = 2)#
				# If there are recent collisions (that will potentially need to be excluded from new splits):#
				if(length(perm_collisions) > 0) {#
					# For each new collision:#
					for(j in 1:nrow(perm_collisions)) {#
						# If new collision occurs within the cluster:#
						if(length(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers)) == 2) {#
							# Add new collision to protected links list:#
							cluster_protected_links <- rbind(cluster_protected_links, perm_collisions[j, ])#
						}#
					}#
#
				}#
				# Get splits (new clusters) of separated cluster:#
				splits <- ContinentSplitter(min_separation, cluster_longitudes, cluster_latitudes, cluster_continent_numbers, cluster_protected_links, EarthRad)#
				# Update separate continents vector:#
				separate_continents <- sort(c(separate_continents[-match(clusters_to_split[i], separate_continents)], splits))#
			}#
		}#
#
# Now change the Euler poles and speeds#
		# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
		touching_continents <- HowManySeparateContinents((radius * 2), position[,t,1], position[,t,2])#
		if (paste(sort(touching_continents), collapse="") != paste(sort(tail(touching,n=1)[[1]]), collapse="")) {#
			touching <- c(touching, list(touching_continents))#
		}#
#
		# If the continental clustering has changed:#
		if (paste(sort(separate_continents), collapse="") != paste(sort(tail(linked,n=1)[[1]]), collapse="")) {#
			# Add new continental configuration to linked list#
			linked <- c(linked, list(separate_continents))#
#
			# Update time step for previous continental configuration:#
			names(linked)[(length(linked) - 1)] <- paste(strsplit(names(linked[(length(linked) - 1)]), ":")[[1]][1], ":", t - 1, sep="")#
			# Add time step to new continental configuration:#
			names(linked)[length(linked)] <- paste(t, ":", t, sep="")#
			# Select continents that are different to previous time step#
			toKeep <- c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]])[duplicated(c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]]))]#
#
			#Vectors for new poles and speeds#
			new_euler_latitudes <- rep(NA, length(separate_continents))#
			new_euler_longitudes <- rep(NA, length(separate_continents))#
			new_degrees_per_step <- rep(NA, length(separate_continents))#
#
			if (length(toKeep) != 0){#
				#Inherit previous poles and speeds for those clumps that remain the same#
				for (y in 1:length(toKeep)) {#
					new_euler_longitudes[match(toKeep[y],separate_continents)]<- euler_pole_longitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_euler_latitudes[match(toKeep[y],separate_continents)]<- euler_pole_latitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_degrees_per_step[match(toKeep[y],separate_continents)]<- degrees_per_step[match(toKeep[y],tail(linked, n=2)[[1]])]#
				}#
			}#
#
			# Make new Euler poles#
			new_euler_longitudes[is.na(new_euler_longitudes)]<- runif((length(separate_continents)-length(toKeep)), -180, 180)#
#
			changed_euler_latitudes<- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			while((sum(changed_euler_latitudes == 90) + sum(changed_euler_latitudes == -90)) > 0) changed_euler_latitudes <- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			new_euler_latitudes[is.na(new_euler_latitudes)] <- changed_euler_latitudes#
#
			# Get Great Circle distances from Euler pole to each continent centre:#
			for (l in 1:(length(separate_continents)-length(toKeep))) {#
				# Find the first NA to fill in:#
				changer <- match(NA, new_degrees_per_step)#
				#Find the contients that are in the clump whose speed is going to change#
				rows <- as.numeric(unlist(strsplit(separate_continents[changer], "&")))#
				#Find the new euler pole for that clump#
				euler_long <- new_euler_longitudes[changer]#
				euler_lat <- new_euler_latitudes[changer]#
				#Find the distances of each of the continents in the clump from their new euler pole#
				euler_GC_distances <- One2ManyGreatCircleDistance(euler_long, euler_lat, position[rows, t, 1], position[rows, t, 2])#
				#Find which of those is closest to the equator#
				furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
				# Randomly draw a continent speed:#
				continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# If a negative or zero speed is picked then redraw:#
				while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# Set degree change per step (effectively the speed):#
				new_degrees_per_step[changer] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
			}#
			euler_pole_longitudes <- new_euler_longitudes#
			euler_pole_latitudes <- new_euler_latitudes#
			degrees_per_step <- new_degrees_per_step#
		}#
#
#Need to add in the tree bit#
		#Move the animals with the continents#
		for (cont in 1:N_continents) {#
			#Find the rows that are in the continent of focus#
			moving <- which(rownames(organism_long_matrix)==cont)#
#
			if (length(moving)==0) {#
				next #
			} else {#
				#Find out how many degrees around the euler pole that continent went#
				organism_degrees <- organism_mover[cont,3]#
				#loops through all the organisms that are currently living#
				for (organism in 1:length(moving)) {#
					organism_row <- moving[organism]#
					if (is.na(organism_long_matrix[organism_row, ot + 1])) {#
						next#
					} else {#
						first_long <- organism_long_matrix[organism_row, ot + 1]#
						first_lat <- organism_lat_matrix[organism_row, ot + 1]#
						organism_distance <- GreatCircleDistanceFromLongLat(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						organism_bearing <- BearingBetweenTwoLongLatPoints(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						new_organism_bearing <- (organism_bearing + organism_degrees) %% 360#
						new_organism_loc <- EndPoint(organism_mover[cont,1], organism_mover[cont,2], new_organism_bearing, organism_distance)#
						organism_long_matrix[organism_row, ot + 1] <- new_organism_loc$long#
    					organism_lat_matrix[organism_row, ot + 1] <- new_organism_loc$lat#
					}#
				}#
			}#
		}#
		for (f in 1:organism_multiplier) {#
            if (sum(alive) == 0) stop("METEOR IMPACT!! EVERYTHING HAS GONE EXTINCT! AAAAHHHHHH!!!")#
            dt<-1#
            ot <- ot + dt#
            for (m in 1:nrow(organism_lat_matrix)) {#
                if (alive[m]) {#
                    starting<-c(organism_lat_matrix[m,ot],organism_long_matrix[m,ot])#
                    moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd))) #generates a random walk step and calculates new position#
                    on_cont <- as.numeric(rownames(organism_lat_matrix)[m])#
                    friends <- as.numeric(strsplit(tail(touching, n=1)[[1]][which_supercontinent(on_cont, tail(touching, n=1)[[1]])], "&")[[1]])#
                    dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    if (length(friends) > 1) {#
                    	all_dist <- vector(length = length(friends))#
                    	for (g in 1:length(friends)) {#
                    		all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    	}#
                    	while (min(all_dist) > radius) {#
                    		moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		temp_all_dist <- vector(length = length(friends))#
                    		for (g in 1:length(friends)) {#
                    			temp_all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    		}#
                    		all_dist <- temp_all_dist#
                    	}#
                    	new_cont <- friends[which(all_dist == min(all_dist))] #
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                    	rownames(organism_long_matrix)[m] <- new_cont#
                    	rownames(organism_lat_matrix)[m] <- new_cont#
                    	if(new_cont != on_cont) {#
                    		dispersals <- rbind(dispersals, c(on_cont, new_cont, m, t, ot+1))#
                    	}#
                    } else {#
                    	while (dist_from_center >= radius) {#
                    		moveto <- EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    	}#
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                	}#
                }#
            }#
#
            r <- runif(1)#
            if (r <= b/(b + d)) { ###4 #this creates a bifucation in the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                e <- matrix(edge[alive,], ncol = 2)#
                parent <- e[random_lineage,2]#
                x <- which(edge[,2] == parent)#
                new.rows.lat <- new.rows.long <- extra.rows#
                new.rows.lat[, ot+1] <- organism_lat_matrix[x, ot+1] #updates the long and lat matricies with new coordiantes for each lineage#
                new.rows.long[, ot+1] <- organism_long_matrix[x, ot+1]#
                rownames(new.rows.lat) <- rep(rownames(organism_lat_matrix)[x],2)#
                rownames(new.rows.long) <- rep(rownames(organism_long_matrix)[x],2)#
                organism_lat_matrix <- rbind(organism_lat_matrix,new.rows.lat)#
                organism_long_matrix <- rbind(organism_long_matrix,new.rows.long)#
                alive[alive][random_lineage] <- FALSE#
                edge <- rbind(edge, c(parent, next.node), c(parent, next.node + 1))#
                next.node <- next.node + 2#
                alive <- c(alive, TRUE, TRUE)#
                stem.depth <- c(stem.depth, ot, ot)#
                edge.length[x] <- ot - stem.depth[x]#
                edge.length<-c(edge.length, NA, NA)#
            } else {###4 This terminates one of the current lineages on the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                edge.length[alive][random_lineage] <- ot - stem.depth[alive][random_lineage]#
                alive[alive][random_lineage] <- FALSE#
            }###4#
        }#1A#
        if (any(progress == t)) {#
        	cat("- ")#
        }#
    }#
#
    #Things to do right at the end to turn it into a phylo object#
    edge.length[alive] <- ot - stem.depth[alive];#
    n <- -1#
    for (f in 1:max(edge)) {#
        if (any(edge[,1] == f)) {#
           	edge[which(edge[,1] == f), 1] <- n#
           	edge[which(edge[,2] == f), 2] <- n#
           	n <- n - 1;#
        }#
    }#
    edge[edge > 0] <- 1:sum(edge > 0)#
   	tip.label <- 1:sum(edge > 0)#
    mode(edge) <- "character"#
    mode(tip.label) <- "character"#
    obj <- list(edge = edge, edge.length = edge.length, tip.label=tip.label)#
    class(obj) <- "phylo"#
    obj <- old2new.phylo(obj)#
    obj$tip.label = paste("s", 1:Ntip(obj), sep = "")#
	# Add final time step to continental configurations:#
	names(linked)[length(linked)] <- paste(strsplit(names(linked)[length(linked)], ":")[[1]][1], ":", t, sep="")#
	output <- list(position, linked, touching, obj, organism_long_matrix, organism_lat_matrix, dispersals)#
	names(output) <- c("continent_positions", "continent_clusters", "continent_overlaps", "tree", "organism_longitudes", "organism_latitudes", "dispersals")
try <- output#
plot(try$organism_longitudes[1,], try$organism_latitudes[1,], xlim=c(-180, 180), ylim=c(-90, 90), type = "l")#
for (i in 1:nrow(try$organism_longitudes))   lines(try$organism_longitudes[i,], try$organism_latitudes[i,])#
for(i in 1:N_continents) points(try$continent_positions[i,,1], try$continent_positions[i,,2], col=rainbow(N_steps))
output$disperr
output$dispersals
# Subfunction to find out which supercontinent a circle belongs to:#
	which_supercontinent <- function(cont, sprconts){#
		cont <- as.character(cont)#
		result <- which(unlist(lapply(lapply(lapply(strsplit(sprconts, "&"), match, cont), sort), length)) == 1)#
		return(result)#
	}#
	# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)#
# Are any continents joined at start?:#
#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
#
	# Get list of separate continents:#
	separate_continents <- HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
#
	# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
	touching_continents <- HowManySeparateContinents((radius * 2), continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
# Assign Euler poles to each separate continent:#
	# Randomly draw longitudes for each separated continent:#
	euler_pole_longitudes <- runif(length(separate_continents), -180, 180)#
	# Randomly draw latitudes for each separated continent:#
	euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
	# Ensure no latitude is directly at a pole (North or South) by redrawing if any are found:#
	if((sum(euler_pole_latitudes == 90) + sum(euler_pole_latitudes == -90)) > 0) euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
#
# Assign speeds to each separate continent:#
	# Create empty vector to store degrees per step (effectively the speed of movement) for each continent:#
	degrees_per_step <- vector(mode="numeric")#
	# For each separate continent:#
	for(i in 1:length(separate_continents)) {#
		# Get Greate Circle distances from Euler pole to each continent centre:#
		euler_GC_distances <- One2ManyGreatCircleDistance(euler_pole_longitudes[i], euler_pole_latitudes[i], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Longitude"], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Latitude"])#
		# Find GC distance to furthest continent (closest to euler pole "equator") in cluster (as speed will be assigned based on this):#
		furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
		# Randomly draw a continent speed:#
		continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# If a negative or zero speed is picked then redraw:#
		while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# Set degree change per step (effectively the speed):#
		degrees_per_step[i] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
	}#
#
	#starting information for the tree#
	dispersals <- matrix(nrow = 0, ncol = 5, dimnames = list(c(), c("From_continent", "To_continent", "Branch", "Continent_time_step", "Animal_time_step")))#
	begin_cont <- ceiling(runif(1, 0, N_continents))#
	life_begins <- EndPoint(continent_starting_points[begin_cont, "Longitude"], continent_starting_points[begin_cont, "Latitude"], runif(1,0,360), runif(1,0,radius))#
	extra.rows <- matrix(NA,nrow=2,ncol= (N_steps * organism_multiplier) + 1)#
	organism_lat_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_long_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_lat_matrix[,1] <- life_begins$lat#
    organism_long_matrix[,1] <- life_begins$lon#
    rownames(organism_lat_matrix) <- rep(begin_cont, 2)#
    rownames(organism_long_matrix) <- rep(begin_cont, 2)#
    edge <- rbind(c(1, 2), c(1, 3)) # this is a starting edge matrix#
    edge.length <- rep(NA, 2)#
    stem.depth <- numeric(2)#
    alive <- rep(TRUE, 2) # marker for live lineages#
    ot <- 0; # time(step) at any point in the tree#
    next.node <- 4#
#
	# Now need to move them!#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	linked <- list()#
	linked[[1]] <- separate_continents#
	names(linked)[[1]] <- "1:1"#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	touching <- list()#
	touching[[1]] <- touching_continents#
#
	#Array to store the positions of every continent at each time step#
	position <- array(NA, c(N_continents, N_steps + 1, 2), c("continent", "timestep", "coordinate"))#
	position[,1,1] <- continent_starting_points[,"Longitude"]#
	position[,1,2] <- continent_starting_points[,"Latitude"]#
#
	temp_position<-matrix(nrow = N_continents, ncol=2)#
#
	progress <- seq(1, N_steps, floor(N_steps/50))#
	cat("Starting time steps \n")#
	cat("Progress \n")#
	cat("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n")#
#
	#for loops to move everything#
	for (t in 2:(N_steps + 1)) {#
		#distances apart before they move#
		starting_distances <- GreatCircleDistanceMatrix(position[,t-1,1], position[,t-1,2])#
#
		for (k in 1:N_continents) {#
			#find current longlat of the circle k#
			start_long <- position[k, t-1, 1]#
			start_lat <- position[k, t-1, 2]#
#
			#Identify which supercontinent, and therefore which element of the euler pole and speed vectors, the circle k belongs to#
			where <- which_supercontinent(k, tail(linked, n=1)[[1]])#
#
			#Find distance of circle from pole#
			distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where], lat2=euler_pole_latitudes[where], Warn = FALSE)#
			#Find bearing of circle from pole#
			init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where], euler_pole_latitudes[where], start_long, start_lat)#
#
			#Find the new bearing of circle from pole according to the speed specified#
			new_bearing <- (init_bearing + degrees_per_step[where]) %% 360#
#
			#Find the new location of the circle#
			new_loc <- EndPoint(euler_pole_longitudes[where], euler_pole_latitudes[where], new_bearing, distance)#
#
			#Add the new loction to the position matrix#
			temp_position[k,1] <- new_loc$long#
			temp_position[k,2] <- new_loc$lat#
#
		}#
#
		#Matrix of the distances between each continent in their new positions, before these are set#
		new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
		comp1 <- vector()#
		comp2 <- vector()#
#
		#Making a vector of whether any continents have collided and should be linked#
		collisions<-matrix(nrow=0, ncol=2)#
		for (q in 1:(N_continents-1)) {#
			for (p in (q+1):N_continents) {#
				comp1 <- all.equal(new_distances[p,q],starting_distances[p,q])#
				comp2 <- new_distances[p,q] <= min_separation#
				if (comp1 != TRUE && comp2 == TRUE) {#
					collisions<-rbind(collisions,c(p,q))#
				}#
			}#
		}#
#
		#Matrix of euler poles and speeds for each individual continent for moving the animals later#
		organism_mover <- matrix(nrow=N_continents, ncol= 3)#
		for (clump in 1:length(tail(linked, n=1)[[1]])) {#
			which_conts <- as.numeric(strsplit(tail(linked, n=1)[[1]][[clump]], "&")[[1]])#
			organism_mover[which_conts,1] <- rep(euler_pole_longitudes[clump],length(which_conts))#
			organism_mover[which_conts,2] <- rep(euler_pole_latitudes[clump],length(which_conts))#
			#This bit will get overwritten if there are collisions#
			organism_mover[which_conts,3] <- rep(degrees_per_step[clump],length(which_conts))#
		}#
		perm_collisions <- matrix(nrow=0, ncol=2)#
#
		# Moving continents back if there has only been one collision#
		while(nrow(collisions) > 0) {#
#
			# Set up vector to store proportional changes after collisions#
			proportion <- vector()#
#
			# Find out proportions to reduce to for all potential collisions#
			for (coll in 1:nrow(collisions)) {#
				cont_1 <- collisions[coll,1]#
				cont_2 <- collisions[coll,2]#
				where_1 <- which_supercontinent(cont_1, tail(linked, n=1)[[1]])#
				where_2 <- which_supercontinent(cont_2, tail(linked, n=1)[[1]])#
				continent_1_euler_longitude = euler_pole_longitudes[where_1]#
				continent_1_euler_latitude = euler_pole_latitudes[where_1]#
				continent_2_euler_longitude = euler_pole_longitudes[where_2]#
				continent_2_euler_latitude = euler_pole_latitudes[where_2]#
				continent_1_degrees_per_step = degrees_per_step[where_1]#
				continent_2_degrees_per_step = degrees_per_step[where_2]#
				proportion[coll] <- ColliderReverser(min_separation, position[cont_1, t-1, 1], position[cont_1, t-1, 2], temp_position[cont_1,1], temp_position[cont_1,2], position[cont_2, t-1, 1], position[cont_2, t-1, 2], temp_position[cont_2,1], temp_position[cont_2,2], continent_1_euler_longitude, continent_1_euler_latitude, continent_2_euler_longitude, continent_2_euler_latitude, continent_1_degrees_per_step, continent_2_degrees_per_step, EarthRad = 6367.4447, Warn = FALSE)#
			}#
#
			# Select proportion to move for first collision#
			first_collision <- match(min(proportion),proportion)#
#
			# Find the two continents that collided first#
			cont_involved <- sort(collisions[first_collision, ])#
#
			# Add to matrix of definite collisions that cannot be separated in the next step#
			perm_collisions <- rbind(perm_collisions, cont_involved)#
#
			# Move first clump back#
			head_of_collision_1 <- cont_involved[1]#
			where_1 <- which_supercontinent(head_of_collision_1, tail(linked, n=1)[[1]])#
#
			#Find the other continents that were attached to the collider#
			all_involved <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_1], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents in one of the clumps#
			for (rev in 1:length(all_involved)) {#
				cont_to_rev <- all_involved[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_1], lat2=euler_pole_latitudes[where_1], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], start_long, start_lat)#
#
				#degrees to add#
				addition <- proportion[first_collision] * degrees_per_step[where_1]#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <- (init_bearing + addition) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
#
				organism_mover[cont_to_rev,3] <- addition#
			}#
#
			#Move the second clump back#
			head_of_collision_2 <- cont_involved[2]#
			where_2 <- which_supercontinent(head_of_collision_2, tail(linked, n=1)[[1]])#
			all_involved_2 <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_2], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents the other clump#
			for (rev in 1:length(all_involved_2)) {#
				cont_to_rev <- all_involved_2[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_2], lat2=euler_pole_latitudes[where_2], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], start_long, start_lat)#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <-  (init_bearing + (proportion[first_collision] * degrees_per_step[where_2])) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
			}#
#
			#Recalculate the new distances#
			new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
			comp1 <- vector()#
			comp2 <- vector()#
#
			# Check whether any other collisions have still occurred#
			collisions <- matrix(nrow=0, ncol=2)#
			for (q in 1:(N_continents - 1)) {#
				for (p in (q+1):N_continents) {#
					comp1 <- all.equal(new_distances[p, q], starting_distances[p, q])#
					comp2 <- new_distances[p, q] <= min_separation#
					if (comp1 != TRUE && comp2 == TRUE) {#
						# If collision has not already been recorded:#
						if(length(sort(match(paste(sort(c(q, p)), collapse=""), apply(perm_collisions, 1, paste, collapse="")))) == 0) {#
							# Record collision:#
							collisions <- rbind(collisions, c(p, q))#
						}#
					}#
				}#
			}#
		}#
#
		# When it finishes while loop can now 'ossify' the positions and move to selecting separations#
		position[, t, 1] <- temp_position[, 1]#
		position[, t, 2] <- temp_position[, 2]#
#
# Finding out if anything gets separated#
		# How many separate continents are there now? (after collisions may have occurred):#
		separate_continents <- HowManySeparateContinents(min_separation, position[,t,1], position[,t,2])#
		# Make random uniform draws for each continental cluster:#
		separation_draws <- runif(length(grep("&", separate_continents)))#
		# Case if a separation occurs (drawn value is equal to or exceeds stickiness):#
		if(any(separation_draws >= stickiness)) {#
			# Get clusters of continents to split apart:#
			clusters_to_split <- separate_continents[grep("&", separate_continents)][which(separation_draws >= stickiness)]#
			# For each cluster to split apart:#
			for(i in 1:length(clusters_to_split)) {#
				# Get numbers of continents involved:#
				cluster_continent_numbers <- sort(strsplit(clusters_to_split[i], "&")[[1]])#
				# Get longitudes of continents in cluster:#
				cluster_longitudes <- position[as.numeric(cluster_continent_numbers), t, 1]#
#
				# Get latitudes of continents in cluster:#
				cluster_latitudes <- position[as.numeric(cluster_continent_numbers), t, 2]#
				# Make protected links an empty matrix:#
				cluster_protected_links <- matrix(nrow = 0, ncol = 2)#
				# If there are recent collisions (that will potentially need to be excluded from new splits):#
				if(length(perm_collisions) > 0) {#
					# For each new collision:#
					for(j in 1:nrow(perm_collisions)) {#
						# If new collision occurs within the cluster:#
						if(length(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers)) == 2) {#
							# Add new collision to protected links list:#
							cluster_protected_links <- rbind(cluster_protected_links, perm_collisions[j, ])#
						}#
					}#
#
				}#
				# Get splits (new clusters) of separated cluster:#
				splits <- ContinentSplitter(min_separation, cluster_longitudes, cluster_latitudes, cluster_continent_numbers, cluster_protected_links, EarthRad)#
				# Update separate continents vector:#
				separate_continents <- sort(c(separate_continents[-match(clusters_to_split[i], separate_continents)], splits))#
			}#
		}#
#
# Now change the Euler poles and speeds#
		# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
		touching_continents <- HowManySeparateContinents((radius * 2), position[,t,1], position[,t,2])#
		if (paste(sort(touching_continents), collapse="") != paste(sort(tail(touching,n=1)[[1]]), collapse="")) {#
			touching <- c(touching, list(touching_continents))#
		}#
#
		# If the continental clustering has changed:#
		if (paste(sort(separate_continents), collapse="") != paste(sort(tail(linked,n=1)[[1]]), collapse="")) {#
			# Add new continental configuration to linked list#
			linked <- c(linked, list(separate_continents))#
#
			# Update time step for previous continental configuration:#
			names(linked)[(length(linked) - 1)] <- paste(strsplit(names(linked[(length(linked) - 1)]), ":")[[1]][1], ":", t - 1, sep="")#
			# Add time step to new continental configuration:#
			names(linked)[length(linked)] <- paste(t, ":", t, sep="")#
			# Select continents that are different to previous time step#
			toKeep <- c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]])[duplicated(c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]]))]#
#
			#Vectors for new poles and speeds#
			new_euler_latitudes <- rep(NA, length(separate_continents))#
			new_euler_longitudes <- rep(NA, length(separate_continents))#
			new_degrees_per_step <- rep(NA, length(separate_continents))#
#
			if (length(toKeep) != 0){#
				#Inherit previous poles and speeds for those clumps that remain the same#
				for (y in 1:length(toKeep)) {#
					new_euler_longitudes[match(toKeep[y],separate_continents)]<- euler_pole_longitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_euler_latitudes[match(toKeep[y],separate_continents)]<- euler_pole_latitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_degrees_per_step[match(toKeep[y],separate_continents)]<- degrees_per_step[match(toKeep[y],tail(linked, n=2)[[1]])]#
				}#
			}#
#
			# Make new Euler poles#
			new_euler_longitudes[is.na(new_euler_longitudes)]<- runif((length(separate_continents)-length(toKeep)), -180, 180)#
#
			changed_euler_latitudes<- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			while((sum(changed_euler_latitudes == 90) + sum(changed_euler_latitudes == -90)) > 0) changed_euler_latitudes <- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			new_euler_latitudes[is.na(new_euler_latitudes)] <- changed_euler_latitudes#
#
			# Get Great Circle distances from Euler pole to each continent centre:#
			for (l in 1:(length(separate_continents)-length(toKeep))) {#
				# Find the first NA to fill in:#
				changer <- match(NA, new_degrees_per_step)#
				#Find the contients that are in the clump whose speed is going to change#
				rows <- as.numeric(unlist(strsplit(separate_continents[changer], "&")))#
				#Find the new euler pole for that clump#
				euler_long <- new_euler_longitudes[changer]#
				euler_lat <- new_euler_latitudes[changer]#
				#Find the distances of each of the continents in the clump from their new euler pole#
				euler_GC_distances <- One2ManyGreatCircleDistance(euler_long, euler_lat, position[rows, t, 1], position[rows, t, 2])#
				#Find which of those is closest to the equator#
				furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
				# Randomly draw a continent speed:#
				continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# If a negative or zero speed is picked then redraw:#
				while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# Set degree change per step (effectively the speed):#
				new_degrees_per_step[changer] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
			}#
			euler_pole_longitudes <- new_euler_longitudes#
			euler_pole_latitudes <- new_euler_latitudes#
			degrees_per_step <- new_degrees_per_step#
		}#
#
#Need to add in the tree bit#
		#Move the animals with the continents#
		for (cont in 1:N_continents) {#
			#Find the rows that are in the continent of focus#
			moving <- which(rownames(organism_long_matrix)==cont)#
#
			if (length(moving)==0) {#
				next #
			} else {#
				#Find out how many degrees around the euler pole that continent went#
				organism_degrees <- organism_mover[cont,3]#
				#loops through all the organisms that are currently living#
				for (organism in 1:length(moving)) {#
					organism_row <- moving[organism]#
					if (is.na(organism_long_matrix[organism_row, ot + 1])) {#
						next#
					} else {#
						first_long <- organism_long_matrix[organism_row, ot + 1]#
						first_lat <- organism_lat_matrix[organism_row, ot + 1]#
						organism_distance <- GreatCircleDistanceFromLongLat(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						organism_bearing <- BearingBetweenTwoLongLatPoints(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						new_organism_bearing <- (organism_bearing + organism_degrees) %% 360#
						new_organism_loc <- EndPoint(organism_mover[cont,1], organism_mover[cont,2], new_organism_bearing, organism_distance)#
						organism_long_matrix[organism_row, ot + 1] <- new_organism_loc$long#
    					organism_lat_matrix[organism_row, ot + 1] <- new_organism_loc$lat#
					}#
				}#
			}#
		}#
		for (f in 1:organism_multiplier) {#
            if (sum(alive) == 0) stop("METEOR IMPACT!! EVERYTHING HAS GONE EXTINCT! AAAAHHHHHH!!!")#
            dt<-1#
            ot <- ot + dt#
            for (m in 1:nrow(organism_lat_matrix)) {#
                if (alive[m]) {#
                    starting<-c(organism_lat_matrix[m,ot],organism_long_matrix[m,ot])#
                    moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd))) #generates a random walk step and calculates new position#
                    on_cont <- as.numeric(rownames(organism_lat_matrix)[m])#
                    friends <- as.numeric(strsplit(tail(touching, n=1)[[1]][which_supercontinent(on_cont, tail(touching, n=1)[[1]])], "&")[[1]])#
                    dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    if (length(friends) > 1) {#
                    	all_dist <- vector(length = length(friends))#
                    	for (g in 1:length(friends)) {#
                    		all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    	}#
                    	while (min(all_dist) > radius) {#
                    		moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		temp_all_dist <- vector(length = length(friends))#
                    		for (g in 1:length(friends)) {#
                    			temp_all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    		}#
                    		all_dist <- temp_all_dist#
                    	}#
                    	new_cont <- friends[which(all_dist == min(all_dist))] #
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                    	rownames(organism_long_matrix)[m] <- new_cont#
                    	rownames(organism_lat_matrix)[m] <- new_cont#
                    	if(new_cont != on_cont) {#
                    		dispersals <- rbind(dispersals, c(on_cont, new_cont, m, t, ot+1))#
                    	}#
                    } else {#
                    	while (dist_from_center >= radius) {#
                    		moveto <- EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    	}#
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                	}#
                }#
            }#
#
            r <- runif(1)#
            if (r <= b/(b + d)) { ###4 #this creates a bifucation in the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                e <- matrix(edge[alive,], ncol = 2)#
                parent <- e[random_lineage,2]#
                x <- which(edge[,2] == parent)#
                new.rows.lat <- new.rows.long <- extra.rows#
                new.rows.lat[, ot+1] <- organism_lat_matrix[x, ot+1] #updates the long and lat matricies with new coordiantes for each lineage#
                new.rows.long[, ot+1] <- organism_long_matrix[x, ot+1]#
                rownames(new.rows.lat) <- rep(rownames(organism_lat_matrix)[x],2)#
                rownames(new.rows.long) <- rep(rownames(organism_long_matrix)[x],2)#
                organism_lat_matrix <- rbind(organism_lat_matrix,new.rows.lat)#
                organism_long_matrix <- rbind(organism_long_matrix,new.rows.long)#
                alive[alive][random_lineage] <- FALSE#
                edge <- rbind(edge, c(parent, next.node), c(parent, next.node + 1))#
                next.node <- next.node + 2#
                alive <- c(alive, TRUE, TRUE)#
                stem.depth <- c(stem.depth, ot, ot)#
                edge.length[x] <- ot - stem.depth[x]#
                edge.length<-c(edge.length, NA, NA)#
            } else {###4 This terminates one of the current lineages on the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                edge.length[alive][random_lineage] <- ot - stem.depth[alive][random_lineage]#
                alive[alive][random_lineage] <- FALSE#
            }###4#
        }#1A#
        if (any(progress == t)) {#
        	cat("- ")#
        }#
    }#
#
    #Things to do right at the end to turn it into a phylo object#
    edge.length[alive] <- ot - stem.depth[alive];#
    n <- -1#
    for (f in 1:max(edge)) {#
        if (any(edge[,1] == f)) {#
           	edge[which(edge[,1] == f), 1] <- n#
           	edge[which(edge[,2] == f), 2] <- n#
           	n <- n - 1;#
        }#
    }#
    edge[edge > 0] <- 1:sum(edge > 0)#
   	tip.label <- 1:sum(edge > 0)#
    mode(edge) <- "character"#
    mode(tip.label) <- "character"#
    obj <- list(edge = edge, edge.length = edge.length, tip.label=tip.label)#
    class(obj) <- "phylo"#
    obj <- old2new.phylo(obj)#
    obj$tip.label = paste("s", 1:Ntip(obj), sep = "")#
	# Add final time step to continental configurations:#
	names(linked)[length(linked)] <- paste(strsplit(names(linked)[length(linked)], ":")[[1]][1], ":", t, sep="")#
	output <- list(position, linked, touching, obj, organism_long_matrix, organism_lat_matrix, dispersals)#
	names(output) <- c("continent_positions", "continent_clusters", "continent_overlaps", "tree", "organism_longitudes", "organism_latitudes", "dispersals")
dispersals
# Subfunction to find out which supercontinent a circle belongs to:#
	which_supercontinent <- function(cont, sprconts){#
		cont <- as.character(cont)#
		result <- which(unlist(lapply(lapply(lapply(strsplit(sprconts, "&"), match, cont), sort), length)) == 1)#
		return(result)#
	}#
	# Start by picking continent start points:#
	continent_starting_points <- StartingPoints(N_continents = N_continents, radius = radius, start_configuration = start_configuration, squishiness = squishiness, EarthRad = EarthRad, polar = polar)#
# Are any continents joined at start?:#
#
	# Get minimum_continental separation:#
	min_separation <- (1 - squishiness) * radius * 2#
#
	# Get list of separate continents:#
	separate_continents <- HowManySeparateContinents(min_separation, continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
#
	# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
	touching_continents <- HowManySeparateContinents((radius * 2), continent_starting_points[, "Longitude"], continent_starting_points[, "Latitude"])#
# Assign Euler poles to each separate continent:#
	# Randomly draw longitudes for each separated continent:#
	euler_pole_longitudes <- runif(length(separate_continents), -180, 180)#
	# Randomly draw latitudes for each separated continent:#
	euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
	# Ensure no latitude is directly at a pole (North or South) by redrawing if any are found:#
	if((sum(euler_pole_latitudes == 90) + sum(euler_pole_latitudes == -90)) > 0) euler_pole_latitudes <- runif(length(separate_continents), -90, 90)#
#
# Assign speeds to each separate continent:#
	# Create empty vector to store degrees per step (effectively the speed of movement) for each continent:#
	degrees_per_step <- vector(mode="numeric")#
	# For each separate continent:#
	for(i in 1:length(separate_continents)) {#
		# Get Greate Circle distances from Euler pole to each continent centre:#
		euler_GC_distances <- One2ManyGreatCircleDistance(euler_pole_longitudes[i], euler_pole_latitudes[i], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Longitude"], continent_starting_points[as.numeric(unlist(strsplit(separate_continents[i], "&"))), "Latitude"])#
		# Find GC distance to furthest continent (closest to euler pole "equator") in cluster (as speed will be assigned based on this):#
		furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
		# Randomly draw a continent speed:#
		continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# If a negative or zero speed is picked then redraw:#
		while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
		# Set degree change per step (effectively the speed):#
		degrees_per_step[i] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
	}#
#
	#starting information for the tree#
	dispersals <- matrix(nrow = 0, ncol = 5, dimnames = list(c(), c("From_continent", "To_continent", "Branch", "Continent_time_step", "Animal_time_step")))#
	begin_cont <- ceiling(runif(1, 0, N_continents))#
	life_begins <- EndPoint(continent_starting_points[begin_cont, "Longitude"], continent_starting_points[begin_cont, "Latitude"], runif(1,0,360), runif(1,0,radius))#
	extra.rows <- matrix(NA,nrow=2,ncol= (N_steps * organism_multiplier) + 1)#
	organism_lat_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_long_matrix <- matrix(nrow=2,ncol=(N_steps * organism_multiplier) + 1)#
    organism_lat_matrix[,1] <- life_begins$lat#
    organism_long_matrix[,1] <- life_begins$lon#
    rownames(organism_lat_matrix) <- rep(begin_cont, 2)#
    rownames(organism_long_matrix) <- rep(begin_cont, 2)#
    edge <- rbind(c(1, 2), c(1, 3)) # this is a starting edge matrix#
    edge.length <- rep(NA, 2)#
    stem.depth <- numeric(2)#
    alive <- rep(TRUE, 2) # marker for live lineages#
    ot <- 0; # time(step) at any point in the tree#
    next.node <- 4#
#
	# Now need to move them!#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	linked <- list()#
	linked[[1]] <- separate_continents#
	names(linked)[[1]] <- "1:1"#
	#List to store which circles are in each supercontinent (new element added only when it changes)#
	touching <- list()#
	touching[[1]] <- touching_continents#
#
	#Array to store the positions of every continent at each time step#
	position <- array(NA, c(N_continents, N_steps + 1, 2), c("continent", "timestep", "coordinate"))#
	position[,1,1] <- continent_starting_points[,"Longitude"]#
	position[,1,2] <- continent_starting_points[,"Latitude"]#
#
	temp_position<-matrix(nrow = N_continents, ncol=2)#
#
	progress <- seq(1, N_steps, floor(N_steps/50))#
	cat("Starting time steps \n")#
	cat("Progress \n")#
	cat("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n")#
#
	#for loops to move everything#
	for (t in 2:(N_steps + 1)) {#
		#distances apart before they move#
		starting_distances <- GreatCircleDistanceMatrix(position[,t-1,1], position[,t-1,2])#
#
		for (k in 1:N_continents) {#
			#find current longlat of the circle k#
			start_long <- position[k, t-1, 1]#
			start_lat <- position[k, t-1, 2]#
#
			#Identify which supercontinent, and therefore which element of the euler pole and speed vectors, the circle k belongs to#
			where <- which_supercontinent(k, tail(linked, n=1)[[1]])#
#
			#Find distance of circle from pole#
			distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where], lat2=euler_pole_latitudes[where], Warn = FALSE)#
			#Find bearing of circle from pole#
			init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where], euler_pole_latitudes[where], start_long, start_lat)#
#
			#Find the new bearing of circle from pole according to the speed specified#
			new_bearing <- (init_bearing + degrees_per_step[where]) %% 360#
#
			#Find the new location of the circle#
			new_loc <- EndPoint(euler_pole_longitudes[where], euler_pole_latitudes[where], new_bearing, distance)#
#
			#Add the new loction to the position matrix#
			temp_position[k,1] <- new_loc$long#
			temp_position[k,2] <- new_loc$lat#
#
		}#
#
		#Matrix of the distances between each continent in their new positions, before these are set#
		new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
		comp1 <- vector()#
		comp2 <- vector()#
#
		#Making a vector of whether any continents have collided and should be linked#
		collisions<-matrix(nrow=0, ncol=2)#
		for (q in 1:(N_continents-1)) {#
			for (p in (q+1):N_continents) {#
				comp1 <- all.equal(new_distances[p,q],starting_distances[p,q])#
				comp2 <- new_distances[p,q] <= min_separation#
				if (comp1 != TRUE && comp2 == TRUE) {#
					collisions<-rbind(collisions,c(p,q))#
				}#
			}#
		}#
#
		#Matrix of euler poles and speeds for each individual continent for moving the animals later#
		organism_mover <- matrix(nrow=N_continents, ncol= 3)#
		for (clump in 1:length(tail(linked, n=1)[[1]])) {#
			which_conts <- as.numeric(strsplit(tail(linked, n=1)[[1]][[clump]], "&")[[1]])#
			organism_mover[which_conts,1] <- rep(euler_pole_longitudes[clump],length(which_conts))#
			organism_mover[which_conts,2] <- rep(euler_pole_latitudes[clump],length(which_conts))#
			#This bit will get overwritten if there are collisions#
			organism_mover[which_conts,3] <- rep(degrees_per_step[clump],length(which_conts))#
		}#
		perm_collisions <- matrix(nrow=0, ncol=2)#
#
		# Moving continents back if there has only been one collision#
		while(nrow(collisions) > 0) {#
#
			# Set up vector to store proportional changes after collisions#
			proportion <- vector()#
#
			# Find out proportions to reduce to for all potential collisions#
			for (coll in 1:nrow(collisions)) {#
				cont_1 <- collisions[coll,1]#
				cont_2 <- collisions[coll,2]#
				where_1 <- which_supercontinent(cont_1, tail(linked, n=1)[[1]])#
				where_2 <- which_supercontinent(cont_2, tail(linked, n=1)[[1]])#
				continent_1_euler_longitude = euler_pole_longitudes[where_1]#
				continent_1_euler_latitude = euler_pole_latitudes[where_1]#
				continent_2_euler_longitude = euler_pole_longitudes[where_2]#
				continent_2_euler_latitude = euler_pole_latitudes[where_2]#
				continent_1_degrees_per_step = degrees_per_step[where_1]#
				continent_2_degrees_per_step = degrees_per_step[where_2]#
				proportion[coll] <- ColliderReverser(min_separation, position[cont_1, t-1, 1], position[cont_1, t-1, 2], temp_position[cont_1,1], temp_position[cont_1,2], position[cont_2, t-1, 1], position[cont_2, t-1, 2], temp_position[cont_2,1], temp_position[cont_2,2], continent_1_euler_longitude, continent_1_euler_latitude, continent_2_euler_longitude, continent_2_euler_latitude, continent_1_degrees_per_step, continent_2_degrees_per_step, EarthRad = 6367.4447, Warn = FALSE)#
			}#
#
			# Select proportion to move for first collision#
			first_collision <- match(min(proportion),proportion)#
#
			# Find the two continents that collided first#
			cont_involved <- sort(collisions[first_collision, ])#
#
			# Add to matrix of definite collisions that cannot be separated in the next step#
			perm_collisions <- rbind(perm_collisions, cont_involved)#
#
			# Move first clump back#
			head_of_collision_1 <- cont_involved[1]#
			where_1 <- which_supercontinent(head_of_collision_1, tail(linked, n=1)[[1]])#
#
			#Find the other continents that were attached to the collider#
			all_involved <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_1], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents in one of the clumps#
			for (rev in 1:length(all_involved)) {#
				cont_to_rev <- all_involved[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_1], lat2=euler_pole_latitudes[where_1], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], start_long, start_lat)#
#
				#degrees to add#
				addition <- proportion[first_collision] * degrees_per_step[where_1]#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <- (init_bearing + addition) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_1], euler_pole_latitudes[where_1], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
#
				organism_mover[cont_to_rev,3] <- addition#
			}#
#
			#Move the second clump back#
			head_of_collision_2 <- cont_involved[2]#
			where_2 <- which_supercontinent(head_of_collision_2, tail(linked, n=1)[[1]])#
			all_involved_2 <- as.numeric(strsplit(tail(linked, n=1)[[1]][where_2], "&")[[1]])#
#
			#Update temporary positions based on new change in bearing for all the continents the other clump#
			for (rev in 1:length(all_involved_2)) {#
				cont_to_rev <- all_involved_2[rev]#
				start_long <- position[cont_to_rev, t-1, 1]#
				start_lat <- position[cont_to_rev, t-1, 2]#
				distance <- GreatCircleDistanceFromLongLat(long1=start_long,lat1=start_lat, long2=euler_pole_longitudes[where_2], lat2=euler_pole_latitudes[where_2], Warn = FALSE)#
				#Find bearing of circle from pole#
				init_bearing <- BearingBetweenTwoLongLatPoints(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], start_long, start_lat)#
#
				#Find the new bearing of circle from pole according to the speed specified#
				new_bearing <-  (init_bearing + (proportion[first_collision] * degrees_per_step[where_2])) %% 360#
#
				#Find the new location of the circle#
				new_loc <- EndPoint(euler_pole_longitudes[where_2], euler_pole_latitudes[where_2], new_bearing, distance)#
#
				#Add the new loction to the position matrix#
				temp_position[cont_to_rev,1] <- new_loc$long#
				temp_position[cont_to_rev,2] <- new_loc$lat#
			}#
#
			#Recalculate the new distances#
			new_distances <- GreatCircleDistanceMatrix(temp_position[,1], temp_position[,2])#
			comp1 <- vector()#
			comp2 <- vector()#
#
			# Check whether any other collisions have still occurred#
			collisions <- matrix(nrow=0, ncol=2)#
			for (q in 1:(N_continents - 1)) {#
				for (p in (q+1):N_continents) {#
					comp1 <- all.equal(new_distances[p, q], starting_distances[p, q])#
					comp2 <- new_distances[p, q] <= min_separation#
					if (comp1 != TRUE && comp2 == TRUE) {#
						# If collision has not already been recorded:#
						if(length(sort(match(paste(sort(c(q, p)), collapse=""), apply(perm_collisions, 1, paste, collapse="")))) == 0) {#
							# Record collision:#
							collisions <- rbind(collisions, c(p, q))#
						}#
					}#
				}#
			}#
		}#
#
		# When it finishes while loop can now 'ossify' the positions and move to selecting separations#
		position[, t, 1] <- temp_position[, 1]#
		position[, t, 2] <- temp_position[, 2]#
#
# Finding out if anything gets separated#
		# How many separate continents are there now? (after collisions may have occurred):#
		separate_continents <- HowManySeparateContinents(min_separation, position[,t,1], position[,t,2])#
		# Make random uniform draws for each continental cluster:#
		separation_draws <- runif(length(grep("&", separate_continents)))#
		# Case if a separation occurs (drawn value is equal to or exceeds stickiness):#
		if(any(separation_draws >= stickiness)) {#
			# Get clusters of continents to split apart:#
			clusters_to_split <- separate_continents[grep("&", separate_continents)][which(separation_draws >= stickiness)]#
			# For each cluster to split apart:#
			for(i in 1:length(clusters_to_split)) {#
				# Get numbers of continents involved:#
				cluster_continent_numbers <- sort(strsplit(clusters_to_split[i], "&")[[1]])#
				# Get longitudes of continents in cluster:#
				cluster_longitudes <- position[as.numeric(cluster_continent_numbers), t, 1]#
#
				# Get latitudes of continents in cluster:#
				cluster_latitudes <- position[as.numeric(cluster_continent_numbers), t, 2]#
				# Make protected links an empty matrix:#
				cluster_protected_links <- matrix(nrow = 0, ncol = 2)#
				# If there are recent collisions (that will potentially need to be excluded from new splits):#
				if(length(perm_collisions) > 0) {#
					# For each new collision:#
					for(j in 1:nrow(perm_collisions)) {#
						# If new collision occurs within the cluster:#
						if(length(intersect(as.character(perm_collisions[j, ]), cluster_continent_numbers)) == 2) {#
							# Add new collision to protected links list:#
							cluster_protected_links <- rbind(cluster_protected_links, perm_collisions[j, ])#
						}#
					}#
#
				}#
				# Get splits (new clusters) of separated cluster:#
				splits <- ContinentSplitter(min_separation, cluster_longitudes, cluster_latitudes, cluster_continent_numbers, cluster_protected_links, EarthRad)#
				# Update separate continents vector:#
				separate_continents <- sort(c(separate_continents[-match(clusters_to_split[i], separate_continents)], splits))#
			}#
		}#
#
# Now change the Euler poles and speeds#
		# Get list of touching continents (to be used later for whether dispersal is allowable or not):#
		touching_continents <- HowManySeparateContinents((radius * 2), position[,t,1], position[,t,2])#
		if (paste(sort(touching_continents), collapse="") != paste(sort(tail(touching,n=1)[[1]]), collapse="")) {#
			touching <- c(touching, list(touching_continents))#
		}#
#
		# If the continental clustering has changed:#
		if (paste(sort(separate_continents), collapse="") != paste(sort(tail(linked,n=1)[[1]]), collapse="")) {#
			# Add new continental configuration to linked list#
			linked <- c(linked, list(separate_continents))#
#
			# Update time step for previous continental configuration:#
			names(linked)[(length(linked) - 1)] <- paste(strsplit(names(linked[(length(linked) - 1)]), ":")[[1]][1], ":", t - 1, sep="")#
			# Add time step to new continental configuration:#
			names(linked)[length(linked)] <- paste(t, ":", t, sep="")#
			# Select continents that are different to previous time step#
			toKeep <- c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]])[duplicated(c(tail(linked,n=1)[[1]], tail(linked, n=2)[[1]]))]#
#
			#Vectors for new poles and speeds#
			new_euler_latitudes <- rep(NA, length(separate_continents))#
			new_euler_longitudes <- rep(NA, length(separate_continents))#
			new_degrees_per_step <- rep(NA, length(separate_continents))#
#
			if (length(toKeep) != 0){#
				#Inherit previous poles and speeds for those clumps that remain the same#
				for (y in 1:length(toKeep)) {#
					new_euler_longitudes[match(toKeep[y],separate_continents)]<- euler_pole_longitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_euler_latitudes[match(toKeep[y],separate_continents)]<- euler_pole_latitudes[match(toKeep[y],tail(linked, n=2)[[1]])]#
					new_degrees_per_step[match(toKeep[y],separate_continents)]<- degrees_per_step[match(toKeep[y],tail(linked, n=2)[[1]])]#
				}#
			}#
#
			# Make new Euler poles#
			new_euler_longitudes[is.na(new_euler_longitudes)]<- runif((length(separate_continents)-length(toKeep)), -180, 180)#
#
			changed_euler_latitudes<- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			while((sum(changed_euler_latitudes == 90) + sum(changed_euler_latitudes == -90)) > 0) changed_euler_latitudes <- runif((length(separate_continents)-length(toKeep)), -90, 90)#
			new_euler_latitudes[is.na(new_euler_latitudes)] <- changed_euler_latitudes#
#
			# Get Great Circle distances from Euler pole to each continent centre:#
			for (l in 1:(length(separate_continents)-length(toKeep))) {#
				# Find the first NA to fill in:#
				changer <- match(NA, new_degrees_per_step)#
				#Find the contients that are in the clump whose speed is going to change#
				rows <- as.numeric(unlist(strsplit(separate_continents[changer], "&")))#
				#Find the new euler pole for that clump#
				euler_long <- new_euler_longitudes[changer]#
				euler_lat <- new_euler_latitudes[changer]#
				#Find the distances of each of the continents in the clump from their new euler pole#
				euler_GC_distances <- One2ManyGreatCircleDistance(euler_long, euler_lat, position[rows, t, 1], position[rows, t, 2])#
				#Find which of those is closest to the equator#
				furthest_continent_GC_distance <- (0.5 * pi * EarthRad) - min(abs(euler_GC_distances - (0.5 * pi * EarthRad)))#
				# Randomly draw a continent speed:#
				continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# If a negative or zero speed is picked then redraw:#
				while(continent_speed <= 0) continent_speed <- rnorm(1, mean = continent_speed_mean, sd = continent_speed_sd)#
				# Set degree change per step (effectively the speed):#
				new_degrees_per_step[changer] <- continent_speed / (2 * pi * furthest_continent_GC_distance) * 360#
			}#
			euler_pole_longitudes <- new_euler_longitudes#
			euler_pole_latitudes <- new_euler_latitudes#
			degrees_per_step <- new_degrees_per_step#
		}#
#
#Need to add in the tree bit#
		#Move the animals with the continents#
		for (cont in 1:N_continents) {#
			#Find the rows that are in the continent of focus#
			moving <- which(rownames(organism_long_matrix)==cont)#
#
			if (length(moving)==0) {#
				next #
			} else {#
				#Find out how many degrees around the euler pole that continent went#
				organism_degrees <- organism_mover[cont,3]#
				#loops through all the organisms that are currently living#
				for (organism in 1:length(moving)) {#
					organism_row <- moving[organism]#
					if (is.na(organism_long_matrix[organism_row, ot + 1])) {#
						next#
					} else {#
						first_long <- organism_long_matrix[organism_row, ot + 1]#
						first_lat <- organism_lat_matrix[organism_row, ot + 1]#
						organism_distance <- GreatCircleDistanceFromLongLat(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						organism_bearing <- BearingBetweenTwoLongLatPoints(organism_mover[cont,1], organism_mover[cont,2], first_long, first_lat)#
						new_organism_bearing <- (organism_bearing + organism_degrees) %% 360#
						new_organism_loc <- EndPoint(organism_mover[cont,1], organism_mover[cont,2], new_organism_bearing, organism_distance)#
						organism_long_matrix[organism_row, ot + 1] <- new_organism_loc$long#
    					organism_lat_matrix[organism_row, ot + 1] <- new_organism_loc$lat#
					}#
				}#
			}#
		}#
		for (f in 1:organism_multiplier) {#
            if (sum(alive) == 0) stop("METEOR IMPACT!! EVERYTHING HAS GONE EXTINCT! AAAAHHHHHH!!!")#
            dt<-1#
            ot <- ot + dt#
            for (m in 1:nrow(organism_lat_matrix)) {#
                if (alive[m]) {#
                    starting<-c(organism_lat_matrix[m,ot],organism_long_matrix[m,ot])#
                    moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd))) #generates a random walk step and calculates new position#
                    on_cont <- as.numeric(rownames(organism_lat_matrix)[m])#
                    friends <- as.numeric(strsplit(tail(touching, n=1)[[1]][which_supercontinent(on_cont, tail(touching, n=1)[[1]])], "&")[[1]])#
                    dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    if (length(friends) > 1) {#
                    	all_dist <- vector(length = length(friends))#
                    	for (g in 1:length(friends)) {#
                    		all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    	}#
                    	while (min(all_dist) > radius) {#
                    		moveto<-EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		temp_all_dist <- vector(length = length(friends))#
                    		for (g in 1:length(friends)) {#
                    			temp_all_dist [g] <- GreatCircleDistanceFromLongLat(position[friends[g], t, 1], position[friends[g], t, 2], moveto$long, moveto$lat)#
                    		}#
                    		all_dist <- temp_all_dist#
                    	}#
                    	new_cont <- friends[which(all_dist == min(all_dist))] #
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                    	rownames(organism_long_matrix)[m] <- new_cont#
                    	rownames(organism_lat_matrix)[m] <- new_cont#
                    	if(new_cont != on_cont) {#
                    		dispersals <- rbind(dispersals, c(on_cont, new_cont, m, t, ot+1))#
                    	}#
                    } else {#
                    	while (dist_from_center >= radius) {#
                    		moveto <- EndPoint(starting[2],starting[1],runif(1,0,360),abs(rnorm(1,0,organism_step_sd)))#
                    		dist_from_center <- GreatCircleDistanceFromLongLat(position[on_cont, t, 1], position[on_cont, t, 2], moveto$long, moveto$lat)#
                    	}#
                    	organism_lat_matrix[m,ot+1]<-moveto$lat#
                    	organism_long_matrix[m,ot+1]<-moveto$long#
                	}#
                }#
            }#
#
            r <- runif(1)#
            if (r <= b/(b + d)) { ###4 #this creates a bifucation in the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                e <- matrix(edge[alive,], ncol = 2)#
                parent <- e[random_lineage,2]#
                x <- which(edge[,2] == parent)#
                new.rows.lat <- new.rows.long <- extra.rows#
                new.rows.lat[, ot+1] <- organism_lat_matrix[x, ot+1] #updates the long and lat matricies with new coordiantes for each lineage#
                new.rows.long[, ot+1] <- organism_long_matrix[x, ot+1]#
                rownames(new.rows.lat) <- rep(rownames(organism_lat_matrix)[x],2)#
                rownames(new.rows.long) <- rep(rownames(organism_long_matrix)[x],2)#
                organism_lat_matrix <- rbind(organism_lat_matrix,new.rows.lat)#
                organism_long_matrix <- rbind(organism_long_matrix,new.rows.long)#
                alive[alive][random_lineage] <- FALSE#
                edge <- rbind(edge, c(parent, next.node), c(parent, next.node + 1))#
                next.node <- next.node + 2#
                alive <- c(alive, TRUE, TRUE)#
                stem.depth <- c(stem.depth, ot, ot)#
                edge.length[x] <- ot - stem.depth[x]#
                edge.length<-c(edge.length, NA, NA)#
            } else {###4 This terminates one of the current lineages on the tree#
                random_lineage <- round(runif(1, min = 1, max = sum(alive)))#
                edge.length[alive][random_lineage] <- ot - stem.depth[alive][random_lineage]#
                alive[alive][random_lineage] <- FALSE#
            }###4#
        }#1A#
        if (any(progress == t)) {#
        	cat("- ")#
        }#
    }#
#
    #Things to do right at the end to turn it into a phylo object#
    edge.length[alive] <- ot - stem.depth[alive];#
    n <- -1#
    for (f in 1:max(edge)) {#
        if (any(edge[,1] == f)) {#
           	edge[which(edge[,1] == f), 1] <- n#
           	edge[which(edge[,2] == f), 2] <- n#
           	n <- n - 1;#
        }#
    }#
    edge[edge > 0] <- 1:sum(edge > 0)#
   	tip.label <- 1:sum(edge > 0)#
    mode(edge) <- "character"#
    mode(tip.label) <- "character"#
    obj <- list(edge = edge, edge.length = edge.length, tip.label=tip.label)#
    class(obj) <- "phylo"#
    obj <- old2new.phylo(obj)#
    obj$tip.label = paste("s", 1:Ntip(obj), sep = "")#
	# Add final time step to continental configurations:#
	names(linked)[length(linked)] <- paste(strsplit(names(linked)[length(linked)], ":")[[1]][1], ":", t, sep="")#
	output <- list(position, linked, touching, obj, organism_long_matrix, organism_lat_matrix, dispersals)#
	names(output) <- c("continent_positions", "continent_clusters", "continent_overlaps", "tree", "organism_longitudes", "organism_latitudes", "dispersals")
dispersals
try <- output#
plot(try$organism_longitudes[1,], try$organism_latitudes[1,], xlim=c(-180, 180), ylim=c(-90, 90), type = "l")#
for (i in 1:nrow(try$organism_longitudes))   lines(try$organism_longitudes[i,], try$organism_latitudes[i,])#
for(i in 1:N_continents) points(try$continent_positions[i,,1], try$continent_positions[i,,2], col=rainbow(N_steps))
document()
check()
touching
plot(tree)
plot(obj)
plot(ladderize(obj))
ladderize(obj)
ladderize(obj)
obj
class(obj)
obj
plot(obj)
ladderize(obj)
obj
write.tree(obj)
read.tree(text=write.tree(obj))
ladderize(read.tree(text=write.tree(obj)))
plot(ladderize(read.tree(text=write.tree(obj))))
document()
document()
document()
install()
??ArcIntersection
?ArcIntersection
?GreatCircleDistanceFromLongLat
check()
